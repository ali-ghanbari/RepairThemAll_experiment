{
  "repair_end": "2018-12-01 15:39:29.417661", 
  "repair_begin": "2018-12-01 14:58:00.471043", 
  "patches": [
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1387/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:19:39.055863522 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_38/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:05:07.043794240 -0500\n@@ -196,22 +196,6 @@\n      */\n     private void visitBreakOrContinue(Node node) {\n       Node nameNode = node.getFirstChild();\n-      if (nameNode != null) {\n-        // This is a named break or continue;\n-        String name = nameNode.getString();\n-        Preconditions.checkState(name.length() != 0);\n-        LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n-      }\n     }\n \n     /**\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_38/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:05:07.043794240 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:57:38.329845888 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_38/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:05:07.043794240 -0500\n@@ -1427,11 +1427,7 @@\n   public String checkTreeEquals(Node node2) {\n       NodeMismatch diff = checkTreeEqualsImpl(node2);\n       if (diff != null) {\n-        return \"Node tree inequality:\" +\n-            \"\\nTree1:\\n\" + toStringTree() +\n-            \"\\n\\nTree2:\\n\" + node2.toStringTree() +\n-            \"\\n\\nSubtree1: \" + diff.nodeA.toStringTree() +\n-            \"\\n\\nSubtree2: \" + diff.nodeB.toStringTree();\n+        return \"SCRIPT\";\n       }\n       return null;\n   }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 199, 
          "faulty": "if (nameNode != null) {\n  String name=nameNode.getString();\n  Preconditions.checkState(name.length() != 0);\n  LabelInfo li=getLabelInfo(name);\n  if (li != null) {\n    String newName=getNameForId(li.id);\n    li.referenced=true;\n    if (!name.equals(newName)) {\n      nameNode.setString(newName);\n      compiler.reportCodeChange();\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1430, 
          "faulty": "return \"Node tree inequality:\" + \"\\nTree1:\\n\" + toStringTree() + \"\\n\\nTree2:\\n\"+ node2.toStringTree()+ \"\\n\\nSubtree1: \"+ diff.nodeA.toStringTree()+ \"\\n\\nSubtree2: \"+ diff.nodeB.toStringTree();", 
          "type": "Replace", 
          "seed": "return \"SCRIPT\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2951/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:35:38.954260196 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1750/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:23:48.751583263 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1750/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:23:48.751583263 -0500\n@@ -886,7 +886,8 @@\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n         if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n+          this.module = null;\n+\t\ti.remove();\n         }\n       }\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 889, 
          "faulty": "i.remove();", 
          "type": "InsertBefore", 
          "seed": "this.module=null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1916/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:25:30.757134928 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2022/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:26:28.842004864 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_349/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:09:18.251129046 -0500\n@@ -208,7 +208,6 @@\n           if (!name.equals(newName)) {\n             // Give it the short name.\n             nameNode.setString(newName);\n-            compiler.reportCodeChange();\n           }\n         }\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_349/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:09:18.255129100 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 211, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1960/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:25:55.041499648 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2796/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:34:04.132857072 -0500\n@@ -206,8 +206,6 @@\n           // Mark the label as referenced so it isn't removed.\n           li.referenced = true;\n           if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n             compiler.reportCodeChange();\n           }\n         }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2796/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:34:04.132857072 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 210, 
          "faulty": "nameNode.setString(newName);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2032/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:26:33.646076461 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2491/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:31:23.930461309 -0500\n@@ -208,7 +208,6 @@\n           if (!name.equals(newName)) {\n             // Give it the short name.\n             nameNode.setString(newName);\n-            compiler.reportCodeChange();\n           }\n         }\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2491/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:31:23.934461369 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2491/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:31:23.934461369 -0500\n@@ -885,9 +885,7 @@\n       Iterator<Entry<Node, Reference>> i;\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n-        if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n-        }\n+        this.module = null;\n       }\n     }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 888, 
          "faulty": "if (entry.getValue().mode == InliningMode.BLOCK) {\n  i.remove();\n}", 
          "type": "Replace", 
          "seed": "this.module=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 211, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_474/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:10:46.444323162 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:57:38.329845888 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_474/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:10:46.444323162 -0500\n@@ -1456,7 +1456,8 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        parent = null;\n+\t\treturn res;\n       }\n     }\n     return res;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1459, 
          "faulty": "return res;", 
          "type": "InsertBefore", 
          "seed": "parent=null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1808/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:24:18.728042983 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_975/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:15:41.076418097 -0500\n@@ -203,12 +203,9 @@\n         LabelInfo li = getLabelInfo(name);\n         if (li != null) {\n           String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n           if (!name.equals(newName)) {\n             // Give it the short name.\n             nameNode.setString(newName);\n-            compiler.reportCodeChange();\n           }\n         }\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_975/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:15:41.080418156 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 207, 
          "faulty": "li.referenced=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 211, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1360/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:19:18.639570093 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_623/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:12:24.353666472 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\t2018-12-01 08:57:38.101845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_623/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\t2018-12-01 09:12:24.357666528 -0500\n@@ -63,10 +63,6 @@\n     if (node.isName()) {\n       Node replacementTemplate = replacements.get(node.getString());\n       if (replacementTemplate != null) {\n-        // This should not be replacing declared names.\n-        Preconditions.checkState(!parent.isFunction()\n-            || !parent.isVar()\n-            || !parent.isCatch());\n         // The name may need to be replaced more than once,\n         // so we need to clone the node.\n         Node replacement = replacementTemplate.cloneTree();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionArgumentInjector.java", 
          "line": 67, 
          "faulty": "Preconditions.checkState(!parent.isFunction() || !parent.isVar() || !parent.isCatch());", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_588/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:12:04.797396977 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_588/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:12:04.797396977 -0500\n@@ -688,7 +688,6 @@\n     if (!inliningLowersCost(fs)) {\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n-        fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 691, 
          "faulty": "fs.setRemove(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3003/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:36:06.250668769 -0500\n@@ -185,7 +185,7 @@\n \n         case Token.BREAK:\n         case Token.CONTINUE:\n-          visitBreakOrContinue(node);\n+          ;\n           break;\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3003/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:36:06.254668828 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 188, 
          "faulty": "visitBreakOrContinue(node);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1070/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:16:37.505241173 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2100/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:27:14.514683621 -0500\n@@ -208,7 +208,6 @@\n           if (!name.equals(newName)) {\n             // Give it the short name.\n             nameNode.setString(newName);\n-            compiler.reportCodeChange();\n           }\n         }\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2100/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:27:14.514683621 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 211, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2762/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:33:47.188605786 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1731/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:23:33.059341166 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1508/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:21:09.141155163 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_565/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:11:52.873232921 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_254/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:08:17.082312999 -0500\n@@ -185,7 +185,7 @@\n \n         case Token.BREAK:\n         case Token.CONTINUE:\n-          visitBreakOrContinue(node);\n+          ;\n           break;\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_254/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:08:17.082312999 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 188, 
          "faulty": "visitBreakOrContinue(node);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2549/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:31:53.602908947 -0500\n@@ -201,16 +201,6 @@\n         String name = nameNode.getString();\n         Preconditions.checkState(name.length() != 0);\n         LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n       }\n     }\n \n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2549/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:31:53.602908947 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 204, 
          "faulty": "if (li != null) {\n  String newName=getNameForId(li.id);\n  li.referenced=true;\n  if (!name.equals(newName)) {\n    nameNode.setString(newName);\n    compiler.reportCodeChange();\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_178/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:07:19.797560568 -0500\n@@ -727,9 +727,6 @@\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2955/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:35:40.886289158 -0500\n@@ -206,8 +206,6 @@\n           // Mark the label as referenced so it isn't removed.\n           li.referenced = true;\n           if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n             compiler.reportCodeChange();\n           }\n         }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2955/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:35:40.890289218 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionToBlockMutator.java\t2018-12-01 08:57:38.101845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2955/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionToBlockMutator.java\t2018-12-01 09:35:40.890289218 -0500\n@@ -198,7 +198,7 @@\n \n     @Override\n     public String get() {\n-        return \"JSCompiler_inline_label_\" + idSupplier.get();\n+        return null;\n     }\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 210, 
          "faulty": "nameNode.setString(newName);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionToBlockMutator.java", 
          "line": 201, 
          "faulty": "return \"JSCompiler_inline_label_\" + idSupplier.get();", 
          "type": "Replace", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2670/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:32:54.995828999 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2670/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:32:54.995828999 -0500\n@@ -691,7 +691,6 @@\n         fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n-          return false;\n         }\n       } else {\n         return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 694, 
          "faulty": "return false;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2968/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:35:47.878393917 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2968/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:35:47.882393977 -0500\n@@ -885,9 +885,7 @@\n       Iterator<Entry<Node, Reference>> i;\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n-        if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n-        }\n+        this.module = null;\n       }\n     }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 888, 
          "faulty": "if (entry.getValue().mode == InliningMode.BLOCK) {\n  i.remove();\n}", 
          "type": "Replace", 
          "seed": "this.module=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3128/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:37:24.035826652 -0500\n@@ -205,11 +205,6 @@\n           String newName = getNameForId(li.id);\n           // Mark the label as referenced so it isn't removed.\n           li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n         }\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3128/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:37:24.035826652 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3128/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:37:24.035826652 -0500\n@@ -501,8 +501,6 @@\n         // This reference can not be directly inlined, see if\n         // block replacement inlining is possible.\n         mode = InliningMode.BLOCK;\n-        referenceAdded = maybeAddReferenceUsingMode(\n-            t, fs, callNode, module, mode);\n       }\n \n       if (!referenceAdded) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 504, 
          "faulty": "referenceAdded=maybeAddReferenceUsingMode(t,fs,callNode,module,mode);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 208, 
          "faulty": "if (!name.equals(newName)) {\n  nameNode.setString(newName);\n  compiler.reportCodeChange();\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1043/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:16:17.948956472 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1389/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:19:40.011877256 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1389/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:19:40.011877256 -0500\n@@ -688,7 +688,6 @@\n     if (!inliningLowersCost(fs)) {\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n-        fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 691, 
          "faulty": "fs.setRemove(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_507/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:11:14.372704724 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_507/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:11:14.372704724 -0500\n@@ -894,7 +894,7 @@\n     public boolean hasBlockInliningReferences() {\n       for (Reference r : getReferencesInternal().values()) {\n         if (r.mode == InliningMode.BLOCK) {\n-          return true;\n+          return false;\n         }\n       }\n       return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 897, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2872/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:34:52.177567533 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 731, 
          "faulty": "return CanInlineResult.NO;", 
          "type": "Replace", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_446/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:10:26.684054099 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 08:57:38.089845892 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_446/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 09:10:26.688054153 -0500\n@@ -106,7 +106,6 @@\n \n   void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n-      return;\n     }\n \n     int type = n.getType();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CodeGenerator.java", 
          "line": 109, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 731, 
          "faulty": "return CanInlineResult.NO;", 
          "type": "Delete", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3185/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:37:58.992344429 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1118/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:17:01.597591190 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 08:57:38.089845892 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1118/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 09:17:01.597591190 -0500\n@@ -106,7 +106,6 @@\n \n   void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n-      return;\n     }\n \n     int type = n.getType();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CodeGenerator.java", 
          "line": 109, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1445/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:20:09.816305094 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2768/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:33:50.080648704 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2145/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:27:49.787205166 -0500\n@@ -201,16 +201,6 @@\n         String name = nameNode.getString();\n         Preconditions.checkState(name.length() != 0);\n         LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n       }\n     }\n \n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2145/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:27:49.787205166 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2145/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:27:49.787205166 -0500\n@@ -690,9 +690,7 @@\n       if (fs.hasBlockInliningReferences()) {\n         fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n-        if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n-          return false;\n-        }\n+        return false;\n       } else {\n         return false;\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 693, 
          "faulty": "if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 204, 
          "faulty": "if (li != null) {\n  String newName=getNameForId(li.id);\n  li.referenced=true;\n  if (!name.equals(newName)) {\n    nameNode.setString(newName);\n    compiler.reportCodeChange();\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2124/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:27:27.054869287 -0500\n@@ -205,11 +205,6 @@\n           String newName = getNameForId(li.id);\n           // Mark the label as referenced so it isn't removed.\n           li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n         }\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2124/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:27:27.054869287 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2124/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:27:27.054869287 -0500\n@@ -501,8 +501,6 @@\n         // This reference can not be directly inlined, see if\n         // block replacement inlining is possible.\n         mode = InliningMode.BLOCK;\n-        referenceAdded = maybeAddReferenceUsingMode(\n-            t, fs, callNode, module, mode);\n       }\n \n       if (!referenceAdded) {\n@@ -894,7 +892,6 @@\n     public boolean hasBlockInliningReferences() {\n       for (Reference r : getReferencesInternal().values()) {\n         if (r.mode == InliningMode.BLOCK) {\n-          return true;\n         }\n       }\n       return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 897, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "this.module=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 504, 
          "faulty": "referenceAdded=maybeAddReferenceUsingMode(t,fs,callNode,module,mode);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 208, 
          "faulty": "if (!name.equals(newName)) {\n  nameNode.setString(newName);\n  compiler.reportCodeChange();\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3028/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:36:24.806945801 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2876/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:34:54.129596340 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2876/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:34:54.129596340 -0500\n@@ -883,7 +883,8 @@\n \n     void removeBlockInliningReferences() {\n       Iterator<Entry<Node, Reference>> i;\n-      for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n+      this.module = null;\n+\tfor (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n         if (entry.getValue().mode == InliningMode.BLOCK) {\n           i.remove();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 886, 
          "faulty": "for (i=getReferencesInternal().entrySet().iterator(); i.hasNext(); ) {\n  Entry<Node,Reference> entry=i.next();\n  if (entry.getValue().mode == InliningMode.BLOCK) {\n    i.remove();\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "this.module=null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2823/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:34:20.693102284 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2823/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:34:20.693102284 -0500\n@@ -690,9 +690,6 @@\n       if (fs.hasBlockInliningReferences()) {\n         fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n-        if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n-          return false;\n-        }\n       } else {\n         return false;\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 693, 
          "faulty": "if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1653/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:22:41.590539228 -0500\n@@ -206,8 +206,6 @@\n           // Mark the label as referenced so it isn't removed.\n           li.referenced = true;\n           if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n             compiler.reportCodeChange();\n           }\n         }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1653/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:22:41.590539228 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 210, 
          "faulty": "nameNode.setString(newName);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2619/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:32:30.027455727 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2573/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:32:06.067096369 -0500\n@@ -205,11 +205,6 @@\n           String newName = getNameForId(li.id);\n           // Mark the label as referenced so it isn't removed.\n           li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n         }\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2573/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:32:06.071096430 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 208, 
          "faulty": "if (!name.equals(newName)) {\n  nameNode.setString(newName);\n  compiler.reportCodeChange();\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_920/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:15:06.507917414 -0500\n@@ -203,8 +203,6 @@\n         LabelInfo li = getLabelInfo(name);\n         if (li != null) {\n           String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n           if (!name.equals(newName)) {\n             // Give it the short name.\n             nameNode.setString(newName);\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_920/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:15:06.507917414 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 207, 
          "faulty": "li.referenced=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2266/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:29:01.528276363 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1347/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:19:11.971474193 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2067/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:26:52.814361645 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1592/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:22:03.953944026 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3206/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:38:10.632516543 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2050/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:26:44.210233727 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_491/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:11:00.416513873 -0500\n@@ -203,8 +203,6 @@\n         LabelInfo li = getLabelInfo(name);\n         if (li != null) {\n           String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n           if (!name.equals(newName)) {\n             // Give it the short name.\n             nameNode.setString(newName);\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_491/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:11:00.420513928 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 207, 
          "faulty": "li.referenced=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1948/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:25:48.261397973 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1948/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:25:48.265398033 -0500\n@@ -690,9 +690,6 @@\n       if (fs.hasBlockInliningReferences()) {\n         fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n-        if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n-          return false;\n-        }\n       } else {\n         return false;\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 693, 
          "faulty": "if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1694/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:23:08.682962944 -0500\n@@ -208,7 +208,6 @@\n           if (!name.equals(newName)) {\n             // Give it the short name.\n             nameNode.setString(newName);\n-            compiler.reportCodeChange();\n           }\n         }\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1694/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:23:08.686963006 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 211, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3014/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:36:11.970754226 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1611/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:22:19.630192928 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:57:38.329845888 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1611/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:22:19.630192928 -0500\n@@ -1427,11 +1427,7 @@\n   public String checkTreeEquals(Node node2) {\n       NodeMismatch diff = checkTreeEqualsImpl(node2);\n       if (diff != null) {\n-        return \"Node tree inequality:\" +\n-            \"\\nTree1:\\n\" + toStringTree() +\n-            \"\\n\\nTree2:\\n\" + node2.toStringTree() +\n-            \"\\n\\nSubtree1: \" + diff.nodeA.toStringTree() +\n-            \"\\n\\nSubtree2: \" + diff.nodeB.toStringTree();\n+        return \"SCRIPT\";\n       }\n       return null;\n   }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1430, 
          "faulty": "return \"Node tree inequality:\" + \"\\nTree1:\\n\" + toStringTree() + \"\\n\\nTree2:\\n\"+ node2.toStringTree()+ \"\\n\\nSubtree1: \"+ diff.nodeA.toStringTree()+ \"\\n\\nSubtree2: \"+ diff.nodeB.toStringTree();", 
          "type": "Replace", 
          "seed": "return \"SCRIPT\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2415/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:30:37.301753214 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3306/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:39:14.189454015 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3306/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:39:14.189454015 -0500\n@@ -688,7 +688,6 @@\n     if (!inliningLowersCost(fs)) {\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n-        fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 691, 
          "faulty": "fs.setRemove(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:57:38.329845888 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1061/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:16:32.721171576 -0500\n@@ -1443,7 +1443,8 @@\n    */\n   NodeMismatch checkTreeEqualsImpl(Node node2) {\n     if (!isEquivalentTo(node2, false, false, false)) {\n-      return new NodeMismatch(this, node2);\n+      sourcePosition = -1;\n+\treturn new NodeMismatch(this, node2);\n     }\n \n     NodeMismatch res = null;\n@@ -1456,7 +1457,7 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        parent = null;\n       }\n     }\n     return res;\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1061/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:16:32.725171635 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1446, 
          "faulty": "return new NodeMismatch(this,node2);", 
          "type": "InsertBefore", 
          "seed": "sourcePosition=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1459, 
          "faulty": "return res;", 
          "type": "Replace", 
          "seed": "parent=null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_562/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:11:45.797135666 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_448/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:10:27.636067043 -0500\n@@ -727,9 +727,6 @@\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 731, 
          "faulty": "return CanInlineResult.NO;", 
          "type": "Delete", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3081/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:36:58.939454008 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1735/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:23:34.971370721 -0500\n@@ -208,7 +208,6 @@\n           if (!name.equals(newName)) {\n             // Give it the short name.\n             nameNode.setString(newName);\n-            compiler.reportCodeChange();\n           }\n         }\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1735/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:23:34.971370721 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1735/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:23:34.971370721 -0500\n@@ -894,7 +894,7 @@\n     public boolean hasBlockInliningReferences() {\n       for (Reference r : getReferencesInternal().values()) {\n         if (r.mode == InliningMode.BLOCK) {\n-          return true;\n+          return false;\n         }\n       }\n       return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 897, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 211, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2386/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:30:16.845440530 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2386/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:30:16.845440530 -0500\n@@ -885,9 +885,6 @@\n       Iterator<Entry<Node, Reference>> i;\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n-        if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n-        }\n       }\n     }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 888, 
          "faulty": "if (entry.getValue().mode == InliningMode.BLOCK) {\n  i.remove();\n}", 
          "type": "Delete", 
          "seed": "this.module=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2609/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:32:25.191383291 -0500\n@@ -185,7 +185,7 @@\n \n         case Token.BREAK:\n         case Token.CONTINUE:\n-          visitBreakOrContinue(node);\n+          ;\n           break;\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2609/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:32:25.191383291 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 188, 
          "faulty": "visitBreakOrContinue(node);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1539/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:21:25.413388018 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2527/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:31:42.142736310 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_464/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:10:35.500174045 -0500\n@@ -185,7 +185,7 @@\n \n         case Token.BREAK:\n         case Token.CONTINUE:\n-          visitBreakOrContinue(node);\n+          ;\n           break;\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_464/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:10:35.504174100 -0500\n@@ -727,9 +727,6 @@\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\t2018-12-01 08:57:38.101845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_464/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\t2018-12-01 09:10:35.504174100 -0500\n@@ -63,10 +63,6 @@\n     if (node.isName()) {\n       Node replacementTemplate = replacements.get(node.getString());\n       if (replacementTemplate != null) {\n-        // This should not be replacing declared names.\n-        Preconditions.checkState(!parent.isFunction()\n-            || !parent.isVar()\n-            || !parent.isCatch());\n         // The name may need to be replaced more than once,\n         // so we need to clone the node.\n         Node replacement = replacementTemplate.cloneTree();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 188, 
          "faulty": "visitBreakOrContinue(node);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionArgumentInjector.java", 
          "line": 67, 
          "faulty": "Preconditions.checkState(!parent.isFunction() || !parent.isVar() || !parent.isCatch());", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_885/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:14:48.507666382 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3196/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:38:04.788430149 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2547/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:31:52.650894617 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1201/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:17:50.038292805 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:57:38.329845888 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1201/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:17:50.042292863 -0500\n@@ -1427,11 +1427,7 @@\n   public String checkTreeEquals(Node node2) {\n       NodeMismatch diff = checkTreeEqualsImpl(node2);\n       if (diff != null) {\n-        return \"Node tree inequality:\" +\n-            \"\\nTree1:\\n\" + toStringTree() +\n-            \"\\n\\nTree2:\\n\" + node2.toStringTree() +\n-            \"\\n\\nSubtree1: \" + diff.nodeA.toStringTree() +\n-            \"\\n\\nSubtree2: \" + diff.nodeB.toStringTree();\n+        return \"SCRIPT\";\n       }\n       return null;\n   }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1430, 
          "faulty": "return \"Node tree inequality:\" + \"\\nTree1:\\n\" + toStringTree() + \"\\n\\nTree2:\\n\"+ node2.toStringTree()+ \"\\n\\nSubtree1: \"+ diff.nodeA.toStringTree()+ \"\\n\\nSubtree2: \"+ diff.nodeB.toStringTree();", 
          "type": "Replace", 
          "seed": "return \"SCRIPT\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2409/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:30:34.461709882 -0500\n@@ -205,11 +205,6 @@\n           String newName = getNameForId(li.id);\n           // Mark the label as referenced so it isn't removed.\n           li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n         }\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2409/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:30:34.461709882 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2409/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:30:34.465709942 -0500\n@@ -885,9 +885,6 @@\n       Iterator<Entry<Node, Reference>> i;\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n-        if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n-        }\n       }\n     }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 888, 
          "faulty": "if (entry.getValue().mode == InliningMode.BLOCK) {\n  i.remove();\n}", 
          "type": "Delete", 
          "seed": "this.module=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 208, 
          "faulty": "if (!name.equals(newName)) {\n  nameNode.setString(newName);\n  compiler.reportCodeChange();\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2263/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:28:59.612246446 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2263/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:28:59.612246446 -0500\n@@ -688,7 +688,6 @@\n     if (!inliningLowersCost(fs)) {\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n-        fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 691, 
          "faulty": "fs.setRemove(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_372/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:09:36.079368936 -0500\n@@ -206,8 +206,6 @@\n           // Mark the label as referenced so it isn't removed.\n           li.referenced = true;\n           if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n             compiler.reportCodeChange();\n           }\n         }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_372/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:09:36.079368936 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_372/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:09:36.079368936 -0500\n@@ -886,7 +886,7 @@\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n         if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n+          this.module = null;\n         }\n       }\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 210, 
          "faulty": "nameNode.setString(newName);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 889, 
          "faulty": "i.remove();", 
          "type": "Replace", 
          "seed": "this.module=null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2037/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:26:36.482118702 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1208/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:17:53.882348372 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2623/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:32:31.963484714 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_260/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:08:21.110366368 -0500\n@@ -185,7 +185,7 @@\n \n         case Token.BREAK:\n         case Token.CONTINUE:\n-          visitBreakOrContinue(node);\n+          ;\n           break;\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_260/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:08:21.110366368 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:57:38.329845888 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_260/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:08:21.110366368 -0500\n@@ -1456,7 +1456,9 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        Preconditions.checkState(this.propListHead == null,\n+\t\t\t\t\"Node has existing properties.\");\n+\t\treturn res;\n       }\n     }\n     return res;\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_260/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:08:21.114366422 -0500\n@@ -501,8 +501,6 @@\n         // This reference can not be directly inlined, see if\n         // block replacement inlining is possible.\n         mode = InliningMode.BLOCK;\n-        referenceAdded = maybeAddReferenceUsingMode(\n-            t, fs, callNode, module, mode);\n       }\n \n       if (!referenceAdded) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 188, 
          "faulty": "visitBreakOrContinue(node);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 504, 
          "faulty": "referenceAdded=maybeAddReferenceUsingMode(t,fs,callNode,module,mode);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1459, 
          "faulty": "return res;", 
          "type": "InsertBefore", 
          "seed": "Preconditions.checkState(this.propListHead == null,\"Node has existing properties.\");"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_621/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:12:23.285651741 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_621/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:12:23.293651851 -0500\n@@ -501,8 +501,6 @@\n         // This reference can not be directly inlined, see if\n         // block replacement inlining is possible.\n         mode = InliningMode.BLOCK;\n-        referenceAdded = maybeAddReferenceUsingMode(\n-            t, fs, callNode, module, mode);\n       }\n \n       if (!referenceAdded) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 504, 
          "faulty": "referenceAdded=maybeAddReferenceUsingMode(t,fs,callNode,module,mode);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1489/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:20:48.388858013 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1489/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:20:48.388858013 -0500\n@@ -756,8 +756,6 @@\n           // For functions that can no longer be removed, check if they should\n           // still be inlined.\n           if (!mimimizeCost(fsCalled)) {\n-            // It can't be inlined remove it from the list.\n-            fsCalled.setInline(false);\n           }\n         }\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 760, 
          "faulty": "fsCalled.setInline(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_937/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:15:21.396129809 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 08:57:38.089845892 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_937/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 09:15:21.396129809 -0500\n@@ -106,7 +106,6 @@\n \n   void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n-      return;\n     }\n \n     int type = n.getType();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CodeGenerator.java", 
          "line": 109, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1548/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:21:30.145455712 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\t2018-12-01 08:57:38.101845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1548/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\t2018-12-01 09:21:30.145455712 -0500\n@@ -63,10 +63,6 @@\n     if (node.isName()) {\n       Node replacementTemplate = replacements.get(node.getString());\n       if (replacementTemplate != null) {\n-        // This should not be replacing declared names.\n-        Preconditions.checkState(!parent.isFunction()\n-            || !parent.isVar()\n-            || !parent.isCatch());\n         // The name may need to be replaced more than once,\n         // so we need to clone the node.\n         Node replacement = replacementTemplate.cloneTree();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionArgumentInjector.java", 
          "line": 67, 
          "faulty": "Preconditions.checkState(!parent.isFunction() || !parent.isVar() || !parent.isCatch());", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_743/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:13:33.150618309 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_719/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:13:20.522443194 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1371/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:19:24.363652392 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2368/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:30:02.125214672 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2048/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:26:43.254219504 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 08:57:38.089845892 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2048/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 09:26:43.258219564 -0500\n@@ -106,7 +106,6 @@\n \n   void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n-      return;\n     }\n \n     int type = n.getType();\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2048/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:26:43.258219564 -0500\n@@ -885,9 +885,7 @@\n       Iterator<Entry<Node, Reference>> i;\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n-        if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n-        }\n+        this.module = null;\n       }\n     }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 888, 
          "faulty": "if (entry.getValue().mode == InliningMode.BLOCK) {\n  i.remove();\n}", 
          "type": "Replace", 
          "seed": "this.module=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CodeGenerator.java", 
          "line": 109, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1912/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:25:28.849106206 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\t2018-12-01 08:57:38.101845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1912/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\t2018-12-01 09:25:28.853106266 -0500\n@@ -63,10 +63,6 @@\n     if (node.isName()) {\n       Node replacementTemplate = replacements.get(node.getString());\n       if (replacementTemplate != null) {\n-        // This should not be replacing declared names.\n-        Preconditions.checkState(!parent.isFunction()\n-            || !parent.isVar()\n-            || !parent.isCatch());\n         // The name may need to be replaced more than once,\n         // so we need to clone the node.\n         Node replacement = replacementTemplate.cloneTree();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionArgumentInjector.java", 
          "line": 67, 
          "faulty": "Preconditions.checkState(!parent.isFunction() || !parent.isVar() || !parent.isCatch());", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1904/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:25:24.981047947 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2885/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:34:58.949667454 -0500\n@@ -185,7 +185,7 @@\n \n         case Token.BREAK:\n         case Token.CONTINUE:\n-          visitBreakOrContinue(node);\n+          ;\n           break;\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2885/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:34:58.949667454 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2885/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:34:58.953667513 -0500\n@@ -885,9 +885,7 @@\n       Iterator<Entry<Node, Reference>> i;\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n-        if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n-        }\n+        this.module = null;\n       }\n     }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 888, 
          "faulty": "if (entry.getValue().mode == InliningMode.BLOCK) {\n  i.remove();\n}", 
          "type": "Replace", 
          "seed": "this.module=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 188, 
          "faulty": "visitBreakOrContinue(node);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1844/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:24:42.016397855 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1193/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:17:46.146236529 -0500\n@@ -205,11 +205,6 @@\n           String newName = getNameForId(li.id);\n           // Mark the label as referenced so it isn't removed.\n           li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n         }\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1193/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:17:46.146236529 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1193/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:17:46.146236529 -0500\n@@ -886,7 +886,8 @@\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n         if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n+          this.module = null;\n+\t\ti.remove();\n         }\n       }\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 208, 
          "faulty": "if (!name.equals(newName)) {\n  nameNode.setString(newName);\n  compiler.reportCodeChange();\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 889, 
          "faulty": "i.remove();", 
          "type": "InsertBefore", 
          "seed": "this.module=null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3324/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:39:22.829581189 -0500\n@@ -196,22 +196,6 @@\n      */\n     private void visitBreakOrContinue(Node node) {\n       Node nameNode = node.getFirstChild();\n-      if (nameNode != null) {\n-        // This is a named break or continue;\n-        String name = nameNode.getString();\n-        Preconditions.checkState(name.length() != 0);\n-        LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n-      }\n     }\n \n     /**\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3324/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:39:22.829581189 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 199, 
          "faulty": "if (nameNode != null) {\n  String name=nameNode.getString();\n  Preconditions.checkState(name.length() != 0);\n  LabelInfo li=getLabelInfo(name);\n  if (li != null) {\n    String newName=getNameForId(li.id);\n    li.referenced=true;\n    if (!name.equals(newName)) {\n      nameNode.setString(newName);\n      compiler.reportCodeChange();\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2964/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:35:45.682361025 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_777/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:13:51.670875419 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_777/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:13:51.670875419 -0500\n@@ -691,7 +691,6 @@\n         fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n-          return false;\n         }\n       } else {\n         return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 694, 
          "faulty": "return false;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_414/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:10:03.943745475 -0500\n@@ -201,16 +201,6 @@\n         String name = nameNode.getString();\n         Preconditions.checkState(name.length() != 0);\n         LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n       }\n     }\n \n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_414/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:10:03.943745475 -0500\n@@ -727,9 +727,6 @@\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 204, 
          "faulty": "if (li != null) {\n  String newName=getNameForId(li.id);\n  li.referenced=true;\n  if (!name.equals(newName)) {\n    nameNode.setString(newName);\n    compiler.reportCodeChange();\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1643/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:22:35.822448526 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1577/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:21:55.965824909 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1738/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:23:36.903400568 -0500\n@@ -727,9 +727,6 @@\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\t2018-12-01 08:57:38.101845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1738/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\t2018-12-01 09:23:36.903400568 -0500\n@@ -63,10 +63,6 @@\n     if (node.isName()) {\n       Node replacementTemplate = replacements.get(node.getString());\n       if (replacementTemplate != null) {\n-        // This should not be replacing declared names.\n-        Preconditions.checkState(!parent.isFunction()\n-            || !parent.isVar()\n-            || !parent.isCatch());\n         // The name may need to be replaced more than once,\n         // so we need to clone the node.\n         Node replacement = replacementTemplate.cloneTree();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionArgumentInjector.java", 
          "line": 67, 
          "faulty": "Preconditions.checkState(!parent.isFunction() || !parent.isVar() || !parent.isCatch());", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3070/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:36:52.707361341 -0500\n@@ -206,8 +206,6 @@\n           // Mark the label as referenced so it isn't removed.\n           li.referenced = true;\n           if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n             compiler.reportCodeChange();\n           }\n         }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3070/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:36:52.707361341 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 210, 
          "faulty": "nameNode.setString(newName);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2721/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:33:26.288295251 -0500\n@@ -199,7 +199,6 @@\n       if (nameNode != null) {\n         // This is a named break or continue;\n         String name = nameNode.getString();\n-        Preconditions.checkState(name.length() != 0);\n         LabelInfo li = getLabelInfo(name);\n         if (li != null) {\n           String newName = getNameForId(li.id);\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2721/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:33:26.288295251 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 08:57:38.089845892 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2721/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 09:33:26.288295251 -0500\n@@ -106,7 +106,6 @@\n \n   void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n-      return;\n     }\n \n     int type = n.getType();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CodeGenerator.java", 
          "line": 109, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 202, 
          "faulty": "Preconditions.checkState(name.length() != 0);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2602/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:32:21.379326158 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2602/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:32:21.379326158 -0500\n@@ -689,7 +689,6 @@\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n         fs.setRemove(false);\n-        fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n         }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 692, 
          "faulty": "fs.removeBlockInliningReferences();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3266/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:38:46.737049536 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3266/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:38:46.737049536 -0500\n@@ -691,7 +691,6 @@\n         fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n-          return false;\n         }\n       } else {\n         return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 694, 
          "faulty": "return false;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1395/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:19:42.899918738 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 08:57:38.089845892 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1395/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 09:19:42.899918738 -0500\n@@ -106,7 +106,6 @@\n \n   void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n-      return;\n     }\n \n     int type = n.getType();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CodeGenerator.java", 
          "line": 109, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2750/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:33:41.448520566 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1685/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:22:57.834793725 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_257/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:08:19.054339120 -0500\n@@ -196,22 +196,6 @@\n      */\n     private void visitBreakOrContinue(Node node) {\n       Node nameNode = node.getFirstChild();\n-      if (nameNode != null) {\n-        // This is a named break or continue;\n-        String name = nameNode.getString();\n-        Preconditions.checkState(name.length() != 0);\n-        LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n-      }\n     }\n \n     /**\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_257/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:08:19.054339120 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:57:38.329845888 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_257/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:08:19.058339173 -0500\n@@ -1456,7 +1456,7 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        parent = null;\n       }\n     }\n     return res;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 202, 
          "faulty": "Preconditions.checkState(name.length() != 0);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 199, 
          "faulty": "if (nameNode != null) {\n  String name=nameNode.getString();\n  Preconditions.checkState(name.length() != 0);\n  LabelInfo li=getLabelInfo(name);\n  if (li != null) {\n    String newName=getNameForId(li.id);\n    li.referenced=true;\n    if (!name.equals(newName)) {\n      nameNode.setString(newName);\n      compiler.reportCodeChange();\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1459, 
          "faulty": "return res;", 
          "type": "Replace", 
          "seed": "parent=null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2456/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:31:00.370104286 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3332/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:39:26.713638340 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1925/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:25:35.485206059 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2452/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:30:58.450075125 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2452/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:30:58.450075125 -0500\n@@ -689,7 +689,6 @@\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n         fs.setRemove(false);\n-        fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n         }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 692, 
          "faulty": "fs.removeBlockInliningReferences();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1504/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:21:07.249128080 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1470/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:20:27.368556800 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1470/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:20:27.368556800 -0500\n@@ -885,9 +885,7 @@\n       Iterator<Entry<Node, Reference>> i;\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n-        if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n-        }\n+        this.module = null;\n       }\n     }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 888, 
          "faulty": "if (entry.getValue().mode == InliningMode.BLOCK) {\n  i.remove();\n}", 
          "type": "Replace", 
          "seed": "this.module=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_309/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:08:54.662812999 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_309/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:08:54.662812999 -0500\n@@ -688,7 +688,6 @@\n     if (!inliningLowersCost(fs)) {\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n-        fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n@@ -884,7 +883,8 @@\n     void removeBlockInliningReferences() {\n       Iterator<Entry<Node, Reference>> i;\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n-        Entry<Node, Reference> entry = i.next();\n+        this.module = null;\n+\t\tEntry<Node, Reference> entry = i.next();\n         if (entry.getValue().mode == InliningMode.BLOCK) {\n           i.remove();\n         }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 887, 
          "faulty": "Entry<Node,Reference> entry=i.next();", 
          "type": "InsertBefore", 
          "seed": "this.module=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 691, 
          "faulty": "fs.setRemove(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2995/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:36:02.418611489 -0500\n@@ -205,11 +205,6 @@\n           String newName = getNameForId(li.id);\n           // Mark the label as referenced so it isn't removed.\n           li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n         }\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2995/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:36:02.418611489 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 208, 
          "faulty": "if (!name.equals(newName)) {\n  nameNode.setString(newName);\n  compiler.reportCodeChange();\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 731, 
          "faulty": "return CanInlineResult.NO;", 
          "type": "Delete", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2580/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:32:09.923154283 -0500\n@@ -727,9 +727,6 @@\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_887/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:14:49.511680377 -0500\n@@ -205,11 +205,6 @@\n           String newName = getNameForId(li.id);\n           // Mark the label as referenced so it isn't removed.\n           li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n         }\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_887/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:14:49.511680377 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_887/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:14:49.511680377 -0500\n@@ -756,8 +756,6 @@\n           // For functions that can no longer be removed, check if they should\n           // still be inlined.\n           if (!mimimizeCost(fsCalled)) {\n-            // It can't be inlined remove it from the list.\n-            fsCalled.setInline(false);\n           }\n         }\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 208, 
          "faulty": "if (!name.equals(newName)) {\n  nameNode.setString(newName);\n  compiler.reportCodeChange();\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 760, 
          "faulty": "fsCalled.setInline(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_896/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:14:54.319747411 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_896/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:14:54.323747468 -0500\n@@ -688,7 +688,6 @@\n     if (!inliningLowersCost(fs)) {\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n-        fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 691, 
          "faulty": "fs.setRemove(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2713/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:33:22.448238123 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 08:57:38.089845892 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2713/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 09:33:22.452238181 -0500\n@@ -106,7 +106,6 @@\n \n   void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n-      return;\n     }\n \n     int type = n.getType();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CodeGenerator.java", 
          "line": 109, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2532/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:31:44.990779242 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_41/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:05:09.015821140 -0500\n@@ -201,16 +201,6 @@\n         String name = nameNode.getString();\n         Preconditions.checkState(name.length() != 0);\n         LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n       }\n     }\n \n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_41/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:05:09.015821140 -0500\n@@ -727,9 +727,6 @@\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 204, 
          "faulty": "if (li != null) {\n  String newName=getNameForId(li.id);\n  li.referenced=true;\n  if (!name.equals(newName)) {\n    nameNode.setString(newName);\n    compiler.reportCodeChange();\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1059/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:16:31.749157433 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2868/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:34:49.277524728 -0500\n@@ -205,11 +205,6 @@\n           String newName = getNameForId(li.id);\n           // Mark the label as referenced so it isn't removed.\n           li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n         }\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2868/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:34:49.281524787 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 208, 
          "faulty": "if (!name.equals(newName)) {\n  nameNode.setString(newName);\n  compiler.reportCodeChange();\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2366/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:30:01.169199978 -0500\n@@ -185,7 +185,7 @@\n \n         case Token.BREAK:\n         case Token.CONTINUE:\n-          visitBreakOrContinue(node);\n+          ;\n           break;\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2366/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:30:01.169199978 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2366/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:30:01.169199978 -0500\n@@ -885,9 +885,6 @@\n       Iterator<Entry<Node, Reference>> i;\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n-        if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n-        }\n       }\n     }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 888, 
          "faulty": "if (entry.getValue().mode == InliningMode.BLOCK) {\n  i.remove();\n}", 
          "type": "Delete", 
          "seed": "this.module=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 188, 
          "faulty": "visitBreakOrContinue(node);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_705/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:13:13.678348357 -0500\n@@ -185,7 +185,7 @@\n \n         case Token.BREAK:\n         case Token.CONTINUE:\n-          visitBreakOrContinue(node);\n+          ;\n           break;\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_705/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:13:13.678348357 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 188, 
          "faulty": "visitBreakOrContinue(node);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1039/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:16:15.972927674 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2137/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:27:39.839058284 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2137/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:27:39.839058284 -0500\n@@ -691,7 +691,6 @@\n         fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n-          return false;\n         }\n       } else {\n         return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 694, 
          "faulty": "return false;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1668/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:22:49.222658970 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_112/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:06:23.884839969 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2398/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:30:28.697621859 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_592/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:12:06.705423248 -0500\n@@ -201,16 +201,6 @@\n         String name = nameNode.getString();\n         Preconditions.checkState(name.length() != 0);\n         LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n       }\n     }\n \n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_592/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:12:06.705423248 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 204, 
          "faulty": "if (li != null) {\n  String newName=getNameForId(li.id);\n  li.referenced=true;\n  if (!name.equals(newName)) {\n    nameNode.setString(newName);\n    compiler.reportCodeChange();\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2347/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:29:45.500958680 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2347/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:29:45.504958741 -0500\n@@ -498,9 +498,6 @@\n           t, fs, callNode, module, mode);\n       if (!referenceAdded &&\n           mode == InliningMode.DIRECT && blockFunctionInliningEnabled) {\n-        // This reference can not be directly inlined, see if\n-        // block replacement inlining is possible.\n-        mode = InliningMode.BLOCK;\n         referenceAdded = maybeAddReferenceUsingMode(\n             t, fs, callNode, module, mode);\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 503, 
          "faulty": "mode=InliningMode.BLOCK;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1486/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:20:41.352757215 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 08:57:38.089845892 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1486/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 09:20:41.352757215 -0500\n@@ -106,7 +106,6 @@\n \n   void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n-      return;\n     }\n \n     int type = n.getType();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CodeGenerator.java", 
          "line": 109, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3042/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:36:31.555046411 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1421/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:19:56.272110739 -0500\n@@ -727,9 +727,6 @@\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1464/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:20:24.480515397 -0500\n@@ -205,11 +205,6 @@\n           String newName = getNameForId(li.id);\n           // Mark the label as referenced so it isn't removed.\n           li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n         }\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1464/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:20:24.480515397 -0500\n@@ -727,9 +727,6 @@\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 208, 
          "faulty": "if (!name.equals(newName)) {\n  nameNode.setString(newName);\n  compiler.reportCodeChange();\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 211, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2091/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:27:04.610536780 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2279/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:29:08.136379416 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2354/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:29:49.309017408 -0500\n@@ -185,7 +185,7 @@\n \n         case Token.BREAK:\n         case Token.CONTINUE:\n-          visitBreakOrContinue(node);\n+          ;\n           break;\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2354/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:29:49.309017408 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 188, 
          "faulty": "visitBreakOrContinue(node);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3318/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:39:19.941538687 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:57:38.329845888 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3318/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:39:19.945538746 -0500\n@@ -1456,7 +1456,7 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        parent = null;\n       }\n     }\n     return res;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1459, 
          "faulty": "return res;", 
          "type": "Replace", 
          "seed": "parent=null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3086/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:37:01.839497111 -0500\n@@ -196,22 +196,6 @@\n      */\n     private void visitBreakOrContinue(Node node) {\n       Node nameNode = node.getFirstChild();\n-      if (nameNode != null) {\n-        // This is a named break or continue;\n-        String name = nameNode.getString();\n-        Preconditions.checkState(name.length() != 0);\n-        LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n-      }\n     }\n \n     /**\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3086/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:37:01.839497111 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3086/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:37:01.843497171 -0500\n@@ -885,9 +885,7 @@\n       Iterator<Entry<Node, Reference>> i;\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n-        if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n-        }\n+        this.module = null;\n       }\n     }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 888, 
          "faulty": "if (entry.getValue().mode == InliningMode.BLOCK) {\n  i.remove();\n}", 
          "type": "Replace", 
          "seed": "this.module=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 199, 
          "faulty": "if (nameNode != null) {\n  String name=nameNode.getString();\n  Preconditions.checkState(name.length() != 0);\n  LabelInfo li=getLabelInfo(name);\n  if (li != null) {\n    String newName=getNameForId(li.id);\n    li.referenced=true;\n    if (!name.equals(newName)) {\n      nameNode.setString(newName);\n      compiler.reportCodeChange();\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1633/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:22:31.050373351 -0500\n@@ -196,22 +196,6 @@\n      */\n     private void visitBreakOrContinue(Node node) {\n       Node nameNode = node.getFirstChild();\n-      if (nameNode != null) {\n-        // This is a named break or continue;\n-        String name = nameNode.getString();\n-        Preconditions.checkState(name.length() != 0);\n-        LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n-      }\n     }\n \n     /**\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1633/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:22:31.054373414 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 199, 
          "faulty": "if (nameNode != null) {\n  String name=nameNode.getString();\n  Preconditions.checkState(name.length() != 0);\n  LabelInfo li=getLabelInfo(name);\n  if (li != null) {\n    String newName=getNameForId(li.id);\n    li.referenced=true;\n    if (!name.equals(newName)) {\n      nameNode.setString(newName);\n      compiler.reportCodeChange();\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2788/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:34:00.248799506 -0500\n@@ -196,22 +196,6 @@\n      */\n     private void visitBreakOrContinue(Node node) {\n       Node nameNode = node.getFirstChild();\n-      if (nameNode != null) {\n-        // This is a named break or continue;\n-        String name = nameNode.getString();\n-        Preconditions.checkState(name.length() != 0);\n-        LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n-      }\n     }\n \n     /**\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2788/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:34:00.248799506 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2788/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:34:00.248799506 -0500\n@@ -885,9 +885,6 @@\n       Iterator<Entry<Node, Reference>> i;\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n-        if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n-        }\n       }\n     }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 888, 
          "faulty": "if (entry.getValue().mode == InliningMode.BLOCK) {\n  i.remove();\n}", 
          "type": "Delete", 
          "seed": "this.module=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 199, 
          "faulty": "if (nameNode != null) {\n  String name=nameNode.getString();\n  Preconditions.checkState(name.length() != 0);\n  LabelInfo li=getLabelInfo(name);\n  if (li != null) {\n    String newName=getNameForId(li.id);\n    li.referenced=true;\n    if (!name.equals(newName)) {\n      nameNode.setString(newName);\n      compiler.reportCodeChange();\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1426/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:19:59.156152133 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2860/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:34:45.413467679 -0500\n@@ -199,7 +199,6 @@\n       if (nameNode != null) {\n         // This is a named break or continue;\n         String name = nameNode.getString();\n-        Preconditions.checkState(name.length() != 0);\n         LabelInfo li = getLabelInfo(name);\n         if (li != null) {\n           String newName = getNameForId(li.id);\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2860/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:34:45.417467738 -0500\n@@ -728,7 +728,7 @@\n       if (fnParam != null) {\n         if (cArg != null) {\n           if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n+            return null;\n           }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 202, 
          "faulty": "Preconditions.checkState(name.length() != 0);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 731, 
          "faulty": "return CanInlineResult.NO;", 
          "type": "Replace", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1240/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:18:10.266585042 -0500\n@@ -201,16 +201,6 @@\n         String name = nameNode.getString();\n         Preconditions.checkState(name.length() != 0);\n         LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n       }\n     }\n \n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1240/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:18:10.266585042 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionToBlockMutator.java\t2018-12-01 08:57:38.101845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1240/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionToBlockMutator.java\t2018-12-01 09:18:10.266585042 -0500\n@@ -198,7 +198,7 @@\n \n     @Override\n     public String get() {\n-        return \"JSCompiler_inline_label_\" + idSupplier.get();\n+        return null;\n     }\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionToBlockMutator.java", 
          "line": 201, 
          "faulty": "return \"JSCompiler_inline_label_\" + idSupplier.get();", 
          "type": "Replace", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 204, 
          "faulty": "if (li != null) {\n  String newName=getNameForId(li.id);\n  li.referenced=true;\n  if (!name.equals(newName)) {\n    nameNode.setString(newName);\n    compiler.reportCodeChange();\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3021/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:36:20.938888100 -0500\n@@ -203,8 +203,6 @@\n         LabelInfo li = getLabelInfo(name);\n         if (li != null) {\n           String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n           if (!name.equals(newName)) {\n             // Give it the short name.\n             nameNode.setString(newName);\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3021/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:36:20.938888100 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 207, 
          "faulty": "li.referenced=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1122/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:17:03.637620793 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3064/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:36:49.783317844 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1906/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:25:25.937062349 -0500\n@@ -185,7 +185,7 @@\n \n         case Token.BREAK:\n         case Token.CONTINUE:\n-          visitBreakOrContinue(node);\n+          ;\n           break;\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1906/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:25:25.937062349 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 188, 
          "faulty": "visitBreakOrContinue(node);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2584/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:32:11.819182748 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3280/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:38:54.569164997 -0500\n@@ -208,7 +208,6 @@\n           if (!name.equals(newName)) {\n             // Give it the short name.\n             nameNode.setString(newName);\n-            compiler.reportCodeChange();\n           }\n         }\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3280/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:38:54.569164997 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3280/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:38:54.569164997 -0500\n@@ -501,8 +501,6 @@\n         // This reference can not be directly inlined, see if\n         // block replacement inlining is possible.\n         mode = InliningMode.BLOCK;\n-        referenceAdded = maybeAddReferenceUsingMode(\n-            t, fs, callNode, module, mode);\n       }\n \n       if (!referenceAdded) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 504, 
          "faulty": "referenceAdded=maybeAddReferenceUsingMode(t,fs,callNode,module,mode);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 211, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_863/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:14:36.947505290 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1564/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:21:49.009725473 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1339/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:19:07.175405195 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2364/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:30:00.205185158 -0500\n@@ -201,16 +201,6 @@\n         String name = nameNode.getString();\n         Preconditions.checkState(name.length() != 0);\n         LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n       }\n     }\n \n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2364/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:30:00.205185158 -0500\n@@ -727,9 +727,6 @@\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 204, 
          "faulty": "if (li != null) {\n  String newName=getNameForId(li.id);\n  li.referenced=true;\n  if (!name.equals(newName)) {\n    nameNode.setString(newName);\n    compiler.reportCodeChange();\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_639/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:12:38.353859715 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1596/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:22:05.857974337 -0500\n@@ -201,16 +201,6 @@\n         String name = nameNode.getString();\n         Preconditions.checkState(name.length() != 0);\n         LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n       }\n     }\n \n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1596/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:22:05.861974399 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 204, 
          "faulty": "if (li != null) {\n  String newName=getNameForId(li.id);\n  li.referenced=true;\n  if (!name.equals(newName)) {\n    nameNode.setString(newName);\n    compiler.reportCodeChange();\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1195/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:17:47.106250412 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1195/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:17:47.110250469 -0500\n@@ -883,12 +883,7 @@\n \n     void removeBlockInliningReferences() {\n       Iterator<Entry<Node, Reference>> i;\n-      for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n-        Entry<Node, Reference> entry = i.next();\n-        if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n-        }\n-      }\n+      this.module = null;\n     }\n \n     public boolean hasBlockInliningReferences() {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 886, 
          "faulty": "for (i=getReferencesInternal().entrySet().iterator(); i.hasNext(); ) {\n  Entry<Node,Reference> entry=i.next();\n  if (entry.getValue().mode == InliningMode.BLOCK) {\n    i.remove();\n  }\n}", 
          "type": "Replace", 
          "seed": "this.module=null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_980/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:15:44.020461165 -0500\n@@ -203,8 +203,6 @@\n         LabelInfo li = getLabelInfo(name);\n         if (li != null) {\n           String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n           if (!name.equals(newName)) {\n             // Give it the short name.\n             nameNode.setString(newName);\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_980/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:15:44.024461223 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 207, 
          "faulty": "li.referenced=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 731, 
          "faulty": "return CanInlineResult.NO;", 
          "type": "Delete", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_693/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:13:07.910268469 -0500\n@@ -206,8 +206,6 @@\n           // Mark the label as referenced so it isn't removed.\n           li.referenced = true;\n           if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n             compiler.reportCodeChange();\n           }\n         }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_693/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:13:07.914268525 -0500\n@@ -727,9 +727,6 @@\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 210, 
          "faulty": "nameNode.setString(newName);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 731, 
          "faulty": "return CanInlineResult.NO;", 
          "type": "Replace", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1874/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:25:09.640816478 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1433/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:20:02.992207184 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1872/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:25:08.588800579 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2464/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:31:04.190162276 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_102/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:06:10.940670010 -0500\n@@ -185,7 +185,7 @@\n \n         case Token.BREAK:\n         case Token.CONTINUE:\n-          visitBreakOrContinue(node);\n+          ;\n           break;\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_102/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:06:10.944670065 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 188, 
          "faulty": "visitBreakOrContinue(node);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_908/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:15:00.327831200 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_130/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:06:37.405012796 -0500\n@@ -206,8 +206,6 @@\n           // Mark the label as referenced so it isn't removed.\n           li.referenced = true;\n           if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n             compiler.reportCodeChange();\n           }\n         }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_130/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:06:37.409012848 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_130/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:06:37.409012848 -0500\n@@ -886,7 +886,8 @@\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n         if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n+          this.module = null;\n+\t\ti.remove();\n         }\n       }\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 210, 
          "faulty": "nameNode.setString(newName);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 889, 
          "faulty": "i.remove();", 
          "type": "InsertBefore", 
          "seed": "this.module=null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_843/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:14:26.327357392 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3038/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:36:29.611017434 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1369/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:19:23.419638820 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2780/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:33:56.384742216 -0500\n@@ -185,7 +185,7 @@\n \n         case Token.BREAK:\n         case Token.CONTINUE:\n-          visitBreakOrContinue(node);\n+          ;\n           break;\n       }\n     }\n@@ -208,7 +208,6 @@\n           if (!name.equals(newName)) {\n             // Give it the short name.\n             nameNode.setString(newName);\n-            compiler.reportCodeChange();\n           }\n         }\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2780/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:33:56.384742216 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2780/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:33:56.384742216 -0500\n@@ -688,7 +688,6 @@\n     if (!inliningLowersCost(fs)) {\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n-        fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 188, 
          "faulty": "visitBreakOrContinue(node);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 211, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 691, 
          "faulty": "fs.setRemove(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3159/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:37:44.732133375 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1733/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:23:34.003355760 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2731/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:33:31.068366332 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2020/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:26:27.889990671 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_826/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:14:17.699237302 -0500\n@@ -196,22 +196,6 @@\n      */\n     private void visitBreakOrContinue(Node node) {\n       Node nameNode = node.getFirstChild();\n-      if (nameNode != null) {\n-        // This is a named break or continue;\n-        String name = nameNode.getString();\n-        Preconditions.checkState(name.length() != 0);\n-        LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n-      }\n     }\n \n     /**\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_826/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:14:17.703237357 -0500\n@@ -727,9 +727,6 @@\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 199, 
          "faulty": "if (nameNode != null) {\n  String name=nameNode.getString();\n  Preconditions.checkState(name.length() != 0);\n  LabelInfo li=getLabelInfo(name);\n  if (li != null) {\n    String newName=getNameForId(li.id);\n    li.referenced=true;\n    if (!name.equals(newName)) {\n      nameNode.setString(newName);\n      compiler.reportCodeChange();\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2075/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:26:56.646418568 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\t2018-12-01 08:57:38.101845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2075/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\t2018-12-01 09:26:56.646418568 -0500\n@@ -63,10 +63,6 @@\n     if (node.isName()) {\n       Node replacementTemplate = replacements.get(node.getString());\n       if (replacementTemplate != null) {\n-        // This should not be replacing declared names.\n-        Preconditions.checkState(!parent.isFunction()\n-            || !parent.isVar()\n-            || !parent.isCatch());\n         // The name may need to be replaced more than once,\n         // so we need to clone the node.\n         Node replacement = replacementTemplate.cloneTree();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionArgumentInjector.java", 
          "line": 67, 
          "faulty": "Preconditions.checkState(!parent.isFunction() || !parent.isVar() || !parent.isCatch());", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2097/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:27:07.466579143 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2379/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:30:13.013381805 -0500\n@@ -205,11 +205,6 @@\n           String newName = getNameForId(li.id);\n           // Mark the label as referenced so it isn't removed.\n           li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n         }\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2379/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:30:13.013381805 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\t2018-12-01 08:57:38.101845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2379/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\t2018-12-01 09:30:13.017381866 -0500\n@@ -63,10 +63,6 @@\n     if (node.isName()) {\n       Node replacementTemplate = replacements.get(node.getString());\n       if (replacementTemplate != null) {\n-        // This should not be replacing declared names.\n-        Preconditions.checkState(!parent.isFunction()\n-            || !parent.isVar()\n-            || !parent.isCatch());\n         // The name may need to be replaced more than once,\n         // so we need to clone the node.\n         Node replacement = replacementTemplate.cloneTree();\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2379/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:30:13.017381866 -0500\n@@ -886,7 +886,8 @@\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n         if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n+          this.module = null;\n+\t\ti.remove();\n         }\n       }\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 208, 
          "faulty": "if (!name.equals(newName)) {\n  nameNode.setString(newName);\n  compiler.reportCodeChange();\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 889, 
          "faulty": "i.remove();", 
          "type": "InsertBefore", 
          "seed": "this.module=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionArgumentInjector.java", 
          "line": 67, 
          "faulty": "Preconditions.checkState(!parent.isFunction() || !parent.isVar() || !parent.isCatch());", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1842/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:24:41.072383507 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2957/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:35:41.842303487 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_984/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:15:45.952489419 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_762/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:13:43.730765148 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1590/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:22:03.001928862 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_941/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:15:23.300157731 -0500\n@@ -201,16 +201,6 @@\n         String name = nameNode.getString();\n         Preconditions.checkState(name.length() != 0);\n         LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n       }\n     }\n \n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_941/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:15:23.300157731 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 204, 
          "faulty": "if (li != null) {\n  String newName=getNameForId(li.id);\n  li.referenced=true;\n  if (!name.equals(newName)) {\n    nameNode.setString(newName);\n    compiler.reportCodeChange();\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_610/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:12:16.373556440 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1274/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:18:27.490833571 -0500\n@@ -196,22 +196,6 @@\n      */\n     private void visitBreakOrContinue(Node node) {\n       Node nameNode = node.getFirstChild();\n-      if (nameNode != null) {\n-        // This is a named break or continue;\n-        String name = nameNode.getString();\n-        Preconditions.checkState(name.length() != 0);\n-        LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n-      }\n     }\n \n     /**\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1274/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:18:27.490833571 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1274/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:18:27.490833571 -0500\n@@ -742,7 +742,6 @@\n   private void resolveInlineConflictsForFunction(FunctionState fs) {\n     // Functions that aren't referenced don't cause conflicts.\n     if (!fs.hasReferences() || !fs.canInline()) {\n-      return;\n     }\n \n     Node fnNode = fs.getFn().getFunctionNode();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 199, 
          "faulty": "if (nameNode != null) {\n  String name=nameNode.getString();\n  Preconditions.checkState(name.length() != 0);\n  LabelInfo li=getLabelInfo(name);\n  if (li != null) {\n    String newName=getNameForId(li.id);\n    li.referenced=true;\n    if (!name.equals(newName)) {\n      nameNode.setString(newName);\n      compiler.reportCodeChange();\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 745, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2475/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:31:10.130252368 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2475/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:31:10.134252428 -0500\n@@ -688,7 +688,6 @@\n     if (!inliningLowersCost(fs)) {\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n-        fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 691, 
          "faulty": "fs.setRemove(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2362/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:29:59.257170580 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_299/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:08:48.654732761 -0500\n@@ -728,7 +728,6 @@\n       if (fnParam != null) {\n         if (cArg != null) {\n           if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n           }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:57:38.329845888 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_299/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:08:48.654732761 -0500\n@@ -1456,7 +1456,7 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        return null;\n       }\n     }\n     return res;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 731, 
          "faulty": "return CanInlineResult.NO;", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1459, 
          "faulty": "return res;", 
          "type": "Replace", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3079/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:36:57.939439142 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1650/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:22:39.598507924 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_857/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:14:34.003464282 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1637/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:22:32.970403612 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1258/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:18:18.838708764 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3254/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:38:40.984964703 -0500\n@@ -206,8 +206,6 @@\n           // Mark the label as referenced so it isn't removed.\n           li.referenced = true;\n           if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n             compiler.reportCodeChange();\n           }\n         }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3254/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:38:40.988964762 -0500\n@@ -727,9 +727,6 @@\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 210, 
          "faulty": "nameNode.setString(newName);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1429/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:20:01.068179574 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_438/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:10:22.744000546 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_647/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:12:42.405915692 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_758/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:13:41.826738715 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_760/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:13:42.782751987 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2159/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:27:56.451303471 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1478/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:20:37.268698695 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1302/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:18:47.995129082 -0500\n@@ -203,8 +203,6 @@\n         LabelInfo li = getLabelInfo(name);\n         if (li != null) {\n           String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n           if (!name.equals(newName)) {\n             // Give it the short name.\n             nameNode.setString(newName);\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1302/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:18:47.999129139 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1302/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:18:47.999129139 -0500\n@@ -742,7 +742,6 @@\n   private void resolveInlineConflictsForFunction(FunctionState fs) {\n     // Functions that aren't referenced don't cause conflicts.\n     if (!fs.hasReferences() || !fs.canInline()) {\n-      return;\n     }\n \n     Node fnNode = fs.getFn().getFunctionNode();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 207, 
          "faulty": "li.referenced=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 745, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_148/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:06:48.337153229 -0500\n@@ -196,22 +196,6 @@\n      */\n     private void visitBreakOrContinue(Node node) {\n       Node nameNode = node.getFirstChild();\n-      if (nameNode != null) {\n-        // This is a named break or continue;\n-        String name = nameNode.getString();\n-        Preconditions.checkState(name.length() != 0);\n-        LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n-      }\n     }\n \n     /**\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_148/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:06:48.337153229 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_148/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:06:48.337153229 -0500\n@@ -690,9 +690,6 @@\n       if (fs.hasBlockInliningReferences()) {\n         fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n-        if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n-          return false;\n-        }\n       } else {\n         return false;\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 199, 
          "faulty": "if (nameNode != null) {\n  String name=nameNode.getString();\n  Preconditions.checkState(name.length() != 0);\n  LabelInfo li=getLabelInfo(name);\n  if (li != null) {\n    String newName=getNameForId(li.id);\n    li.referenced=true;\n    if (!name.equals(newName)) {\n      nameNode.setString(newName);\n      compiler.reportCodeChange();\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 693, 
          "faulty": "if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1223/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:18:01.586459691 -0500\n@@ -206,8 +206,6 @@\n           // Mark the label as referenced so it isn't removed.\n           li.referenced = true;\n           if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n             compiler.reportCodeChange();\n           }\n         }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1223/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:18:01.586459691 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 08:57:38.089845892 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1223/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 09:18:01.586459691 -0500\n@@ -106,7 +106,6 @@\n \n   void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n-      return;\n     }\n \n     int type = n.getType();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 210, 
          "faulty": "nameNode.setString(newName);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CodeGenerator.java", 
          "line": 109, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_317/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:08:59.530878092 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_558/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:11:43.845108851 -0500\n@@ -203,8 +203,6 @@\n         LabelInfo li = getLabelInfo(name);\n         if (li != null) {\n           String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n           if (!name.equals(newName)) {\n             // Give it the short name.\n             nameNode.setString(newName);\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_558/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:11:43.849108906 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 207, 
          "faulty": "li.referenced=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1927/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:25:36.429220255 -0500\n@@ -727,9 +727,6 @@\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1666/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:22:48.270644049 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1666/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:22:48.270644049 -0500\n@@ -885,9 +885,6 @@\n       Iterator<Entry<Node, Reference>> i;\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n-        if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n-        }\n       }\n     }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 888, 
          "faulty": "if (entry.getValue().mode == InliningMode.BLOCK) {\n  i.remove();\n}", 
          "type": "Delete", 
          "seed": "this.module=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1374/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:19:26.299680221 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2658/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:32:49.219742752 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:57:38.329845888 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2658/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:32:49.219742752 -0500\n@@ -1456,7 +1456,9 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        Preconditions.checkState(this.propListHead == null,\n+\t\t\t\t\"Node has existing properties.\");\n+\t\treturn res;\n       }\n     }\n     return res;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1459, 
          "faulty": "return res;", 
          "type": "InsertBefore", 
          "seed": "Preconditions.checkState(this.propListHead == null,\"Node has existing properties.\");"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_537/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:11:32.096947590 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 08:57:38.089845892 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_537/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 09:11:32.096947590 -0500\n@@ -106,7 +106,6 @@\n \n   void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n-      return;\n     }\n \n     int type = n.getType();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CodeGenerator.java", 
          "line": 109, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1435/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:20:03.984221419 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2833/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:34:25.801177848 -0500\n@@ -201,16 +201,6 @@\n         String name = nameNode.getString();\n         Preconditions.checkState(name.length() != 0);\n         LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n       }\n     }\n \n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2833/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:34:25.805177908 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\t2018-12-01 08:57:38.101845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2833/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\t2018-12-01 09:34:25.805177908 -0500\n@@ -63,10 +63,6 @@\n     if (node.isName()) {\n       Node replacementTemplate = replacements.get(node.getString());\n       if (replacementTemplate != null) {\n-        // This should not be replacing declared names.\n-        Preconditions.checkState(!parent.isFunction()\n-            || !parent.isVar()\n-            || !parent.isCatch());\n         // The name may need to be replaced more than once,\n         // so we need to clone the node.\n         Node replacement = replacementTemplate.cloneTree();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 207, 
          "faulty": "li.referenced=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionArgumentInjector.java", 
          "line": 67, 
          "faulty": "Preconditions.checkState(!parent.isFunction() || !parent.isVar() || !parent.isCatch());", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 204, 
          "faulty": "if (li != null) {\n  String newName=getNameForId(li.id);\n  li.referenced=true;\n  if (!name.equals(newName)) {\n    nameNode.setString(newName);\n    compiler.reportCodeChange();\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2508/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:31:32.594592237 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2821/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:34:19.729088020 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_900/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:14:56.239774185 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1293/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:18:43.195059935 -0500\n@@ -203,8 +203,6 @@\n         LabelInfo li = getLabelInfo(name);\n         if (li != null) {\n           String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n           if (!name.equals(newName)) {\n             // Give it the short name.\n             nameNode.setString(newName);\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1293/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:18:43.195059935 -0500\n@@ -727,9 +727,6 @@\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 207, 
          "faulty": "li.referenced=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2674/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:32:56.971858492 -0500\n@@ -199,7 +199,6 @@\n       if (nameNode != null) {\n         // This is a named break or continue;\n         String name = nameNode.getString();\n-        Preconditions.checkState(name.length() != 0);\n         LabelInfo li = getLabelInfo(name);\n         if (li != null) {\n           String newName = getNameForId(li.id);\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2674/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:32:56.971858492 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2674/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:32:56.975858551 -0500\n@@ -883,7 +883,8 @@\n \n     void removeBlockInliningReferences() {\n       Iterator<Entry<Node, Reference>> i;\n-      for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n+      this.module = null;\n+\tfor (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n         if (entry.getValue().mode == InliningMode.BLOCK) {\n           i.remove();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 202, 
          "faulty": "Preconditions.checkState(name.length() != 0);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 886, 
          "faulty": "for (i=getReferencesInternal().entrySet().iterator(); i.hasNext(); ) {\n  Entry<Node,Reference> entry=i.next();\n  if (entry.getValue().mode == InliningMode.BLOCK) {\n    i.remove();\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "this.module=null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1298/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:18:46.063101252 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1298/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:18:46.063101252 -0500\n@@ -498,9 +498,6 @@\n           t, fs, callNode, module, mode);\n       if (!referenceAdded &&\n           mode == InliningMode.DIRECT && blockFunctionInliningEnabled) {\n-        // This reference can not be directly inlined, see if\n-        // block replacement inlining is possible.\n-        mode = InliningMode.BLOCK;\n         referenceAdded = maybeAddReferenceUsingMode(\n             t, fs, callNode, module, mode);\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 503, 
          "faulty": "mode=InliningMode.BLOCK;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2772/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:33:52.552685380 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2772/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:33:52.552685380 -0500\n@@ -885,9 +885,7 @@\n       Iterator<Entry<Node, Reference>> i;\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n-        if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n-        }\n+        this.module = null;\n       }\n     }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 888, 
          "faulty": "if (entry.getValue().mode == InliningMode.BLOCK) {\n  i.remove();\n}", 
          "type": "Replace", 
          "seed": "this.module=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_313/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:08:56.610839038 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1818/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:24:23.500115856 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_495/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:11:02.376540655 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2468/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:31:06.122191589 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_440/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:10:23.736014026 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_440/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:10:23.736014026 -0500\n@@ -501,8 +501,6 @@\n         // This reference can not be directly inlined, see if\n         // block replacement inlining is possible.\n         mode = InliningMode.BLOCK;\n-        referenceAdded = maybeAddReferenceUsingMode(\n-            t, fs, callNode, module, mode);\n       }\n \n       if (!referenceAdded) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 504, 
          "faulty": "referenceAdded=maybeAddReferenceUsingMode(t,fs,callNode,module,mode);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2034/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:26:34.598090643 -0500\n@@ -206,8 +206,6 @@\n           // Mark the label as referenced so it isn't removed.\n           li.referenced = true;\n           if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n             compiler.reportCodeChange();\n           }\n         }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2034/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:26:34.602090702 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 210, 
          "faulty": "nameNode.setString(newName);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1950/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:25:49.209412197 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_756/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:13:40.874725500 -0500\n@@ -201,16 +201,6 @@\n         String name = nameNode.getString();\n         Preconditions.checkState(name.length() != 0);\n         LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n       }\n     }\n \n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_756/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:13:40.874725500 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_756/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:13:40.874725500 -0500\n@@ -689,7 +689,6 @@\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n         fs.setRemove(false);\n-        fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n         }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 204, 
          "faulty": "if (li != null) {\n  String newName=getNameForId(li.id);\n  li.referenced=true;\n  if (!name.equals(newName)) {\n    nameNode.setString(newName);\n    compiler.reportCodeChange();\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 692, 
          "faulty": "fs.removeBlockInliningReferences();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3030/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:36:25.794960537 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3030/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:36:25.798960596 -0500\n@@ -690,9 +690,6 @@\n       if (fs.hasBlockInliningReferences()) {\n         fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n-        if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n-          return false;\n-        }\n       } else {\n         return false;\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 693, 
          "faulty": "if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1020/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:16:05.228770989 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1084/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:16:44.225338881 -0500\n@@ -206,8 +206,6 @@\n           // Mark the label as referenced so it isn't removed.\n           li.referenced = true;\n           if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n             compiler.reportCodeChange();\n           }\n         }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1084/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:16:44.229338938 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 210, 
          "faulty": "nameNode.setString(newName);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_686/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:13:03.962213810 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_686/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:13:03.962213810 -0500\n@@ -885,9 +885,7 @@\n       Iterator<Entry<Node, Reference>> i;\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n-        if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n-        }\n+        this.module = null;\n       }\n     }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 888, 
          "faulty": "if (entry.getValue().mode == InliningMode.BLOCK) {\n  i.remove();\n}", 
          "type": "Replace", 
          "seed": "this.module=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2118/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:27:24.166826552 -0500\n@@ -208,7 +208,6 @@\n           if (!name.equals(newName)) {\n             // Give it the short name.\n             nameNode.setString(newName);\n-            compiler.reportCodeChange();\n           }\n         }\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2118/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:27:24.170826611 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2118/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:27:24.170826611 -0500\n@@ -689,7 +689,6 @@\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n         fs.setRemove(false);\n-        fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n         }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 211, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 692, 
          "faulty": "fs.removeBlockInliningReferences();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1940/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:25:44.409340156 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:57:38.329845888 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1940/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:25:44.409340156 -0500\n@@ -1456,7 +1456,8 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        sourcePosition = -1;\n+\t\treturn res;\n       }\n     }\n     return res;\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1940/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:25:44.409340156 -0500\n@@ -742,7 +742,6 @@\n   private void resolveInlineConflictsForFunction(FunctionState fs) {\n     // Functions that aren't referenced don't cause conflicts.\n     if (!fs.hasReferences() || !fs.canInline()) {\n-      return;\n     }\n \n     Node fnNode = fs.getFn().getFunctionNode();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 745, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1459, 
          "faulty": "return res;", 
          "type": "InsertBefore", 
          "seed": "sourcePosition=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1234/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:18:07.370543228 -0500\n@@ -199,7 +199,6 @@\n       if (nameNode != null) {\n         // This is a named break or continue;\n         String name = nameNode.getString();\n-        Preconditions.checkState(name.length() != 0);\n         LabelInfo li = getLabelInfo(name);\n         if (li != null) {\n           String newName = getNameForId(li.id);\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1234/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:18:07.370543228 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1234/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:18:07.374543286 -0500\n@@ -501,8 +501,6 @@\n         // This reference can not be directly inlined, see if\n         // block replacement inlining is possible.\n         mode = InliningMode.BLOCK;\n-        referenceAdded = maybeAddReferenceUsingMode(\n-            t, fs, callNode, module, mode);\n       }\n \n       if (!referenceAdded) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 504, 
          "faulty": "referenceAdded=maybeAddReferenceUsingMode(t,fs,callNode,module,mode);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 202, 
          "faulty": "Preconditions.checkState(name.length() != 0);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1154/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:17:20.901871116 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3242/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:38:34.156863961 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_395/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:09:54.043611478 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2308/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:29:23.520618605 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3245/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:38:36.116892884 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2807/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:34:10.928957747 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2273/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:29:05.272334775 -0500\n@@ -205,11 +205,6 @@\n           String newName = getNameForId(li.id);\n           // Mark the label as referenced so it isn't removed.\n           li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n         }\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2273/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:29:05.276334837 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 208, 
          "faulty": "if (!name.equals(newName)) {\n  nameNode.setString(newName);\n  compiler.reportCodeChange();\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 731, 
          "faulty": "return CanInlineResult.NO;", 
          "type": "Replace", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1468/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:20:26.380542636 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1696/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:23:09.662978203 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3210/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:38:12.528544564 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_301/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:08:49.710746856 -0500\n@@ -205,11 +205,6 @@\n           String newName = getNameForId(li.id);\n           // Mark the label as referenced so it isn't removed.\n           li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n         }\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_301/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:08:49.714746909 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_301/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:08:49.714746909 -0500\n@@ -883,7 +883,8 @@\n \n     void removeBlockInliningReferences() {\n       Iterator<Entry<Node, Reference>> i;\n-      for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n+      this.module = null;\n+\tfor (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n         if (entry.getValue().mode == InliningMode.BLOCK) {\n           i.remove();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 208, 
          "faulty": "if (!name.equals(newName)) {\n  nameNode.setString(newName);\n  compiler.reportCodeChange();\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 886, 
          "faulty": "for (i=getReferencesInternal().entrySet().iterator(); i.hasNext(); ) {\n  Entry<Node,Reference> entry=i.next();\n  if (entry.getValue().mode == InliningMode.BLOCK) {\n    i.remove();\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "this.module=null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2418/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:30:39.225782556 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionToBlockMutator.java\t2018-12-01 08:57:38.101845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2418/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionToBlockMutator.java\t2018-12-01 09:30:39.225782556 -0500\n@@ -198,7 +198,7 @@\n \n     @Override\n     public String get() {\n-        return \"JSCompiler_inline_label_\" + idSupplier.get();\n+        return null;\n     }\n   }\n \n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2418/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:30:39.225782556 -0500\n@@ -501,8 +501,6 @@\n         // This reference can not be directly inlined, see if\n         // block replacement inlining is possible.\n         mode = InliningMode.BLOCK;\n-        referenceAdded = maybeAddReferenceUsingMode(\n-            t, fs, callNode, module, mode);\n       }\n \n       if (!referenceAdded) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionToBlockMutator.java", 
          "line": 201, 
          "faulty": "return \"JSCompiler_inline_label_\" + idSupplier.get();", 
          "type": "Replace", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 504, 
          "faulty": "referenceAdded=maybeAddReferenceUsingMode(t,fs,callNode,module,mode);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1856/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:24:48.744500037 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_341/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:09:14.255075394 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1316/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:18:54.787226892 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2344/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:29:43.564928800 -0500\n@@ -203,8 +203,6 @@\n         LabelInfo li = getLabelInfo(name);\n         if (li != null) {\n           String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n           if (!name.equals(newName)) {\n             // Give it the short name.\n             nameNode.setString(newName);\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2344/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:29:43.564928800 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 207, 
          "faulty": "li.referenced=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_412/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:10:02.927731713 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1236/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:18:08.318556917 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_606/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:12:14.445529868 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2071/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:26:54.730390110 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_276/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:08:29.870482626 -0500\n@@ -185,7 +185,7 @@\n \n         case Token.BREAK:\n         case Token.CONTINUE:\n-          visitBreakOrContinue(node);\n+          ;\n           break;\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_276/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:08:29.894482945 -0500\n@@ -727,9 +727,6 @@\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_276/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:08:29.898482998 -0500\n@@ -883,12 +883,7 @@\n \n     void removeBlockInliningReferences() {\n       Iterator<Entry<Node, Reference>> i;\n-      for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n-        Entry<Node, Reference> entry = i.next();\n-        if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n-        }\n-      }\n+      this.module = null;\n     }\n \n     public boolean hasBlockInliningReferences() {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 188, 
          "faulty": "visitBreakOrContinue(node);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 886, 
          "faulty": "for (i=getReferencesInternal().entrySet().iterator(); i.hasNext(); ) {\n  Entry<Node,Reference> entry=i.next();\n  if (entry.getValue().mode == InliningMode.BLOCK) {\n    i.remove();\n  }\n}", 
          "type": "Replace", 
          "seed": "this.module=null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1011/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:16:00.384700288 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\t2018-12-01 08:57:38.101845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1011/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\t2018-12-01 09:16:00.384700288 -0500\n@@ -63,10 +63,6 @@\n     if (node.isName()) {\n       Node replacementTemplate = replacements.get(node.getString());\n       if (replacementTemplate != null) {\n-        // This should not be replacing declared names.\n-        Preconditions.checkState(!parent.isFunction()\n-            || !parent.isVar()\n-            || !parent.isCatch());\n         // The name may need to be replaced more than once,\n         // so we need to clone the node.\n         Node replacement = replacementTemplate.cloneTree();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionArgumentInjector.java", 
          "line": 67, 
          "faulty": "Preconditions.checkState(!parent.isFunction() || !parent.isVar() || !parent.isCatch());", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3298/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:39:04.109305569 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3189/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:38:00.936373183 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1864/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:24:53.536572726 -0500\n@@ -205,11 +205,6 @@\n           String newName = getNameForId(li.id);\n           // Mark the label as referenced so it isn't removed.\n           li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n         }\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1864/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:24:53.540572786 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1864/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:24:53.540572786 -0500\n@@ -886,7 +886,6 @@\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n         if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n         }\n       }\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 208, 
          "faulty": "if (!name.equals(newName)) {\n  nameNode.setString(newName);\n  compiler.reportCodeChange();\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 889, 
          "faulty": "i.remove();", 
          "type": "Delete", 
          "seed": "this.module=null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_189/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:07:27.497660943 -0500\n@@ -728,7 +728,7 @@\n       if (fnParam != null) {\n         if (cArg != null) {\n           if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n+            return null;\n           }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 731, 
          "faulty": "return CanInlineResult.NO;", 
          "type": "Replace", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1740/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:23:37.879415640 -0500\n@@ -201,16 +201,6 @@\n         String name = nameNode.getString();\n         Preconditions.checkState(name.length() != 0);\n         LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n       }\n     }\n \n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1740/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:23:37.879415640 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 204, 
          "faulty": "if (li != null) {\n  String newName=getNameForId(li.id);\n  li.referenced=true;\n  if (!name.equals(newName)) {\n    nameNode.setString(newName);\n    compiler.reportCodeChange();\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2676/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:32:57.931872818 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2676/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:32:57.935872877 -0500\n@@ -883,12 +883,6 @@\n \n     void removeBlockInliningReferences() {\n       Iterator<Entry<Node, Reference>> i;\n-      for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n-        Entry<Node, Reference> entry = i.next();\n-        if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n-        }\n-      }\n     }\n \n     public boolean hasBlockInliningReferences() {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 886, 
          "faulty": "for (i=getReferencesInternal().entrySet().iterator(); i.hasNext(); ) {\n  Entry<Node,Reference> entry=i.next();\n  if (entry.getValue().mode == InliningMode.BLOCK) {\n    i.remove();\n  }\n}", 
          "type": "Delete", 
          "seed": "this.module=null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3234/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:38:30.320807345 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_356/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:09:22.127181129 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_226/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:07:57.838058818 -0500\n@@ -185,7 +185,7 @@\n \n         case Token.BREAK:\n         case Token.CONTINUE:\n-          visitBreakOrContinue(node);\n+          ;\n           break;\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_226/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:07:57.842058870 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 188, 
          "faulty": "visitBreakOrContinue(node);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3247/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:38:37.088907226 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1601/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:22:13.814100753 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2530/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:31:44.034764833 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2530/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:31:44.038764893 -0500\n@@ -756,8 +756,6 @@\n           // For functions that can no longer be removed, check if they should\n           // still be inlined.\n           if (!mimimizeCost(fsCalled)) {\n-            // It can't be inlined remove it from the list.\n-            fsCalled.setInline(false);\n           }\n         }\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 760, 
          "faulty": "fsCalled.setInline(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1962/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:25:55.993513915 -0500\n@@ -205,11 +205,6 @@\n           String newName = getNameForId(li.id);\n           // Mark the label as referenced so it isn't removed.\n           li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n         }\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1962/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:25:55.993513915 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 208, 
          "faulty": "if (!name.equals(newName)) {\n  nameNode.setString(newName);\n  compiler.reportCodeChange();\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2403/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:30:31.557665547 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_699/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:13:10.778308187 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_173/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:07:16.009511282 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:57:38.329845888 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_173/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:07:16.013511334 -0500\n@@ -1456,7 +1456,9 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        Preconditions.checkState(this.propListHead == null,\n+\t\t\t\t\"Node has existing properties.\");\n+\t\treturn res;\n       }\n     }\n     return res;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1459, 
          "faulty": "return res;", 
          "type": "InsertBefore", 
          "seed": "Preconditions.checkState(this.propListHead == null,\"Node has existing properties.\");"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1414/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:19:52.448055844 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1162/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:17:24.745926805 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_500/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:11:05.300580623 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2997/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:36:03.378625841 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1705/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:23:14.495053372 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:57:38.329845888 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1705/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:23:14.495053372 -0500\n@@ -1456,7 +1456,9 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        Preconditions.checkState(this.propListHead == null,\n+\t\t\t\t\"Node has existing properties.\");\n+\t\treturn res;\n       }\n     }\n     return res;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1459, 
          "faulty": "return res;", 
          "type": "InsertBefore", 
          "seed": "Preconditions.checkState(this.propListHead == null,\"Node has existing properties.\");"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_573/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:11:56.837287436 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_195/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:07:30.453699545 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_212/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:07:48.177931743 -0500\n@@ -185,7 +185,7 @@\n \n         case Token.BREAK:\n         case Token.CONTINUE:\n-          visitBreakOrContinue(node);\n+          ;\n           break;\n       }\n     }\n@@ -205,11 +205,6 @@\n           String newName = getNameForId(li.id);\n           // Mark the label as referenced so it isn't removed.\n           li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n         }\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_212/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:07:48.177931743 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:57:38.329845888 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_212/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:07:48.177931743 -0500\n@@ -1456,7 +1456,9 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        Preconditions.checkState(this.propListHead == null,\n+\t\t\t\t\"Node has existing properties.\");\n+\t\treturn res;\n       }\n     }\n     return res;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 188, 
          "faulty": "visitBreakOrContinue(node);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 208, 
          "faulty": "if (!name.equals(newName)) {\n  nameNode.setString(newName);\n  compiler.reportCodeChange();\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1459, 
          "faulty": "return res;", 
          "type": "InsertBefore", 
          "seed": "Preconditions.checkState(this.propListHead == null,\"Node has existing properties.\");"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_669/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:12:54.254079481 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3115/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:37:17.247725939 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1197/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:17:48.070264351 -0500\n@@ -206,8 +206,6 @@\n           // Mark the label as referenced so it isn't removed.\n           li.referenced = true;\n           if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n             compiler.reportCodeChange();\n           }\n         }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1197/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:17:48.074264409 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1197/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:17:48.074264409 -0500\n@@ -689,7 +689,6 @@\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n         fs.setRemove(false);\n-        fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n         }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 210, 
          "faulty": "nameNode.setString(newName);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 692, 
          "faulty": "fs.removeBlockInliningReferences();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_715/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:13:18.594416472 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2147/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:27:50.759219509 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_431/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:10:13.735878231 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_429/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:10:12.751864881 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_429/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:10:12.755864935 -0500\n@@ -885,9 +885,7 @@\n       Iterator<Entry<Node, Reference>> i;\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n-        if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n-        }\n+        this.module = null;\n       }\n     }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 888, 
          "faulty": "if (entry.getValue().mode == InliningMode.BLOCK) {\n  i.remove();\n}", 
          "type": "Replace", 
          "seed": "this.module=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1810/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:24:19.680057527 -0500\n@@ -185,7 +185,7 @@\n \n         case Token.BREAK:\n         case Token.CONTINUE:\n-          visitBreakOrContinue(node);\n+          ;\n           break;\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1810/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:24:19.684057588 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 188, 
          "faulty": "visitBreakOrContinue(node);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2883/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:34:57.985653233 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2883/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:34:57.989653292 -0500\n@@ -886,7 +886,6 @@\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n         if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n         }\n       }\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 889, 
          "faulty": "i.remove();", 
          "type": "Delete", 
          "seed": "this.module=null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2947/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:35:37.054231706 -0500\n@@ -205,11 +205,6 @@\n           String newName = getNameForId(li.id);\n           // Mark the label as referenced so it isn't removed.\n           li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n         }\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2947/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:35:37.054231706 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 208, 
          "faulty": "if (!name.equals(newName)) {\n  nameNode.setString(newName);\n  compiler.reportCodeChange();\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3199/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:38:06.692458300 -0500\n@@ -727,9 +727,6 @@\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1713/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:23:18.359113404 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2907/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:35:10.385836077 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2425/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:30:43.049840840 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 08:57:38.089845892 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2425/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 09:30:43.049840840 -0500\n@@ -106,7 +106,6 @@\n \n   void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n-      return;\n     }\n \n     int type = n.getType();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CodeGenerator.java", 
          "line": 109, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1458/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:20:21.636474619 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1458/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:20:21.636474619 -0500\n@@ -688,7 +688,6 @@\n     if (!inliningLowersCost(fs)) {\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n-        fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 691, 
          "faulty": "fs.setRemove(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1399/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:19:44.807946141 -0500\n@@ -206,8 +206,6 @@\n           // Mark the label as referenced so it isn't removed.\n           li.referenced = true;\n           if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n             compiler.reportCodeChange();\n           }\n         }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1399/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:19:44.807946141 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1399/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:19:44.807946141 -0500\n@@ -690,9 +690,6 @@\n       if (fs.hasBlockInliningReferences()) {\n         fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n-        if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n-          return false;\n-        }\n       } else {\n         return false;\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 210, 
          "faulty": "nameNode.setString(newName);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 693, 
          "faulty": "if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1140/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:17:13.245760151 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2149/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:27:51.707233497 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_641/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:12:39.345873418 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_641/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:12:39.345873418 -0500\n@@ -883,7 +883,8 @@\n \n     void removeBlockInliningReferences() {\n       Iterator<Entry<Node, Reference>> i;\n-      for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n+      this.module = null;\n+\tfor (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n         if (entry.getValue().mode == InliningMode.BLOCK) {\n           i.remove();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 886, 
          "faulty": "for (i=getReferencesInternal().entrySet().iterator(); i.hasNext(); ) {\n  Entry<Node,Reference> entry=i.next();\n  if (entry.getValue().mode == InliningMode.BLOCK) {\n    i.remove();\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "this.module=null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2405/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:30:32.525680327 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3009/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:36:09.110711504 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 731, 
          "faulty": "return CanInlineResult.NO;", 
          "type": "Replace", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2054/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:26:46.106261928 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_450/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:10:28.588079990 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2400/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:30:29.653636464 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2400/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:30:29.657636526 -0500\n@@ -688,7 +688,6 @@\n     if (!inliningLowersCost(fs)) {\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n-        fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 691, 
          "faulty": "fs.setRemove(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_32/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:05:02.027725858 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_32/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:05:02.031725912 -0500\n@@ -498,9 +498,6 @@\n           t, fs, callNode, module, mode);\n       if (!referenceAdded &&\n           mode == InliningMode.DIRECT && blockFunctionInliningEnabled) {\n-        // This reference can not be directly inlined, see if\n-        // block replacement inlining is possible.\n-        mode = InliningMode.BLOCK;\n         referenceAdded = maybeAddReferenceUsingMode(\n             t, fs, callNode, module, mode);\n       }\n@@ -742,7 +739,6 @@\n   private void resolveInlineConflictsForFunction(FunctionState fs) {\n     // Functions that aren't referenced don't cause conflicts.\n     if (!fs.hasReferences() || !fs.canInline()) {\n-      return;\n     }\n \n     Node fnNode = fs.getFn().getFunctionNode();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 503, 
          "faulty": "mode=InliningMode.BLOCK;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 745, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_504/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:11:07.268607532 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2660/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:32:50.175757031 -0500\n@@ -203,8 +203,6 @@\n         LabelInfo li = getLabelInfo(name);\n         if (li != null) {\n           String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n           if (!name.equals(newName)) {\n             // Give it the short name.\n             nameNode.setString(newName);\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2660/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:32:50.175757031 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 207, 
          "faulty": "li.referenced=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1221/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:18:00.614445649 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1221/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:18:00.618445707 -0500\n@@ -742,7 +742,6 @@\n   private void resolveInlineConflictsForFunction(FunctionState fs) {\n     // Functions that aren't referenced don't cause conflicts.\n     if (!fs.hasReferences() || !fs.canInline()) {\n-      return;\n     }\n \n     Node fnNode = fs.getFn().getFunctionNode();\n@@ -886,7 +885,6 @@\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n         if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n         }\n       }\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 889, 
          "faulty": "i.remove();", 
          "type": "Delete", 
          "seed": "this.module=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 745, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2918/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:35:16.173921368 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2918/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:35:16.173921368 -0500\n@@ -688,7 +688,6 @@\n     if (!inliningLowersCost(fs)) {\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n-        fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n@@ -883,7 +882,8 @@\n \n     void removeBlockInliningReferences() {\n       Iterator<Entry<Node, Reference>> i;\n-      for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n+      this.module = null;\n+\tfor (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n         if (entry.getValue().mode == InliningMode.BLOCK) {\n           i.remove();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 886, 
          "faulty": "for (i=getReferencesInternal().entrySet().iterator(); i.hasNext(); ) {\n  Entry<Node,Reference> entry=i.next();\n  if (entry.getValue().mode == InliningMode.BLOCK) {\n    i.remove();\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "this.module=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 691, 
          "faulty": "fs.setRemove(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1135/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:17:10.361718331 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_819/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:14:13.875184097 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_819/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:14:13.879184153 -0500\n@@ -690,9 +690,7 @@\n       if (fs.hasBlockInliningReferences()) {\n         fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n-        if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n-          return false;\n-        }\n+        return false;\n       } else {\n         return false;\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 693, 
          "faulty": "if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1754/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:23:50.663612691 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2629/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:32:34.803527220 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3314/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:39:18.025510485 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3040/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:36:30.579031864 -0500\n@@ -185,7 +185,7 @@\n \n         case Token.BREAK:\n         case Token.CONTINUE:\n-          visitBreakOrContinue(node);\n+          ;\n           break;\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3040/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:36:30.579031864 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3040/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:36:30.583031923 -0500\n@@ -498,9 +498,6 @@\n           t, fs, callNode, module, mode);\n       if (!referenceAdded &&\n           mode == InliningMode.DIRECT && blockFunctionInliningEnabled) {\n-        // This reference can not be directly inlined, see if\n-        // block replacement inlining is possible.\n-        mode = InliningMode.BLOCK;\n         referenceAdded = maybeAddReferenceUsingMode(\n             t, fs, callNode, module, mode);\n       }\n@@ -885,9 +882,7 @@\n       Iterator<Entry<Node, Reference>> i;\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n-        if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n-        }\n+        this.module = null;\n       }\n     }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 888, 
          "faulty": "if (entry.getValue().mode == InliningMode.BLOCK) {\n  i.remove();\n}", 
          "type": "Replace", 
          "seed": "this.module=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 188, 
          "faulty": "visitBreakOrContinue(node);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 503, 
          "faulty": "mode=InliningMode.BLOCK;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1946/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:25:47.305383628 -0500\n@@ -199,7 +199,6 @@\n       if (nameNode != null) {\n         // This is a named break or continue;\n         String name = nameNode.getString();\n-        Preconditions.checkState(name.length() != 0);\n         LabelInfo li = getLabelInfo(name);\n         if (li != null) {\n           String newName = getNameForId(li.id);\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1946/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:25:47.305383628 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 202, 
          "faulty": "Preconditions.checkState(name.length() != 0);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1423/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:19:57.216124289 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1546/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:21:29.193442093 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2575/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:32:07.051111151 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2575/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:32:07.051111151 -0500\n@@ -883,7 +883,8 @@\n \n     void removeBlockInliningReferences() {\n       Iterator<Entry<Node, Reference>> i;\n-      for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n+      this.module = null;\n+\tfor (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n         if (entry.getValue().mode == InliningMode.BLOCK) {\n           i.remove();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 886, 
          "faulty": "for (i=getReferencesInternal().entrySet().iterator(); i.hasNext(); ) {\n  Entry<Node,Reference> entry=i.next();\n  if (entry.getValue().mode == InliningMode.BLOCK) {\n    i.remove();\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "this.module=null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3102/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:37:10.419624572 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3282/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:38:55.517178970 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3236/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:38:31.292821692 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_72/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:05:46.628335820 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_72/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:05:46.628335820 -0500\n@@ -742,7 +742,6 @@\n   private void resolveInlineConflictsForFunction(FunctionState fs) {\n     // Functions that aren't referenced don't cause conflicts.\n     if (!fs.hasReferences() || !fs.canInline()) {\n-      return;\n     }\n \n     Node fnNode = fs.getFn().getFunctionNode();\n@@ -885,9 +884,7 @@\n       Iterator<Entry<Node, Reference>> i;\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n-        if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n-        }\n+        this.module = null;\n       }\n     }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 888, 
          "faulty": "if (entry.getValue().mode == InliningMode.BLOCK) {\n  i.remove();\n}", 
          "type": "Replace", 
          "seed": "this.module=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 745, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2077/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:26:57.602432765 -0500\n@@ -185,7 +185,7 @@\n \n         case Token.BREAK:\n         case Token.CONTINUE:\n-          visitBreakOrContinue(node);\n+          ;\n           break;\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2077/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:26:57.602432765 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 188, 
          "faulty": "visitBreakOrContinue(node);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2224/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:28:39.295933921 -0500\n@@ -206,9 +206,6 @@\n           // Mark the label as referenced so it isn't removed.\n           li.referenced = true;\n           if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n           }\n         }\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2224/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:28:39.295933921 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 210, 
          "faulty": "nameNode.setString(newName);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 211, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1252/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:18:16.006667897 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1252/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:18:16.006667897 -0500\n@@ -498,9 +498,6 @@\n           t, fs, callNode, module, mode);\n       if (!referenceAdded &&\n           mode == InliningMode.DIRECT && blockFunctionInliningEnabled) {\n-        // This reference can not be directly inlined, see if\n-        // block replacement inlining is possible.\n-        mode = InliningMode.BLOCK;\n         referenceAdded = maybeAddReferenceUsingMode(\n             t, fs, callNode, module, mode);\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 503, 
          "faulty": "mode=InliningMode.BLOCK;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1356/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:19:16.735542713 -0500\n@@ -728,7 +728,6 @@\n       if (fnParam != null) {\n         if (cArg != null) {\n           if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n           }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 731, 
          "faulty": "return CanInlineResult.NO;", 
          "type": "Delete", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_245/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:08:11.306236568 -0500\n@@ -196,22 +196,6 @@\n      */\n     private void visitBreakOrContinue(Node node) {\n       Node nameNode = node.getFirstChild();\n-      if (nameNode != null) {\n-        // This is a named break or continue;\n-        String name = nameNode.getString();\n-        Preconditions.checkState(name.length() != 0);\n-        LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n-      }\n     }\n \n     /**\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_245/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:08:11.310236621 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 199, 
          "faulty": "if (nameNode != null) {\n  String name=nameNode.getString();\n  Preconditions.checkState(name.length() != 0);\n  LabelInfo li=getLabelInfo(name);\n  if (li != null) {\n    String newName=getNameForId(li.id);\n    li.referenced=true;\n    if (!name.equals(newName)) {\n      nameNode.setString(newName);\n      compiler.reportCodeChange();\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_679/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:13:00.010159113 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 731, 
          "faulty": "return CanInlineResult.NO;", 
          "type": "Replace", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1270/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:18:25.582806053 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_205/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:07:43.365868578 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_205/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:07:43.365868578 -0500\n@@ -688,7 +688,6 @@\n     if (!inliningLowersCost(fs)) {\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n-        fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n@@ -742,7 +741,6 @@\n   private void resolveInlineConflictsForFunction(FunctionState fs) {\n     // Functions that aren't referenced don't cause conflicts.\n     if (!fs.hasReferences() || !fs.canInline()) {\n-      return;\n     }\n \n     Node fnNode = fs.getFn().getFunctionNode();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 745, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 691, 
          "faulty": "fs.setRemove(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1812/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:24:20.624071946 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2155/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:27:54.555275509 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2786/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:33:59.272785037 -0500\n@@ -185,7 +185,7 @@\n \n         case Token.BREAK:\n         case Token.CONTINUE:\n-          visitBreakOrContinue(node);\n+          ;\n           break;\n       }\n     }\n@@ -205,11 +205,6 @@\n           String newName = getNameForId(li.id);\n           // Mark the label as referenced so it isn't removed.\n           li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n         }\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2786/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:33:59.276785097 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2786/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:33:59.276785097 -0500\n@@ -742,7 +742,6 @@\n   private void resolveInlineConflictsForFunction(FunctionState fs) {\n     // Functions that aren't referenced don't cause conflicts.\n     if (!fs.hasReferences() || !fs.canInline()) {\n-      return;\n     }\n \n     Node fnNode = fs.getFn().getFunctionNode();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 188, 
          "faulty": "visitBreakOrContinue(node);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 208, 
          "faulty": "if (!name.equals(newName)) {\n  nameNode.setString(newName);\n  compiler.reportCodeChange();\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 745, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3285/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:38:57.397206676 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3285/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:38:57.397206676 -0500\n@@ -756,8 +756,6 @@\n           // For functions that can no longer be removed, check if they should\n           // still be inlined.\n           if (!mimimizeCost(fsCalled)) {\n-            // It can't be inlined remove it from the list.\n-            fsCalled.setInline(false);\n           }\n         }\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 760, 
          "faulty": "fsCalled.setInline(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_725/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:13:23.454483838 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2598/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:32:19.431296952 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1232/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:18:06.406529307 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1232/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:18:06.406529307 -0500\n@@ -690,9 +690,7 @@\n       if (fs.hasBlockInliningReferences()) {\n         fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n-        if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n-          return false;\n-        }\n+        return false;\n       } else {\n         return false;\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 693, 
          "faulty": "if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1408/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:19:49.616015183 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1408/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:19:49.616015183 -0500\n@@ -886,7 +886,6 @@\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n         if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n         }\n       }\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 889, 
          "faulty": "i.remove();", 
          "type": "Delete", 
          "seed": "this.module=null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2495/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:31:25.854490401 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3016/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:36:12.966769100 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3016/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:36:12.970769160 -0500\n@@ -688,7 +688,6 @@\n     if (!inliningLowersCost(fs)) {\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n-        fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n@@ -756,8 +755,6 @@\n           // For functions that can no longer be removed, check if they should\n           // still be inlined.\n           if (!mimimizeCost(fsCalled)) {\n-            // It can't be inlined remove it from the list.\n-            fsCalled.setInline(false);\n           }\n         }\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 691, 
          "faulty": "fs.setRemove(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 760, 
          "faulty": "fsCalled.setInline(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2743/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:33:37.600463409 -0500\n@@ -208,7 +208,6 @@\n           if (!name.equals(newName)) {\n             // Give it the short name.\n             nameNode.setString(newName);\n-            compiler.reportCodeChange();\n           }\n         }\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2743/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:33:37.600463409 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 211, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1910/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:25:27.897091871 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1910/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:25:27.897091871 -0500\n@@ -689,10 +689,7 @@\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n         fs.setRemove(false);\n-        fs.removeBlockInliningReferences();\n-        if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n-          return false;\n-        }\n+        return false;\n       } else {\n         return false;\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 693, 
          "faulty": "if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 692, 
          "faulty": "fs.removeBlockInliningReferences();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2565/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:32:02.211038423 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2565/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:32:02.211038423 -0500\n@@ -501,8 +501,6 @@\n         // This reference can not be directly inlined, see if\n         // block replacement inlining is possible.\n         mode = InliningMode.BLOCK;\n-        referenceAdded = maybeAddReferenceUsingMode(\n-            t, fs, callNode, module, mode);\n       }\n \n       if (!referenceAdded) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 504, 
          "faulty": "referenceAdded=maybeAddReferenceUsingMode(t,fs,callNode,module,mode);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1834/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:24:37.240325229 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1834/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:24:37.240325229 -0500\n@@ -742,7 +742,6 @@\n   private void resolveInlineConflictsForFunction(FunctionState fs) {\n     // Functions that aren't referenced don't cause conflicts.\n     if (!fs.hasReferences() || !fs.canInline()) {\n-      return;\n     }\n \n     Node fnNode = fs.getFn().getFunctionNode();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 745, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_801/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:14:05.187063265 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:57:38.329845888 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_801/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:14:05.191063320 -0500\n@@ -1427,11 +1427,7 @@\n   public String checkTreeEquals(Node node2) {\n       NodeMismatch diff = checkTreeEqualsImpl(node2);\n       if (diff != null) {\n-        return \"Node tree inequality:\" +\n-            \"\\nTree1:\\n\" + toStringTree() +\n-            \"\\n\\nTree2:\\n\" + node2.toStringTree() +\n-            \"\\n\\nSubtree1: \" + diff.nodeA.toStringTree() +\n-            \"\\n\\nSubtree2: \" + diff.nodeB.toStringTree();\n+        return \"SCRIPT\";\n       }\n       return null;\n   }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1430, 
          "faulty": "return \"Node tree inequality:\" + \"\\nTree1:\\n\" + toStringTree() + \"\\n\\nTree2:\\n\"+ node2.toStringTree()+ \"\\n\\nSubtree1: \"+ diff.nodeA.toStringTree()+ \"\\n\\nSubtree2: \"+ diff.nodeB.toStringTree();", 
          "type": "Replace", 
          "seed": "return \"SCRIPT\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1850/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:24:45.892456740 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1850/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:24:45.892456740 -0500\n@@ -688,7 +688,6 @@\n     if (!inliningLowersCost(fs)) {\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n-        fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 691, 
          "faulty": "fs.setRemove(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_584/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:12:02.813369666 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_584/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:12:02.813369666 -0500\n@@ -501,8 +501,6 @@\n         // This reference can not be directly inlined, see if\n         // block replacement inlining is possible.\n         mode = InliningMode.BLOCK;\n-        referenceAdded = maybeAddReferenceUsingMode(\n-            t, fs, callNode, module, mode);\n       }\n \n       if (!referenceAdded) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 504, 
          "faulty": "referenceAdded=maybeAddReferenceUsingMode(t,fs,callNode,module,mode);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1898/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:25:22.101004540 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3276/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:38:52.621136284 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1147/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:17:17.041815179 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_658/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:12:48.305997234 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3059/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:36:46.631270942 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_454/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:10:30.612107522 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_771/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:13:48.554832137 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 08:57:38.089845892 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_771/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 09:13:48.554832137 -0500\n@@ -106,7 +106,6 @@\n \n   void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n-      return;\n     }\n \n     int type = n.getType();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CodeGenerator.java", 
          "line": 109, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3094/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:37:05.663553931 -0500\n@@ -199,7 +199,6 @@\n       if (nameNode != null) {\n         // This is a named break or continue;\n         String name = nameNode.getString();\n-        Preconditions.checkState(name.length() != 0);\n         LabelInfo li = getLabelInfo(name);\n         if (li != null) {\n           String newName = getNameForId(li.id);\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3094/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:37:05.663553931 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 202, 
          "faulty": "Preconditions.checkState(name.length() != 0);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_397/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:09:55.027624786 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_397/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:09:55.027624786 -0500\n@@ -688,8 +688,6 @@\n     if (!inliningLowersCost(fs)) {\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n-        fs.setRemove(false);\n-        fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n         }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 691, 
          "faulty": "fs.setRemove(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 692, 
          "faulty": "fs.removeBlockInliningReferences();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3178/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:37:55.160287736 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1282/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:18:37.418976701 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1282/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:18:37.422976759 -0500\n@@ -742,7 +742,6 @@\n   private void resolveInlineConflictsForFunction(FunctionState fs) {\n     // Functions that aren't referenced don't cause conflicts.\n     if (!fs.hasReferences() || !fs.canInline()) {\n-      return;\n     }\n \n     Node fnNode = fs.getFn().getFunctionNode();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 745, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2535/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:31:46.922808355 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 08:57:38.089845892 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2535/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 09:31:46.922808355 -0500\n@@ -106,7 +106,6 @@\n \n   void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n-      return;\n     }\n \n     int type = n.getType();\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2535/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:31:46.926808415 -0500\n@@ -498,9 +498,6 @@\n           t, fs, callNode, module, mode);\n       if (!referenceAdded &&\n           mode == InliningMode.DIRECT && blockFunctionInliningEnabled) {\n-        // This reference can not be directly inlined, see if\n-        // block replacement inlining is possible.\n-        mode = InliningMode.BLOCK;\n         referenceAdded = maybeAddReferenceUsingMode(\n             t, fs, callNode, module, mode);\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 503, 
          "faulty": "mode=InliningMode.BLOCK;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CodeGenerator.java", 
          "line": 109, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2847/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:34:38.657367890 -0500\n@@ -205,11 +205,6 @@\n           String newName = getNameForId(li.id);\n           // Mark the label as referenced so it isn't removed.\n           li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n         }\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2847/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:34:38.661367949 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2847/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:34:38.661367949 -0500\n@@ -742,7 +742,6 @@\n   private void resolveInlineConflictsForFunction(FunctionState fs) {\n     // Functions that aren't referenced don't cause conflicts.\n     if (!fs.hasReferences() || !fs.canInline()) {\n-      return;\n     }\n \n     Node fnNode = fs.getFn().getFunctionNode();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 208, 
          "faulty": "if (!name.equals(newName)) {\n  nameNode.setString(newName);\n  compiler.reportCodeChange();\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 745, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_470/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:10:44.468296221 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3023/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:36:21.890902303 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1324/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:18:59.567295706 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1571/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:21:52.933781569 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2562/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:32:00.295009618 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2331/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:29:35.916810628 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3256/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:38:41.940978804 -0500\n@@ -185,7 +185,7 @@\n \n         case Token.BREAK:\n         case Token.CONTINUE:\n-          visitBreakOrContinue(node);\n+          ;\n           break;\n       }\n     }\n@@ -208,7 +208,6 @@\n           if (!name.equals(newName)) {\n             // Give it the short name.\n             nameNode.setString(newName);\n-            compiler.reportCodeChange();\n           }\n         }\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3256/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:38:41.940978804 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 188, 
          "faulty": "visitBreakOrContinue(node);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 211, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_883/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:14:47.547653000 -0500\n@@ -185,7 +185,7 @@\n \n         case Token.BREAK:\n         case Token.CONTINUE:\n-          visitBreakOrContinue(node);\n+          ;\n           break;\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_883/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:14:47.551653056 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 188, 
          "faulty": "visitBreakOrContinue(node);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2328/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:29:34.032781483 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2328/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:29:34.032781483 -0500\n@@ -691,7 +691,6 @@\n         fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n-          return false;\n         }\n       } else {\n         return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 694, 
          "faulty": "return false;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2541/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:31:49.794851616 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2285/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:29:11.024424395 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2285/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:29:11.024424395 -0500\n@@ -498,9 +498,6 @@\n           t, fs, callNode, module, mode);\n       if (!referenceAdded &&\n           mode == InliningMode.DIRECT && blockFunctionInliningEnabled) {\n-        // This reference can not be directly inlined, see if\n-        // block replacement inlining is possible.\n-        mode = InliningMode.BLOCK;\n         referenceAdded = maybeAddReferenceUsingMode(\n             t, fs, callNode, module, mode);\n       }\n@@ -885,9 +882,6 @@\n       Iterator<Entry<Node, Reference>> i;\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n-        if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n-        }\n       }\n     }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 888, 
          "faulty": "if (entry.getValue().mode == InliningMode.BLOCK) {\n  i.remove();\n}", 
          "type": "Delete", 
          "seed": "this.module=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 503, 
          "faulty": "mode=InliningMode.BLOCK;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1177/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:17:38.482125665 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_168/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:07:13.049472814 -0500\n@@ -206,8 +206,6 @@\n           // Mark the label as referenced so it isn't removed.\n           li.referenced = true;\n           if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n             compiler.reportCodeChange();\n           }\n         }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_168/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:07:13.049472814 -0500\n@@ -728,7 +728,6 @@\n       if (fnParam != null) {\n         if (cArg != null) {\n           if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n           }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:57:38.329845888 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_168/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:07:13.049472814 -0500\n@@ -1456,7 +1456,7 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        parent = null;\n       }\n     }\n     return res;\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_168/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:07:13.053472866 -0500\n@@ -742,7 +742,6 @@\n   private void resolveInlineConflictsForFunction(FunctionState fs) {\n     // Functions that aren't referenced don't cause conflicts.\n     if (!fs.hasReferences() || !fs.canInline()) {\n-      return;\n     }\n \n     Node fnNode = fs.getFn().getFunctionNode();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 210, 
          "faulty": "nameNode.setString(newName);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 745, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 731, 
          "faulty": "return CanInlineResult.NO;", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1459, 
          "faulty": "return res;", 
          "type": "Replace", 
          "seed": "parent=null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1698/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:23:10.626993209 -0500\n@@ -208,7 +208,6 @@\n           if (!name.equals(newName)) {\n             // Give it the short name.\n             nameNode.setString(newName);\n-            compiler.reportCodeChange();\n           }\n         }\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1698/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:23:10.626993209 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 211, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2518/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:31:37.358664150 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1086/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:16:45.173352659 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_262/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:08:22.114379679 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:57:38.329845888 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_262/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:08:22.118379733 -0500\n@@ -1427,11 +1427,7 @@\n   public String checkTreeEquals(Node node2) {\n       NodeMismatch diff = checkTreeEqualsImpl(node2);\n       if (diff != null) {\n-        return \"Node tree inequality:\" +\n-            \"\\nTree1:\\n\" + toStringTree() +\n-            \"\\n\\nTree2:\\n\" + node2.toStringTree() +\n-            \"\\n\\nSubtree1: \" + diff.nodeA.toStringTree() +\n-            \"\\n\\nSubtree2: \" + diff.nodeB.toStringTree();\n+        return \"SCRIPT\";\n       }\n       return null;\n   }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1430, 
          "faulty": "return \"Node tree inequality:\" + \"\\nTree1:\\n\" + toStringTree() + \"\\n\\nTree2:\\n\"+ node2.toStringTree()+ \"\\n\\nSubtree1: \"+ diff.nodeA.toStringTree()+ \"\\n\\nSubtree2: \"+ diff.nodeB.toStringTree();", 
          "type": "Replace", 
          "seed": "return \"SCRIPT\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2430/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:30:45.941884890 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1212/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:17:55.810376236 -0500\n@@ -199,7 +199,6 @@\n       if (nameNode != null) {\n         // This is a named break or continue;\n         String name = nameNode.getString();\n-        Preconditions.checkState(name.length() != 0);\n         LabelInfo li = getLabelInfo(name);\n         if (li != null) {\n           String newName = getNameForId(li.id);\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1212/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:17:55.814376294 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 202, 
          "faulty": "Preconditions.checkState(name.length() != 0);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_993/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:15:50.728559241 -0500\n@@ -196,22 +196,6 @@\n      */\n     private void visitBreakOrContinue(Node node) {\n       Node nameNode = node.getFirstChild();\n-      if (nameNode != null) {\n-        // This is a named break or continue;\n-        String name = nameNode.getString();\n-        Preconditions.checkState(name.length() != 0);\n-        LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n-      }\n     }\n \n     /**\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_993/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:15:50.732559299 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 199, 
          "faulty": "if (nameNode != null) {\n  String name=nameNode.getString();\n  Preconditions.checkState(name.length() != 0);\n  LabelInfo li=getLabelInfo(name);\n  if (li != null) {\n    String newName=getNameForId(li.id);\n    li.referenced=true;\n    if (!name.equals(newName)) {\n      nameNode.setString(newName);\n      compiler.reportCodeChange();\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_487/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:10:58.508487808 -0500\n@@ -185,7 +185,7 @@\n \n         case Token.BREAK:\n         case Token.CONTINUE:\n-          visitBreakOrContinue(node);\n+          ;\n           break;\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_487/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:10:58.512487863 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_487/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:10:58.512487863 -0500\n@@ -885,9 +885,7 @@\n       Iterator<Entry<Node, Reference>> i;\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n-        if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n-        }\n+        this.module = null;\n       }\n     }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 888, 
          "faulty": "if (entry.getValue().mode == InliningMode.BLOCK) {\n  i.remove();\n}", 
          "type": "Replace", 
          "seed": "this.module=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 188, 
          "faulty": "visitBreakOrContinue(node);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_745/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:13:34.094631407 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_377/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:09:39.011408468 -0500\n@@ -185,7 +185,7 @@\n \n         case Token.BREAK:\n         case Token.CONTINUE:\n-          visitBreakOrContinue(node);\n+          ;\n           break;\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_377/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:09:39.011408468 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 188, 
          "faulty": "visitBreakOrContinue(node);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3194/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:38:03.840416130 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3194/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:38:03.840416130 -0500\n@@ -886,7 +886,8 @@\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n         if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n+          this.module = null;\n+\t\ti.remove();\n         }\n       }\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 889, 
          "faulty": "i.remove();", 
          "type": "InsertBefore", 
          "seed": "this.module=null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1554/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:21:33.005496620 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1554/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:21:33.009496677 -0500\n@@ -689,7 +689,6 @@\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n         fs.setRemove(false);\n-        fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n         }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 692, 
          "faulty": "fs.removeBlockInliningReferences();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_832/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:14:20.611277825 -0500\n@@ -203,8 +203,6 @@\n         LabelInfo li = getLabelInfo(name);\n         if (li != null) {\n           String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n           if (!name.equals(newName)) {\n             // Give it the short name.\n             nameNode.setString(newName);\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_832/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:14:20.611277825 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 207, 
          "faulty": "li.referenced=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_600/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:12:11.561490130 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_345/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:09:16.243102080 -0500\n@@ -206,8 +206,6 @@\n           // Mark the label as referenced so it isn't removed.\n           li.referenced = true;\n           if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n             compiler.reportCodeChange();\n           }\n         }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_345/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:09:16.271102457 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 210, 
          "faulty": "nameNode.setString(newName);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1261/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:18:20.810737216 -0500\n@@ -727,9 +727,6 @@\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:57:38.329845888 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_416/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:10:04.967759347 -0500\n@@ -1443,7 +1443,8 @@\n    */\n   NodeMismatch checkTreeEqualsImpl(Node node2) {\n     if (!isEquivalentTo(node2, false, false, false)) {\n-      return new NodeMismatch(this, node2);\n+      this.sourcePosition = sourcePosition;\n+\treturn new NodeMismatch(this, node2);\n     }\n \n     NodeMismatch res = null;\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_416/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:10:04.971759402 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1446, 
          "faulty": "return new NodeMismatch(this,node2);", 
          "type": "InsertBefore", 
          "seed": "this.sourcePosition=sourcePosition;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_846/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:14:28.299384847 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:57:38.329845888 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_846/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:14:28.299384847 -0500\n@@ -1427,11 +1427,7 @@\n   public String checkTreeEquals(Node node2) {\n       NodeMismatch diff = checkTreeEqualsImpl(node2);\n       if (diff != null) {\n-        return \"Node tree inequality:\" +\n-            \"\\nTree1:\\n\" + toStringTree() +\n-            \"\\n\\nTree2:\\n\" + node2.toStringTree() +\n-            \"\\n\\nSubtree1: \" + diff.nodeA.toStringTree() +\n-            \"\\n\\nSubtree2: \" + diff.nodeB.toStringTree();\n+        return \"SCRIPT\";\n       }\n       return null;\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\t2018-12-01 08:57:38.101845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_846/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\t2018-12-01 09:14:28.299384847 -0500\n@@ -63,10 +63,6 @@\n     if (node.isName()) {\n       Node replacementTemplate = replacements.get(node.getString());\n       if (replacementTemplate != null) {\n-        // This should not be replacing declared names.\n-        Preconditions.checkState(!parent.isFunction()\n-            || !parent.isVar()\n-            || !parent.isCatch());\n         // The name may need to be replaced more than once,\n         // so we need to clone the node.\n         Node replacement = replacementTemplate.cloneTree();\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_846/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:14:28.303384903 -0500\n@@ -689,7 +689,6 @@\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n         fs.setRemove(false);\n-        fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n         }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1430, 
          "faulty": "return \"Node tree inequality:\" + \"\\nTree1:\\n\" + toStringTree() + \"\\n\\nTree2:\\n\"+ node2.toStringTree()+ \"\\n\\nSubtree1: \"+ diff.nodeA.toStringTree()+ \"\\n\\nSubtree2: \"+ diff.nodeB.toStringTree();", 
          "type": "Replace", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionArgumentInjector.java", 
          "line": 67, 
          "faulty": "Preconditions.checkState(!parent.isFunction() || !parent.isVar() || !parent.isCatch());", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 692, 
          "faulty": "fs.removeBlockInliningReferences();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1045/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:16:18.928970752 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1752/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:23:49.715598103 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1752/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:23:49.715598103 -0500\n@@ -501,8 +501,6 @@\n         // This reference can not be directly inlined, see if\n         // block replacement inlining is possible.\n         mode = InliningMode.BLOCK;\n-        referenceAdded = maybeAddReferenceUsingMode(\n-            t, fs, callNode, module, mode);\n       }\n \n       if (!referenceAdded) {\n@@ -886,7 +884,6 @@\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n         if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n         }\n       }\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 504, 
          "faulty": "referenceAdded=maybeAddReferenceUsingMode(t,fs,callNode,module,mode);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 889, 
          "faulty": "i.remove();", 
          "type": "Delete", 
          "seed": "this.module=null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_425/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:10:10.811838566 -0500\n@@ -206,8 +206,6 @@\n           // Mark the label as referenced so it isn't removed.\n           li.referenced = true;\n           if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n             compiler.reportCodeChange();\n           }\n         }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_425/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:10:10.811838566 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 210, 
          "faulty": "nameNode.setString(newName);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2853/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:34:41.565410848 -0500\n@@ -208,7 +208,6 @@\n           if (!name.equals(newName)) {\n             // Give it the short name.\n             nameNode.setString(newName);\n-            compiler.reportCodeChange();\n           }\n         }\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2853/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:34:41.565410848 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 211, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3170/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:37:50.768222738 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2690/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:33:04.643972932 -0500\n@@ -201,16 +201,6 @@\n         String name = nameNode.getString();\n         Preconditions.checkState(name.length() != 0);\n         LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n       }\n     }\n \n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2690/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:33:04.647972992 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 204, 
          "faulty": "if (li != null) {\n  String newName=getNameForId(li.id);\n  li.referenced=true;\n  if (!name.equals(newName)) {\n    nameNode.setString(newName);\n    compiler.reportCodeChange();\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2450/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:30:57.486060479 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 08:57:38.089845892 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2450/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 09:30:57.490060540 -0500\n@@ -106,7 +106,6 @@\n \n   void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n-      return;\n     }\n \n     int type = n.getType();\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2450/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:30:57.490060540 -0500\n@@ -742,7 +742,6 @@\n   private void resolveInlineConflictsForFunction(FunctionState fs) {\n     // Functions that aren't referenced don't cause conflicts.\n     if (!fs.hasReferences() || !fs.canInline()) {\n-      return;\n     }\n \n     Node fnNode = fs.getFn().getFunctionNode();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CodeGenerator.java", 
          "line": 109, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 745, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1152/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:17:19.953857379 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1037/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:16:14.972913098 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2446/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:30:55.538030876 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1594/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:22:04.909959247 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1594/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:22:04.909959247 -0500\n@@ -883,7 +883,8 @@\n \n     void removeBlockInliningReferences() {\n       Iterator<Entry<Node, Reference>> i;\n-      for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n+      this.module = null;\n+\tfor (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n         if (entry.getValue().mode == InliningMode.BLOCK) {\n           i.remove();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 886, 
          "faulty": "for (i=getReferencesInternal().entrySet().iterator(); i.hasNext(); ) {\n  Entry<Node,Reference> entry=i.next();\n  if (entry.getValue().mode == InliningMode.BLOCK) {\n    i.remove();\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "this.module=null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_391/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:09:52.003583894 -0500\n@@ -206,8 +206,6 @@\n           // Mark the label as referenced so it isn't removed.\n           li.referenced = true;\n           if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n             compiler.reportCodeChange();\n           }\n         }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_391/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:09:52.003583894 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 210, 
          "faulty": "nameNode.setString(newName);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2625/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:32:32.911498904 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2237/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:28:46.168036061 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2605/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:32:23.271354519 -0500\n@@ -206,8 +206,6 @@\n           // Mark the label as referenced so it isn't removed.\n           li.referenced = true;\n           if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n             compiler.reportCodeChange();\n           }\n         }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2605/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:32:23.275354578 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 210, 
          "faulty": "nameNode.setString(newName);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_805/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:14:07.119090129 -0500\n@@ -196,22 +196,6 @@\n      */\n     private void visitBreakOrContinue(Node node) {\n       Node nameNode = node.getFirstChild();\n-      if (nameNode != null) {\n-        // This is a named break or continue;\n-        String name = nameNode.getString();\n-        Preconditions.checkState(name.length() != 0);\n-        LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n-      }\n     }\n \n     /**\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_805/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:14:07.119090129 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 199, 
          "faulty": "if (nameNode != null) {\n  String name=nameNode.getString();\n  Preconditions.checkState(name.length() != 0);\n  LabelInfo li=getLabelInfo(name);\n  if (li != null) {\n    String newName=getNameForId(li.id);\n    li.referenced=true;\n    if (!name.equals(newName)) {\n      nameNode.setString(newName);\n      compiler.reportCodeChange();\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_136/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:06:41.385063854 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 08:57:38.089845892 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_136/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 09:06:41.385063854 -0500\n@@ -106,7 +106,6 @@\n \n   void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n-      return;\n     }\n \n     int type = n.getType();\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_136/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:06:41.389063906 -0500\n@@ -498,9 +498,6 @@\n           t, fs, callNode, module, mode);\n       if (!referenceAdded &&\n           mode == InliningMode.DIRECT && blockFunctionInliningEnabled) {\n-        // This reference can not be directly inlined, see if\n-        // block replacement inlining is possible.\n-        mode = InliningMode.BLOCK;\n         referenceAdded = maybeAddReferenceUsingMode(\n             t, fs, callNode, module, mode);\n       }\n@@ -691,7 +688,6 @@\n         fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n-          return false;\n         }\n       } else {\n         return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 503, 
          "faulty": "mode=InliningMode.BLOCK;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CodeGenerator.java", 
          "line": 109, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 694, 
          "faulty": "return false;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1770/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:23:59.399746963 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2253/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:28:54.824171614 -0500\n@@ -196,22 +196,6 @@\n      */\n     private void visitBreakOrContinue(Node node) {\n       Node nameNode = node.getFirstChild();\n-      if (nameNode != null) {\n-        // This is a named break or continue;\n-        String name = nameNode.getString();\n-        Preconditions.checkState(name.length() != 0);\n-        LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n-      }\n     }\n \n     /**\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2253/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:28:54.828171676 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 199, 
          "faulty": "if (nameNode != null) {\n  String name=nameNode.getString();\n  Preconditions.checkState(name.length() != 0);\n  LabelInfo li=getLabelInfo(name);\n  if (li != null) {\n    String newName=getNameForId(li.id);\n    li.referenced=true;\n    if (!name.equals(newName)) {\n      nameNode.setString(newName);\n      compiler.reportCodeChange();\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1266/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:18:23.682778648 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1953/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:25:51.169441596 -0500\n@@ -199,7 +199,6 @@\n       if (nameNode != null) {\n         // This is a named break or continue;\n         String name = nameNode.getString();\n-        Preconditions.checkState(name.length() != 0);\n         LabelInfo li = getLabelInfo(name);\n         if (li != null) {\n           String newName = getNameForId(li.id);\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1953/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:25:51.169441596 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 202, 
          "faulty": "Preconditions.checkState(name.length() != 0);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_616/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:12:20.289610425 -0500\n@@ -199,7 +199,6 @@\n       if (nameNode != null) {\n         // This is a named break or continue;\n         String name = nameNode.getString();\n-        Preconditions.checkState(name.length() != 0);\n         LabelInfo li = getLabelInfo(name);\n         if (li != null) {\n           String newName = getNameForId(li.id);\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_616/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:12:20.289610425 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 202, 
          "faulty": "Preconditions.checkState(name.length() != 0);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3232/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:38:29.360793174 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:57:38.329845888 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3232/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:38:29.360793174 -0500\n@@ -1456,7 +1456,6 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n       }\n     }\n     return res;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1459, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "sourcePosition=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_660/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:12:49.294010892 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:57:38.329845888 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_660/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:12:49.298010947 -0500\n@@ -1456,7 +1456,9 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        Preconditions.checkState(this.propListHead == null,\n+\t\t\t\t\"Node has existing properties.\");\n+\t\treturn res;\n       }\n     }\n     return res;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1459, 
          "faulty": "return res;", 
          "type": "InsertBefore", 
          "seed": "Preconditions.checkState(this.propListHead == null,\"Node has existing properties.\");"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2909/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:35:11.377850698 -0500\n@@ -208,7 +208,6 @@\n           if (!name.equals(newName)) {\n             // Give it the short name.\n             nameNode.setString(newName);\n-            compiler.reportCodeChange();\n           }\n         }\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2909/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:35:11.381850756 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2909/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:35:11.381850756 -0500\n@@ -885,9 +885,7 @@\n       Iterator<Entry<Node, Reference>> i;\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n-        if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n-        }\n+        this.module = null;\n       }\n     }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 888, 
          "faulty": "if (entry.getValue().mode == InliningMode.BLOCK) {\n  i.remove();\n}", 
          "type": "Replace", 
          "seed": "this.module=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 211, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_247/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:08:12.274249369 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_247/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:08:12.274249369 -0500\n@@ -689,7 +689,6 @@\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n         fs.setRemove(false);\n-        fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n         }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 692, 
          "faulty": "fs.removeBlockInliningReferences();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1854/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:24:47.800485709 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1934/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:25:40.461280857 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 731, 
          "faulty": "return CanInlineResult.NO;", 
          "type": "Delete", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_403/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:09:57.995664940 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_403/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:09:57.995664940 -0500\n@@ -885,9 +885,7 @@\n       Iterator<Entry<Node, Reference>> i;\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n-        if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n-        }\n+        this.module = null;\n       }\n     }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 888, 
          "faulty": "if (entry.getValue().mode == InliningMode.BLOCK) {\n  i.remove();\n}", 
          "type": "Replace", 
          "seed": "this.module=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_966/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:15:36.168346265 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_278/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:08:30.850495648 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2454/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:30:59.418089828 -0500\n@@ -203,8 +203,6 @@\n         LabelInfo li = getLabelInfo(name);\n         if (li != null) {\n           String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n           if (!name.equals(newName)) {\n             // Give it the short name.\n             nameNode.setString(newName);\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2454/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:30:59.418089828 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 08:57:38.089845892 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2454/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 09:30:59.422089889 -0500\n@@ -106,7 +106,6 @@\n \n   void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n-      return;\n     }\n \n     int type = n.getType();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 207, 
          "faulty": "li.referenced=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CodeGenerator.java", 
          "line": 109, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_399/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:09:56.019638204 -0500\n@@ -185,7 +185,7 @@\n \n         case Token.BREAK:\n         case Token.CONTINUE:\n-          visitBreakOrContinue(node);\n+          ;\n           break;\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_399/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:09:56.019638204 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:57:38.329845888 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_399/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:09:56.019638204 -0500\n@@ -1456,7 +1456,9 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        Preconditions.checkState(this.propListHead == null,\n+\t\t\t\t\"Node has existing properties.\");\n+\t\treturn res;\n       }\n     }\n     return res;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 188, 
          "faulty": "visitBreakOrContinue(node);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1459, 
          "faulty": "return res;", 
          "type": "InsertBefore", 
          "seed": "Preconditions.checkState(this.propListHead == null,\"Node has existing properties.\");"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2591/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:32:15.631239955 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_95/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:06:05.960601466 -0500\n@@ -728,7 +728,6 @@\n       if (fnParam != null) {\n         if (cArg != null) {\n           if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n           }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 08:57:38.089845892 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_95/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 09:06:05.964601522 -0500\n@@ -106,7 +106,6 @@\n \n   void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n-      return;\n     }\n \n     int type = n.getType();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CodeGenerator.java", 
          "line": 109, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 731, 
          "faulty": "return CanInlineResult.NO;", 
          "type": "Delete", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1793/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:24:10.935923813 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 731, 
          "faulty": "return CanInlineResult.NO;", 
          "type": "Replace", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_580/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:12:00.785341754 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\t2018-12-01 08:57:38.101845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_580/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\t2018-12-01 09:12:00.785341754 -0500\n@@ -63,10 +63,6 @@\n     if (node.isName()) {\n       Node replacementTemplate = replacements.get(node.getString());\n       if (replacementTemplate != null) {\n-        // This should not be replacing declared names.\n-        Preconditions.checkState(!parent.isFunction()\n-            || !parent.isVar()\n-            || !parent.isCatch());\n         // The name may need to be replaced more than once,\n         // so we need to clone the node.\n         Node replacement = replacementTemplate.cloneTree();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionArgumentInjector.java", 
          "line": 67, 
          "faulty": "Preconditions.checkState(!parent.isFunction() || !parent.isVar() || !parent.isCatch());", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2654/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:32:47.283713829 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1729/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:23:32.115326569 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1852/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:24:46.852471317 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1852/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:24:46.852471317 -0500\n@@ -501,8 +501,6 @@\n         // This reference can not be directly inlined, see if\n         // block replacement inlining is possible.\n         mode = InliningMode.BLOCK;\n-        referenceAdded = maybeAddReferenceUsingMode(\n-            t, fs, callNode, module, mode);\n       }\n \n       if (!referenceAdded) {\n@@ -688,7 +686,6 @@\n     if (!inliningLowersCost(fs)) {\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n-        fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n@@ -886,7 +883,6 @@\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n         if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n         }\n       }\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 504, 
          "faulty": "referenceAdded=maybeAddReferenceUsingMode(t,fs,callNode,module,mode);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 889, 
          "faulty": "i.remove();", 
          "type": "Delete", 
          "seed": "this.module=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 691, 
          "faulty": "fs.setRemove(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1218/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:17:58.702418026 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1218/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:17:58.702418026 -0500\n@@ -498,9 +498,6 @@\n           t, fs, callNode, module, mode);\n       if (!referenceAdded &&\n           mode == InliningMode.DIRECT && blockFunctionInliningEnabled) {\n-        // This reference can not be directly inlined, see if\n-        // block replacement inlining is possible.\n-        mode = InliningMode.BLOCK;\n         referenceAdded = maybeAddReferenceUsingMode(\n             t, fs, callNode, module, mode);\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 503, 
          "faulty": "mode=InliningMode.BLOCK;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2897/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:35:04.665751753 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3240/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:38:33.212850030 -0500\n@@ -206,8 +206,6 @@\n           // Mark the label as referenced so it isn't removed.\n           li.referenced = true;\n           if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n             compiler.reportCodeChange();\n           }\n         }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3240/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:38:33.212850030 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 210, 
          "faulty": "nameNode.setString(newName);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2392/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:30:25.817577838 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2392/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:30:25.817577838 -0500\n@@ -883,7 +883,8 @@\n \n     void removeBlockInliningReferences() {\n       Iterator<Entry<Node, Reference>> i;\n-      for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n+      this.module = null;\n+\tfor (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n         if (entry.getValue().mode == InliningMode.BLOCK) {\n           i.remove();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 886, 
          "faulty": "for (i=getReferencesInternal().entrySet().iterator(); i.hasNext(); ) {\n  Entry<Node,Reference> entry=i.next();\n  if (entry.getValue().mode == InliningMode.BLOCK) {\n    i.remove();\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "this.module=null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_815/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:14:11.927156999 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1531/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:21:21.553332791 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 731, 
          "faulty": "return CanInlineResult.NO;", 
          "type": "Replace", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1254/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:18:16.950681520 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1244/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:18:12.162612414 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1367/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:19:22.455624961 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3168/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:37:49.812208587 -0500\n@@ -727,9 +727,6 @@\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2694/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:33:06.620002391 -0500\n@@ -185,7 +185,7 @@\n \n         case Token.BREAK:\n         case Token.CONTINUE:\n-          visitBreakOrContinue(node);\n+          ;\n           break;\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2694/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:33:06.624002451 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 188, 
          "faulty": "visitBreakOrContinue(node);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_56/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:05:22.736008534 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_56/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:05:22.736008534 -0500\n@@ -688,7 +688,6 @@\n     if (!inliningLowersCost(fs)) {\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n-        fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 691, 
          "faulty": "fs.setRemove(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_550/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:11:38.949041618 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1655/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:22:42.534554055 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1805/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:24:16.788013333 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_191/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:07:28.525674364 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1401/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:19:45.759959813 -0500\n@@ -201,16 +201,6 @@\n         String name = nameNode.getString();\n         Preconditions.checkState(name.length() != 0);\n         LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n       }\n     }\n \n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1401/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:19:45.759959813 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 204, 
          "faulty": "if (li != null) {\n  String newName=getNameForId(li.id);\n  li.referenced=true;\n  if (!name.equals(newName)) {\n    nameNode.setString(newName);\n    compiler.reportCodeChange();\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2261/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:28:58.652231451 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2261/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:28:58.656231513 -0500\n@@ -501,8 +501,6 @@\n         // This reference can not be directly inlined, see if\n         // block replacement inlining is possible.\n         mode = InliningMode.BLOCK;\n-        referenceAdded = maybeAddReferenceUsingMode(\n-            t, fs, callNode, module, mode);\n       }\n \n       if (!referenceAdded) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 504, 
          "faulty": "referenceAdded=maybeAddReferenceUsingMode(t,fs,callNode,module,mode);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1002/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:15:55.572630017 -0500\n@@ -185,7 +185,7 @@\n \n         case Token.BREAK:\n         case Token.CONTINUE:\n-          visitBreakOrContinue(node);\n+          ;\n           break;\n       }\n     }\n@@ -199,7 +199,6 @@\n       if (nameNode != null) {\n         // This is a named break or continue;\n         String name = nameNode.getString();\n-        Preconditions.checkState(name.length() != 0);\n         LabelInfo li = getLabelInfo(name);\n         if (li != null) {\n           String newName = getNameForId(li.id);\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1002/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:15:55.572630017 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 188, 
          "faulty": "visitBreakOrContinue(node);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 202, 
          "faulty": "Preconditions.checkState(name.length() != 0);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2754/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:33:43.352548839 -0500\n@@ -203,8 +203,6 @@\n         LabelInfo li = getLabelInfo(name);\n         if (li != null) {\n           String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n           if (!name.equals(newName)) {\n             // Give it the short name.\n             nameNode.setString(newName);\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2754/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:33:43.356548899 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 207, 
          "faulty": "li.referenced=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2093/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:27:05.574551081 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2093/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:27:05.574551081 -0500\n@@ -501,8 +501,6 @@\n         // This reference can not be directly inlined, see if\n         // block replacement inlining is possible.\n         mode = InliningMode.BLOCK;\n-        referenceAdded = maybeAddReferenceUsingMode(\n-            t, fs, callNode, module, mode);\n       }\n \n       if (!referenceAdded) {\n@@ -742,7 +740,6 @@\n   private void resolveInlineConflictsForFunction(FunctionState fs) {\n     // Functions that aren't referenced don't cause conflicts.\n     if (!fs.hasReferences() || !fs.canInline()) {\n-      return;\n     }\n \n     Node fnNode = fs.getFn().getFunctionNode();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 504, 
          "faulty": "referenceAdded=maybeAddReferenceUsingMode(t,fs,callNode,module,mode);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 745, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1175/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:17:37.542112063 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1944/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:25:46.353369339 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\t2018-12-01 08:57:38.101845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1944/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\t2018-12-01 09:25:46.357369400 -0500\n@@ -63,10 +63,6 @@\n     if (node.isName()) {\n       Node replacementTemplate = replacements.get(node.getString());\n       if (replacementTemplate != null) {\n-        // This should not be replacing declared names.\n-        Preconditions.checkState(!parent.isFunction()\n-            || !parent.isVar()\n-            || !parent.isCatch());\n         // The name may need to be replaced more than once,\n         // so we need to clone the node.\n         Node replacement = replacementTemplate.cloneTree();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionArgumentInjector.java", 
          "line": 67, 
          "faulty": "Preconditions.checkState(!parent.isFunction() || !parent.isVar() || !parent.isCatch());", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2752/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:33:42.400534704 -0500\n@@ -185,7 +185,7 @@\n \n         case Token.BREAK:\n         case Token.CONTINUE:\n-          visitBreakOrContinue(node);\n+          ;\n           break;\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2752/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:33:42.400534704 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 188, 
          "faulty": "visitBreakOrContinue(node);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2016/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:26:25.989962336 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 08:57:38.089845892 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2016/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 09:26:25.993962396 -0500\n@@ -106,7 +106,6 @@\n \n   void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n-      return;\n     }\n \n     int type = n.getType();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CodeGenerator.java", 
          "line": 109, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1451/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:20:12.660345890 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_964/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:15:35.208332210 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:57:38.329845888 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2087/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:27:02.670507995 -0500\n@@ -1443,7 +1443,8 @@\n    */\n   NodeMismatch checkTreeEqualsImpl(Node node2) {\n     if (!isEquivalentTo(node2, false, false, false)) {\n-      return new NodeMismatch(this, node2);\n+      parent = null;\n+\treturn new NodeMismatch(this, node2);\n     }\n \n     NodeMismatch res = null;\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2087/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:27:02.674508055 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1446, 
          "faulty": "return new NodeMismatch(this,node2);", 
          "type": "InsertBefore", 
          "seed": "parent=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3148/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:37:35.087990511 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3148/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:37:35.091990569 -0500\n@@ -742,7 +742,6 @@\n   private void resolveInlineConflictsForFunction(FunctionState fs) {\n     // Functions that aren't referenced don't cause conflicts.\n     if (!fs.hasReferences() || !fs.canInline()) {\n-      return;\n     }\n \n     Node fnNode = fs.getFn().getFunctionNode();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 745, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2163/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:27:58.367331722 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2893/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:35:02.765723736 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2893/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:35:02.765723736 -0500\n@@ -688,7 +688,6 @@\n     if (!inliningLowersCost(fs)) {\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n-        fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n@@ -894,7 +893,8 @@\n     public boolean hasBlockInliningReferences() {\n       for (Reference r : getReferencesInternal().values()) {\n         if (r.mode == InliningMode.BLOCK) {\n-          return true;\n+          this.module = null;\n+\t\treturn true;\n         }\n       }\n       return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 897, 
          "faulty": "return true;", 
          "type": "InsertBefore", 
          "seed": "this.module=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 691, 
          "faulty": "fs.setRemove(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3051/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:36:42.591210806 -0500\n@@ -208,7 +208,6 @@\n           if (!name.equals(newName)) {\n             // Give it the short name.\n             nameNode.setString(newName);\n-            compiler.reportCodeChange();\n           }\n         }\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3051/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:36:42.603210984 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:57:38.329845888 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3051/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:36:42.603210984 -0500\n@@ -1456,7 +1456,9 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        Preconditions.checkState(this.propListHead == null,\n+\t\t\t\t\"Node has existing properties.\");\n+\t\treturn res;\n       }\n     }\n     return res;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 211, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1459, 
          "faulty": "return res;", 
          "type": "InsertBefore", 
          "seed": "Preconditions.checkState(this.propListHead == null,\"Node has existing properties.\");"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1866/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:24:54.484587097 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1284/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:18:38.370990422 -0500\n@@ -201,16 +201,6 @@\n         String name = nameNode.getString();\n         Preconditions.checkState(name.length() != 0);\n         LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n       }\n     }\n \n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1284/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:18:38.370990422 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 204, 
          "faulty": "if (li != null) {\n  String newName=getNameForId(li.id);\n  li.referenced=true;\n  if (!name.equals(newName)) {\n    nameNode.setString(newName);\n    compiler.reportCodeChange();\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:57:38.329845888 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2988/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:35:58.602554423 -0500\n@@ -1443,7 +1443,9 @@\n    */\n   NodeMismatch checkTreeEqualsImpl(Node node2) {\n     if (!isEquivalentTo(node2, false, false, false)) {\n-      return new NodeMismatch(this, node2);\n+      if (!isEquivalentTo(node2, false, false, false)) {\n+\t\treturn new NodeMismatch(this, node2);\n+\t}\n     }\n \n     NodeMismatch res = null;\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2988/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:35:58.602554423 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1446, 
          "faulty": "return new NodeMismatch(this,node2);", 
          "type": "Replace", 
          "seed": "if (!isEquivalentTo(node2,false,false,false)) {\n  return new NodeMismatch(this,node2);\n}"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1230/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:18:05.446515443 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_795/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:14:02.291023002 -0500\n@@ -728,7 +728,7 @@\n       if (fnParam != null) {\n         if (cArg != null) {\n           if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n+            return null;\n           }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_795/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:14:02.291023002 -0500\n@@ -742,7 +742,6 @@\n   private void resolveInlineConflictsForFunction(FunctionState fs) {\n     // Functions that aren't referenced don't cause conflicts.\n     if (!fs.hasReferences() || !fs.canInline()) {\n-      return;\n     }\n \n     Node fnNode = fs.getFn().getFunctionNode();\n@@ -756,8 +755,6 @@\n           // For functions that can no longer be removed, check if they should\n           // still be inlined.\n           if (!mimimizeCost(fsCalled)) {\n-            // It can't be inlined remove it from the list.\n-            fsCalled.setInline(false);\n           }\n         }\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 745, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 731, 
          "faulty": "return CanInlineResult.NO;", 
          "type": "Replace", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 760, 
          "faulty": "fsCalled.setInline(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2631/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:32:35.771541705 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1006/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:15:57.500658176 -0500\n@@ -728,7 +728,7 @@\n       if (fnParam != null) {\n         if (cArg != null) {\n           if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n+            return null;\n           }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1006/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:15:57.500658176 -0500\n@@ -688,7 +688,6 @@\n     if (!inliningLowersCost(fs)) {\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n-        fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 691, 
          "faulty": "fs.setRemove(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 731, 
          "faulty": "return CanInlineResult.NO;", 
          "type": "Replace", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3049/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:36:41.587195857 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1312/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:18:52.883199476 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1312/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:18:52.887199534 -0500\n@@ -690,9 +690,7 @@\n       if (fs.hasBlockInliningReferences()) {\n         fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n-        if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n-          return false;\n-        }\n+        return false;\n       } else {\n         return false;\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 693, 
          "faulty": "if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_955/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:15:30.080257105 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_955/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:15:30.084257163 -0500\n@@ -501,8 +501,6 @@\n         // This reference can not be directly inlined, see if\n         // block replacement inlining is possible.\n         mode = InliningMode.BLOCK;\n-        referenceAdded = maybeAddReferenceUsingMode(\n-            t, fs, callNode, module, mode);\n       }\n \n       if (!referenceAdded) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 504, 
          "faulty": "referenceAdded=maybeAddReferenceUsingMode(t,fs,callNode,module,mode);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_703/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:13:12.714335003 -0500\n@@ -205,11 +205,6 @@\n           String newName = getNameForId(li.id);\n           // Mark the label as referenced so it isn't removed.\n           li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n         }\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_703/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:13:12.714335003 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 208, 
          "faulty": "if (!name.equals(newName)) {\n  nameNode.setString(newName);\n  compiler.reportCodeChange();\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_460/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:10:33.568147746 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_460/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:10:33.568147746 -0500\n@@ -742,7 +742,6 @@\n   private void resolveInlineConflictsForFunction(FunctionState fs) {\n     // Functions that aren't referenced don't cause conflicts.\n     if (!fs.hasReferences() || !fs.canInline()) {\n-      return;\n     }\n \n     Node fnNode = fs.getFn().getFunctionNode();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 745, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1764/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:23:56.471701994 -0500\n@@ -208,7 +208,6 @@\n           if (!name.equals(newName)) {\n             // Give it the short name.\n             nameNode.setString(newName);\n-            compiler.reportCodeChange();\n           }\n         }\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1764/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:23:56.471701994 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1764/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:23:56.475702055 -0500\n@@ -756,8 +756,6 @@\n           // For functions that can no longer be removed, check if they should\n           // still be inlined.\n           if (!mimimizeCost(fsCalled)) {\n-            // It can't be inlined remove it from the list.\n-            fsCalled.setInline(false);\n           }\n         }\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 211, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 760, 
          "faulty": "fsCalled.setInline(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_140/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:06:44.317101519 -0500\n@@ -185,7 +185,7 @@\n \n         case Token.BREAK:\n         case Token.CONTINUE:\n-          visitBreakOrContinue(node);\n+          ;\n           break;\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_140/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:06:44.317101519 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:57:38.329845888 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_140/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:06:44.321101570 -0500\n@@ -1456,7 +1456,8 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        Preconditions.checkState(this.propListHead == null,\n+\t\t\t\t\"Node has existing properties.\");\n       }\n     }\n     return res;\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_140/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:06:44.321101570 -0500\n@@ -688,7 +688,6 @@\n     if (!inliningLowersCost(fs)) {\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n-        fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 188, 
          "faulty": "visitBreakOrContinue(node);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 691, 
          "faulty": "fs.setRemove(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1459, 
          "faulty": "return res;", 
          "type": "Replace", 
          "seed": "Preconditions.checkState(this.propListHead == null,\"Node has existing properties.\");"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:57:38.329845888 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1050/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:16:26.941087448 -0500\n@@ -1443,7 +1443,9 @@\n    */\n   NodeMismatch checkTreeEqualsImpl(Node node2) {\n     if (!isEquivalentTo(node2, false, false, false)) {\n-      return new NodeMismatch(this, node2);\n+      if (!isEquivalentTo(node2, false, false, false)) {\n+\t\treturn new NodeMismatch(this, node2);\n+\t}\n     }\n \n     NodeMismatch res = null;\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1050/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:16:26.941087448 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1446, 
          "faulty": "return new NodeMismatch(this,node2);", 
          "type": "Replace", 
          "seed": "if (!isEquivalentTo(node2,false,false,false)) {\n  return new NodeMismatch(this,node2);\n}"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_510/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:11:16.332731556 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 731, 
          "faulty": "return CanInlineResult.NO;", 
          "type": "Delete", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_736/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:13:29.290564764 -0500\n@@ -208,7 +208,6 @@\n           if (!name.equals(newName)) {\n             // Give it the short name.\n             nameNode.setString(newName);\n-            compiler.reportCodeChange();\n           }\n         }\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_736/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:13:29.290564764 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_736/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:13:29.290564764 -0500\n@@ -688,7 +688,6 @@\n     if (!inliningLowersCost(fs)) {\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n-        fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 211, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 691, 
          "faulty": "fs.setRemove(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2314/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:29:26.376662901 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_232/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:08:02.650122251 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_232/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:08:02.650122251 -0500\n@@ -883,12 +883,6 @@\n \n     void removeBlockInliningReferences() {\n       Iterator<Entry<Node, Reference>> i;\n-      for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n-        Entry<Node, Reference> entry = i.next();\n-        if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n-        }\n-      }\n     }\n \n     public boolean hasBlockInliningReferences() {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 888, 
          "faulty": "if (entry.getValue().mode == InliningMode.BLOCK) {\n  i.remove();\n}", 
          "type": "Replace", 
          "seed": "this.module=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 886, 
          "faulty": "for (i=getReferencesInternal().entrySet().iterator(); i.hasNext(); ) {\n  Entry<Node,Reference> entry=i.next();\n  if (entry.getValue().mode == InliningMode.BLOCK) {\n    i.remove();\n  }\n}", 
          "type": "Delete", 
          "seed": "this.module=null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1076/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:16:40.421283579 -0500\n@@ -201,16 +201,6 @@\n         String name = nameNode.getString();\n         Preconditions.checkState(name.length() != 0);\n         LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n       }\n     }\n \n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1076/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:16:40.421283579 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 204, 
          "faulty": "if (li != null) {\n  String newName=getNameForId(li.id);\n  li.referenced=true;\n  if (!name.equals(newName)) {\n    nameNode.setString(newName);\n    compiler.reportCodeChange();\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_653/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:12:45.377956761 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_653/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:12:45.377956761 -0500\n@@ -498,9 +498,6 @@\n           t, fs, callNode, module, mode);\n       if (!referenceAdded &&\n           mode == InliningMode.DIRECT && blockFunctionInliningEnabled) {\n-        // This reference can not be directly inlined, see if\n-        // block replacement inlining is possible.\n-        mode = InliningMode.BLOCK;\n         referenceAdded = maybeAddReferenceUsingMode(\n             t, fs, callNode, module, mode);\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 503, 
          "faulty": "mode=InliningMode.BLOCK;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1522/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:21:16.793264679 -0500\n@@ -185,7 +185,7 @@\n \n         case Token.BREAK:\n         case Token.CONTINUE:\n-          visitBreakOrContinue(node);\n+          ;\n           break;\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1522/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:21:16.793264679 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 188, 
          "faulty": "visitBreakOrContinue(node);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2396/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:30:27.749607372 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2396/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:30:27.753607432 -0500\n@@ -756,8 +756,6 @@\n           // For functions that can no longer be removed, check if they should\n           // still be inlined.\n           if (!mimimizeCost(fsCalled)) {\n-            // It can't be inlined remove it from the list.\n-            fsCalled.setInline(false);\n           }\n         }\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 760, 
          "faulty": "fsCalled.setInline(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1580/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:21:57.997853953 -0500\n@@ -727,9 +727,6 @@\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1494/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:20:56.404972819 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1494/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:20:56.408972878 -0500\n@@ -688,7 +688,6 @@\n     if (!inliningLowersCost(fs)) {\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n-        fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 691, 
          "faulty": "fs.setRemove(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1098/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:16:51.021437632 -0500\n@@ -727,9 +727,6 @@\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1761/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:23:54.511671873 -0500\n@@ -185,7 +185,7 @@\n \n         case Token.BREAK:\n         case Token.CONTINUE:\n-          visitBreakOrContinue(node);\n+          ;\n           break;\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1761/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:23:54.515671934 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 188, 
          "faulty": "visitBreakOrContinue(node);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2065/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:26:51.870347618 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_912/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:15:02.411860270 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_912/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:15:02.415860326 -0500\n@@ -756,8 +756,6 @@\n           // For functions that can no longer be removed, check if they should\n           // still be inlined.\n           if (!mimimizeCost(fsCalled)) {\n-            // It can't be inlined remove it from the list.\n-            fsCalled.setInline(false);\n           }\n         }\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 760, 
          "faulty": "fsCalled.setInline(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2992/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:36:00.506582899 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2992/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:36:00.510582959 -0500\n@@ -691,7 +691,6 @@\n         fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n-          return false;\n         }\n       } else {\n         return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 694, 
          "faulty": "return false;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2646/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:32:43.427656203 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1291/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:18:42.243046218 -0500\n@@ -185,7 +185,7 @@\n \n         case Token.BREAK:\n         case Token.CONTINUE:\n-          visitBreakOrContinue(node);\n+          ;\n           break;\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1291/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:18:42.243046218 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 188, 
          "faulty": "visitBreakOrContinue(node);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_523/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:11:23.284826776 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_523/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:11:23.284826776 -0500\n@@ -689,7 +689,6 @@\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n         fs.setRemove(false);\n-        fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n         }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 692, 
          "faulty": "fs.removeBlockInliningReferences();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1108/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:16:55.821507343 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_962/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:15:34.260318329 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3130/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:37:25.311845578 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3130/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:37:25.311845578 -0500\n@@ -501,8 +501,6 @@\n         // This reference can not be directly inlined, see if\n         // block replacement inlining is possible.\n         mode = InliningMode.BLOCK;\n-        referenceAdded = maybeAddReferenceUsingMode(\n-            t, fs, callNode, module, mode);\n       }\n \n       if (!referenceAdded) {\n@@ -884,7 +882,8 @@\n     void removeBlockInliningReferences() {\n       Iterator<Entry<Node, Reference>> i;\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n-        Entry<Node, Reference> entry = i.next();\n+        this.module = null;\n+\t\tEntry<Node, Reference> entry = i.next();\n         if (entry.getValue().mode == InliningMode.BLOCK) {\n           i.remove();\n         }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 504, 
          "faulty": "referenceAdded=maybeAddReferenceUsingMode(t,fs,callNode,module,mode);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 887, 
          "faulty": "Entry<Node,Reference> entry=i.next();", 
          "type": "InsertBefore", 
          "seed": "this.module=null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2925/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:35:20.421983944 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2925/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:35:20.421983944 -0500\n@@ -894,7 +894,7 @@\n     public boolean hasBlockInliningReferences() {\n       for (Reference r : getReferencesInternal().values()) {\n         if (r.mode == InliningMode.BLOCK) {\n-          return true;\n+          return false;\n         }\n       }\n       return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 897, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_982/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:15:44.976475147 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2302/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:29:20.600573281 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2302/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:29:20.600573281 -0500\n@@ -688,7 +688,6 @@\n     if (!inliningLowersCost(fs)) {\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n-        fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 691, 
          "faulty": "fs.setRemove(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2812/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:34:13.780999979 -0500\n@@ -199,7 +199,6 @@\n       if (nameNode != null) {\n         // This is a named break or continue;\n         String name = nameNode.getString();\n-        Preconditions.checkState(name.length() != 0);\n         LabelInfo li = getLabelInfo(name);\n         if (li != null) {\n           String newName = getNameForId(li.id);\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2812/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:34:13.780999979 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 202, 
          "faulty": "Preconditions.checkState(name.length() != 0);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2652/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:32:46.339699724 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 08:57:38.089845892 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2652/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 09:32:46.339699724 -0500\n@@ -106,7 +106,6 @@\n \n   void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n-      return;\n     }\n \n     int type = n.getType();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CodeGenerator.java", 
          "line": 109, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_733/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:13:27.374538192 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1214/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:17:56.798390514 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1214/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:17:56.798390514 -0500\n@@ -498,9 +498,6 @@\n           t, fs, callNode, module, mode);\n       if (!referenceAdded &&\n           mode == InliningMode.DIRECT && blockFunctionInliningEnabled) {\n-        // This reference can not be directly inlined, see if\n-        // block replacement inlining is possible.\n-        mode = InliningMode.BLOCK;\n         referenceAdded = maybeAddReferenceUsingMode(\n             t, fs, callNode, module, mode);\n       }\n@@ -689,7 +686,6 @@\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n         fs.setRemove(false);\n-        fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n         }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 503, 
          "faulty": "mode=InliningMode.BLOCK;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 692, 
          "faulty": "fs.removeBlockInliningReferences();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_203/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:07:42.389855777 -0500\n@@ -185,7 +185,7 @@\n \n         case Token.BREAK:\n         case Token.CONTINUE:\n-          visitBreakOrContinue(node);\n+          ;\n           break;\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_203/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:07:42.389855777 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 08:57:38.089845892 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_203/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 09:07:42.389855777 -0500\n@@ -106,7 +106,6 @@\n \n   void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n-      return;\n     }\n \n     int type = n.getType();\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_203/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:07:42.393855830 -0500\n@@ -688,7 +688,6 @@\n     if (!inliningLowersCost(fs)) {\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n-        fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 188, 
          "faulty": "visitBreakOrContinue(node);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CodeGenerator.java", 
          "line": 109, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 691, 
          "faulty": "fs.setRemove(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_673/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:12:57.074118490 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1683/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:22:56.890778973 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2756/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:33:44.320563212 -0500\n@@ -203,8 +203,6 @@\n         LabelInfo li = getLabelInfo(name);\n         if (li != null) {\n           String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n           if (!name.equals(newName)) {\n             // Give it the short name.\n             nameNode.setString(newName);\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2756/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:33:44.320563212 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2756/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:33:44.320563212 -0500\n@@ -498,9 +498,6 @@\n           t, fs, callNode, module, mode);\n       if (!referenceAdded &&\n           mode == InliningMode.DIRECT && blockFunctionInliningEnabled) {\n-        // This reference can not be directly inlined, see if\n-        // block replacement inlining is possible.\n-        mode = InliningMode.BLOCK;\n         referenceAdded = maybeAddReferenceUsingMode(\n             t, fs, callNode, module, mode);\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 503, 
          "faulty": "mode=InliningMode.BLOCK;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 207, 
          "faulty": "li.referenced=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3183/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:37:58.040330345 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1332/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:19:03.363350341 -0500\n@@ -203,8 +203,6 @@\n         LabelInfo li = getLabelInfo(name);\n         if (li != null) {\n           String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n           if (!name.equals(newName)) {\n             // Give it the short name.\n             nameNode.setString(newName);\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1332/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:19:03.367350398 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 08:57:38.089845892 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1332/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 09:19:03.367350398 -0500\n@@ -106,7 +106,6 @@\n \n   void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n-      return;\n     }\n \n     int type = n.getType();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 207, 
          "faulty": "li.referenced=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CodeGenerator.java", 
          "line": 109, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1537/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:21:24.437374055 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1537/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:21:24.441374112 -0500\n@@ -689,7 +689,6 @@\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n         fs.setRemove(false);\n-        fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n         }\n@@ -886,7 +885,8 @@\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n         if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n+          this.module = null;\n+\t\ti.remove();\n         }\n       }\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 889, 
          "faulty": "i.remove();", 
          "type": "InsertBefore", 
          "seed": "this.module=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 692, 
          "faulty": "fs.removeBlockInliningReferences();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1936/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:25:41.433295461 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_575/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:11:57.797300642 -0500\n@@ -196,22 +196,6 @@\n      */\n     private void visitBreakOrContinue(Node node) {\n       Node nameNode = node.getFirstChild();\n-      if (nameNode != null) {\n-        // This is a named break or continue;\n-        String name = nameNode.getString();\n-        Preconditions.checkState(name.length() != 0);\n-        LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n-      }\n     }\n \n     /**\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_575/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:11:57.797300642 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 199, 
          "faulty": "if (nameNode != null) {\n  String name=nameNode.getString();\n  Preconditions.checkState(name.length() != 0);\n  LabelInfo li=getLabelInfo(name);\n  if (li != null) {\n    String newName=getNameForId(li.id);\n    li.referenced=true;\n    if (!name.equals(newName)) {\n      nameNode.setString(newName);\n      compiler.reportCodeChange();\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2249/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:28:52.892141389 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2030/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:26:32.694062276 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2030/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:26:32.694062276 -0500\n@@ -691,7 +691,6 @@\n         fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n-          return false;\n         }\n       } else {\n         return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 694, 
          "faulty": "return false;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 731, 
          "faulty": "return CanInlineResult.NO;", 
          "type": "Replace", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_830/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:14:19.651264465 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_830/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:14:19.651264465 -0500\n@@ -690,9 +690,6 @@\n       if (fs.hasBlockInliningReferences()) {\n         fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n-        if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n-          return false;\n-        }\n       } else {\n         return false;\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 693, 
          "faulty": "if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1519/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:21:14.877237260 -0500\n@@ -199,7 +199,6 @@\n       if (nameNode != null) {\n         // This is a named break or continue;\n         String name = nameNode.getString();\n-        Preconditions.checkState(name.length() != 0);\n         LabelInfo li = getLabelInfo(name);\n         if (li != null) {\n           String newName = getNameForId(li.id);\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1519/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:21:14.877237260 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 202, 
          "faulty": "Preconditions.checkState(name.length() != 0);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3077/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:36:56.987424989 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3077/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:36:56.987424989 -0500\n@@ -689,7 +689,6 @@\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n         fs.setRemove(false);\n-        fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n         }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 692, 
          "faulty": "fs.removeBlockInliningReferences();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2627/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:32:33.855513033 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2443/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:30:53.602001445 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_723/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:13:22.454469974 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1824/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:24:26.332159064 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2194/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:28:13.723557945 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3137/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:37:29.195903173 -0500\n@@ -185,7 +185,7 @@\n \n         case Token.BREAK:\n         case Token.CONTINUE:\n-          visitBreakOrContinue(node);\n+          ;\n           break;\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3137/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:37:29.195903173 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 188, 
          "faulty": "visitBreakOrContinue(node);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:57:38.329845888 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2864/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:34:47.373496619 -0500\n@@ -1443,7 +1443,8 @@\n    */\n   NodeMismatch checkTreeEqualsImpl(Node node2) {\n     if (!isEquivalentTo(node2, false, false, false)) {\n-      return new NodeMismatch(this, node2);\n+      this.sourcePosition = sourcePosition;\n+\treturn new NodeMismatch(this, node2);\n     }\n \n     NodeMismatch res = null;\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2864/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:34:47.373496619 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1446, 
          "faulty": "return new NodeMismatch(this,node2);", 
          "type": "InsertBefore", 
          "seed": "this.sourcePosition=sourcePosition;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_548/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:11:37.997028550 -0500\n@@ -185,7 +185,7 @@\n \n         case Token.BREAK:\n         case Token.CONTINUE:\n-          visitBreakOrContinue(node);\n+          ;\n           break;\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_548/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:11:37.997028550 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 188, 
          "faulty": "visitBreakOrContinue(node);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2116/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:27:23.182811988 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1056/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:16:29.833129547 -0500\n@@ -208,7 +208,6 @@\n           if (!name.equals(newName)) {\n             // Give it the short name.\n             nameNode.setString(newName);\n-            compiler.reportCodeChange();\n           }\n         }\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1056/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:16:29.833129547 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1056/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:16:29.833129547 -0500\n@@ -742,7 +742,6 @@\n   private void resolveInlineConflictsForFunction(FunctionState fs) {\n     // Functions that aren't referenced don't cause conflicts.\n     if (!fs.hasReferences() || !fs.canInline()) {\n-      return;\n     }\n \n     Node fnNode = fs.getFn().getFunctionNode();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 745, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 211, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_834/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:14:21.583291353 -0500\n@@ -205,11 +205,6 @@\n           String newName = getNameForId(li.id);\n           // Mark the label as referenced so it isn't removed.\n           li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n         }\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_834/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:14:21.587291410 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_834/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:14:21.587291410 -0500\n@@ -894,7 +894,8 @@\n     public boolean hasBlockInliningReferences() {\n       for (Reference r : getReferencesInternal().values()) {\n         if (r.mode == InliningMode.BLOCK) {\n-          return true;\n+          this.module = null;\n+\t\treturn true;\n         }\n       }\n       return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 897, 
          "faulty": "return true;", 
          "type": "InsertBefore", 
          "seed": "this.module=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 208, 
          "faulty": "if (!name.equals(newName)) {\n  nameNode.setString(newName);\n  compiler.reportCodeChange();\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_873/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:14:41.711571665 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_707/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:13:14.654361878 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2106/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:27:17.422726702 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2106/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:27:17.422726702 -0500\n@@ -501,8 +501,6 @@\n         // This reference can not be directly inlined, see if\n         // block replacement inlining is possible.\n         mode = InliningMode.BLOCK;\n-        referenceAdded = maybeAddReferenceUsingMode(\n-            t, fs, callNode, module, mode);\n       }\n \n       if (!referenceAdded) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 504, 
          "faulty": "referenceAdded=maybeAddReferenceUsingMode(t,fs,callNode,module,mode);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2845/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:34:37.693353646 -0500\n@@ -208,7 +208,6 @@\n           if (!name.equals(newName)) {\n             // Give it the short name.\n             nameNode.setString(newName);\n-            compiler.reportCodeChange();\n           }\n         }\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2845/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:34:37.693353646 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 211, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2004/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:26:19.229861461 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2004/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:26:19.233861520 -0500\n@@ -885,9 +885,6 @@\n       Iterator<Entry<Node, Reference>> i;\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n-        if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n-        }\n       }\n     }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 888, 
          "faulty": "if (entry.getValue().mode == InliningMode.BLOCK) {\n  i.remove();\n}", 
          "type": "Delete", 
          "seed": "this.module=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1627/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:22:28.194328298 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1529/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:21:20.613319342 -0500\n@@ -185,7 +185,7 @@\n \n         case Token.BREAK:\n         case Token.CONTINUE:\n-          visitBreakOrContinue(node);\n+          ;\n           break;\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1529/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:21:20.613319342 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 188, 
          "faulty": "visitBreakOrContinue(node);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_753/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:13:38.942698682 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1013/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:16:01.352714419 -0500\n@@ -727,9 +727,6 @@\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1013/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:16:01.352714419 -0500\n@@ -886,7 +886,6 @@\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n         if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n         }\n       }\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 889, 
          "faulty": "i.remove();", 
          "type": "Delete", 
          "seed": "this.module=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_23/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:04:54.223619585 -0500\n@@ -196,22 +196,6 @@\n      */\n     private void visitBreakOrContinue(Node node) {\n       Node nameNode = node.getFirstChild();\n-      if (nameNode != null) {\n-        // This is a named break or continue;\n-        String name = nameNode.getString();\n-        Preconditions.checkState(name.length() != 0);\n-        LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n-      }\n     }\n \n     /**\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_23/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:04:54.227619640 -0500\n@@ -728,7 +728,7 @@\n       if (fnParam != null) {\n         if (cArg != null) {\n           if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n+            return null;\n           }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 199, 
          "faulty": "if (nameNode != null) {\n  String name=nameNode.getString();\n  Preconditions.checkState(name.length() != 0);\n  LabelInfo li=getLabelInfo(name);\n  if (li != null) {\n    String newName=getNameForId(li.id);\n    li.referenced=true;\n    if (!name.equals(newName)) {\n      nameNode.setString(newName);\n      compiler.reportCodeChange();\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 731, 
          "faulty": "return CanInlineResult.NO;", 
          "type": "Replace", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1164/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:17:25.693940536 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1881/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:25:13.480874485 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1881/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:25:13.480874485 -0500\n@@ -885,9 +885,6 @@\n       Iterator<Entry<Node, Reference>> i;\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n-        if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n-        }\n       }\n     }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 888, 
          "faulty": "if (entry.getValue().mode == InliningMode.BLOCK) {\n  i.remove();\n}", 
          "type": "Delete", 
          "seed": "this.module=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1573/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:21:53.937795921 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2008/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:26:21.137889943 -0500\n@@ -199,7 +199,6 @@\n       if (nameNode != null) {\n         // This is a named break or continue;\n         String name = nameNode.getString();\n-        Preconditions.checkState(name.length() != 0);\n         LabelInfo li = getLabelInfo(name);\n         if (li != null) {\n           String newName = getNameForId(li.id);\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2008/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:26:21.137889943 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 202, 
          "faulty": "Preconditions.checkState(name.length() != 0);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_207/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:07:44.321881120 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1772/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:24:00.347761516 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2607/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:32:24.239369025 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 08:57:38.089845892 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2607/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 09:32:24.239369025 -0500\n@@ -106,7 +106,6 @@\n \n   void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n-      return;\n     }\n \n     int type = n.getType();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CodeGenerator.java", 
          "line": 109, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 731, 
          "faulty": "return CanInlineResult.NO;", 
          "type": "Replace", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2014/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:26:25.017947838 -0500\n@@ -203,8 +203,6 @@\n         LabelInfo li = getLabelInfo(name);\n         if (li != null) {\n           String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n           if (!name.equals(newName)) {\n             // Give it the short name.\n             nameNode.setString(newName);\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2014/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:26:25.021947898 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2014/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:26:25.021947898 -0500\n@@ -690,9 +690,7 @@\n       if (fs.hasBlockInliningReferences()) {\n         fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n-        if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n-          return false;\n-        }\n+        return false;\n       } else {\n         return false;\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 207, 
          "faulty": "li.referenced=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 693, 
          "faulty": "if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_822/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:14:15.779210586 -0500\n@@ -208,7 +208,6 @@\n           if (!name.equals(newName)) {\n             // Give it the short name.\n             nameNode.setString(newName);\n-            compiler.reportCodeChange();\n           }\n         }\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_822/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:14:15.779210586 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 211, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1766/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:23:57.479717479 -0500\n@@ -201,16 +201,6 @@\n         String name = nameNode.getString();\n         Preconditions.checkState(name.length() != 0);\n         LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n       }\n     }\n \n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1766/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:23:57.479717479 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1766/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:23:57.479717479 -0500\n@@ -742,7 +742,6 @@\n   private void resolveInlineConflictsForFunction(FunctionState fs) {\n     // Functions that aren't referenced don't cause conflicts.\n     if (!fs.hasReferences() || !fs.canInline()) {\n-      return;\n     }\n \n     Node fnNode = fs.getFn().getFunctionNode();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 745, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 204, 
          "faulty": "if (li != null) {\n  String newName=getNameForId(li.id);\n  li.referenced=true;\n  if (!name.equals(newName)) {\n    nameNode.setString(newName);\n    compiler.reportCodeChange();\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1688/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:22:59.734823405 -0500\n@@ -196,22 +196,6 @@\n      */\n     private void visitBreakOrContinue(Node node) {\n       Node nameNode = node.getFirstChild();\n-      if (nameNode != null) {\n-        // This is a named break or continue;\n-        String name = nameNode.getString();\n-        Preconditions.checkState(name.length() != 0);\n-        LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n-      }\n     }\n \n     /**\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1688/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:22:59.734823405 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 199, 
          "faulty": "if (nameNode != null) {\n  String name=nameNode.getString();\n  Preconditions.checkState(name.length() != 0);\n  LabelInfo li=getLabelInfo(name);\n  if (li != null) {\n    String newName=getNameForId(li.id);\n    li.referenced=true;\n    if (!name.equals(newName)) {\n      nameNode.setString(newName);\n      compiler.reportCodeChange();\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1365/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:19:21.507611331 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2306/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:29:22.552603583 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2560/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:31:59.346995362 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3219/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:38:17.404616612 -0500\n@@ -185,7 +185,7 @@\n \n         case Token.BREAK:\n         case Token.CONTINUE:\n-          visitBreakOrContinue(node);\n+          ;\n           break;\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3219/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:38:17.408616671 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionToBlockMutator.java\t2018-12-01 08:57:38.101845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3219/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionToBlockMutator.java\t2018-12-01 09:38:17.408616671 -0500\n@@ -198,7 +198,7 @@\n \n     @Override\n     public String get() {\n-        return \"JSCompiler_inline_label_\" + idSupplier.get();\n+        return null;\n     }\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 188, 
          "faulty": "visitBreakOrContinue(node);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionToBlockMutator.java", 
          "line": 201, 
          "faulty": "return \"JSCompiler_inline_label_\" + idSupplier.get();", 
          "type": "Replace", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_409/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:10:01.003705657 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\t2018-12-01 08:57:38.101845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_409/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\t2018-12-01 09:10:01.003705657 -0500\n@@ -63,10 +63,6 @@\n     if (node.isName()) {\n       Node replacementTemplate = replacements.get(node.getString());\n       if (replacementTemplate != null) {\n-        // This should not be replacing declared names.\n-        Preconditions.checkState(!parent.isFunction()\n-            || !parent.isVar()\n-            || !parent.isCatch());\n         // The name may need to be replaced more than once,\n         // so we need to clone the node.\n         Node replacement = replacementTemplate.cloneTree();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionArgumentInjector.java", 
          "line": 67, 
          "faulty": "Preconditions.checkState(!parent.isFunction() || !parent.isVar() || !parent.isCatch());", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3226/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:38:26.488750774 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_236/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:08:04.594147900 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_236/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:08:04.594147900 -0500\n@@ -883,12 +883,6 @@\n \n     void removeBlockInliningReferences() {\n       Iterator<Entry<Node, Reference>> i;\n-      for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n-        Entry<Node, Reference> entry = i.next();\n-        if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n-        }\n-      }\n     }\n \n     public boolean hasBlockInliningReferences() {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 887, 
          "faulty": "Entry<Node,Reference> entry=i.next();", 
          "type": "InsertBefore", 
          "seed": "this.module=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 886, 
          "faulty": "for (i=getReferencesInternal().entrySet().iterator(); i.hasNext(); ) {\n  Entry<Node,Reference> entry=i.next();\n  if (entry.getValue().mode == InliningMode.BLOCK) {\n    i.remove();\n  }\n}", 
          "type": "Delete", 
          "seed": "this.module=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 731, 
          "faulty": "return CanInlineResult.NO;", 
          "type": "Delete", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_953/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:15:29.092242629 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_953/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:15:29.096242688 -0500\n@@ -886,7 +886,6 @@\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n         if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n         }\n       }\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 889, 
          "faulty": "i.remove();", 
          "type": "Delete", 
          "seed": "this.module=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_643/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:12:40.337887121 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\t2018-12-01 08:57:38.101845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_643/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\t2018-12-01 09:12:40.337887121 -0500\n@@ -63,10 +63,6 @@\n     if (node.isName()) {\n       Node replacementTemplate = replacements.get(node.getString());\n       if (replacementTemplate != null) {\n-        // This should not be replacing declared names.\n-        Preconditions.checkState(!parent.isFunction()\n-            || !parent.isVar()\n-            || !parent.isCatch());\n         // The name may need to be replaced more than once,\n         // so we need to clone the node.\n         Node replacement = replacementTemplate.cloneTree();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionArgumentInjector.java", 
          "line": 67, 
          "faulty": "Preconditions.checkState(!parent.isFunction() || !parent.isVar() || !parent.isCatch());", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_807/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:14:08.075103424 -0500\n@@ -727,9 +727,6 @@\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_807/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:14:08.075103424 -0500\n@@ -688,7 +688,6 @@\n     if (!inliningLowersCost(fs)) {\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n-        fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 691, 
          "faulty": "fs.setRemove(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1306/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:18:50.015158175 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1306/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:18:50.015158175 -0500\n@@ -883,7 +883,8 @@\n \n     void removeBlockInliningReferences() {\n       Iterator<Entry<Node, Reference>> i;\n-      for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n+      this.module = null;\n+\tfor (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n         if (entry.getValue().mode == InliningMode.BLOCK) {\n           i.remove();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 886, 
          "faulty": "for (i=getReferencesInternal().entrySet().iterator(); i.hasNext(); ) {\n  Entry<Node,Reference> entry=i.next();\n  if (entry.getValue().mode == InliningMode.BLOCK) {\n    i.remove();\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "this.module=null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1328/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:19:01.451322824 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3166/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:37:48.864194554 -0500\n@@ -203,8 +203,6 @@\n         LabelInfo li = getLabelInfo(name);\n         if (li != null) {\n           String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n           if (!name.equals(newName)) {\n             // Give it the short name.\n             nameNode.setString(newName);\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3166/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:37:48.868194612 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 207, 
          "faulty": "li.referenced=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2184/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:28:08.931487389 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2662/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:32:51.155771667 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2977/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:35:52.838468178 -0500\n@@ -201,16 +201,6 @@\n         String name = nameNode.getString();\n         Preconditions.checkState(name.length() != 0);\n         LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n       }\n     }\n \n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2977/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:35:52.838468178 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 204, 
          "faulty": "if (li != null) {\n  String newName=getNameForId(li.id);\n  li.referenced=true;\n  if (!name.equals(newName)) {\n    nameNode.setString(newName);\n    compiler.reportCodeChange();\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3270/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:38:48.677078140 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2668/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:32:54.035814669 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1041/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:16:16.988942482 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1041/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:16:16.992942540 -0500\n@@ -886,7 +886,8 @@\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n         if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n+          this.module = null;\n+\t\ti.remove();\n         }\n       }\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 889, 
          "faulty": "i.remove();", 
          "type": "InsertBefore", 
          "seed": "this.module=null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2440/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:30:51.705972611 -0500\n@@ -185,7 +185,7 @@\n \n         case Token.BREAK:\n         case Token.CONTINUE:\n-          visitBreakOrContinue(node);\n+          ;\n           break;\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2440/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:30:51.705972611 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 188, 
          "faulty": "visitBreakOrContinue(node);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2235/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:28:45.220021193 -0500\n@@ -201,16 +201,6 @@\n         String name = nameNode.getString();\n         Preconditions.checkState(name.length() != 0);\n         LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n       }\n     }\n \n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2235/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:28:45.224021256 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2235/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:28:45.224021256 -0500\n@@ -501,8 +501,6 @@\n         // This reference can not be directly inlined, see if\n         // block replacement inlining is possible.\n         mode = InliningMode.BLOCK;\n-        referenceAdded = maybeAddReferenceUsingMode(\n-            t, fs, callNode, module, mode);\n       }\n \n       if (!referenceAdded) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 504, 
          "faulty": "referenceAdded=maybeAddReferenceUsingMode(t,fs,callNode,module,mode);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 204, 
          "faulty": "if (li != null) {\n  String newName=getNameForId(li.id);\n  li.referenced=true;\n  if (!name.equals(newName)) {\n    nameNode.setString(newName);\n    compiler.reportCodeChange();\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_326/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:09:05.334955792 -0500\n@@ -727,9 +727,6 @@\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2178/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:28:06.007444318 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2178/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:28:06.007444318 -0500\n@@ -688,7 +688,6 @@\n     if (!inliningLowersCost(fs)) {\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n-        fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 691, 
          "faulty": "fs.setRemove(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_894/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:14:53.347733858 -0500\n@@ -203,8 +203,6 @@\n         LabelInfo li = getLabelInfo(name);\n         if (li != null) {\n           String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n           if (!name.equals(newName)) {\n             // Give it the short name.\n             nameNode.setString(newName);\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_894/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:14:53.347733858 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_894/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:14:53.347733858 -0500\n@@ -742,7 +742,6 @@\n   private void resolveInlineConflictsForFunction(FunctionState fs) {\n     // Functions that aren't referenced don't cause conflicts.\n     if (!fs.hasReferences() || !fs.canInline()) {\n-      return;\n     }\n \n     Node fnNode = fs.getFn().getFunctionNode();\n@@ -756,8 +755,6 @@\n           // For functions that can no longer be removed, check if they should\n           // still be inlined.\n           if (!mimimizeCost(fsCalled)) {\n-            // It can't be inlined remove it from the list.\n-            fsCalled.setInline(false);\n           }\n         }\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 207, 
          "faulty": "li.referenced=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 745, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 760, 
          "faulty": "fsCalled.setInline(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3053/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:36:43.659226705 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_541/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:11:34.136975577 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:57:38.329845888 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_541/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:11:34.140975631 -0500\n@@ -1456,7 +1456,8 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        sourcePosition = -1;\n+\t\treturn res;\n       }\n     }\n     return res;\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_541/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:11:34.140975631 -0500\n@@ -756,8 +756,6 @@\n           // For functions that can no longer be removed, check if they should\n           // still be inlined.\n           if (!mimimizeCost(fsCalled)) {\n-            // It can't be inlined remove it from the list.\n-            fsCalled.setInline(false);\n           }\n         }\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 760, 
          "faulty": "fsCalled.setInline(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1459, 
          "faulty": "return res;", 
          "type": "InsertBefore", 
          "seed": "sourcePosition=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2375/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:30:11.097352423 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2375/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:30:11.097352423 -0500\n@@ -756,8 +756,6 @@\n           // For functions that can no longer be removed, check if they should\n           // still be inlined.\n           if (!mimimizeCost(fsCalled)) {\n-            // It can't be inlined remove it from the list.\n-            fsCalled.setInline(false);\n           }\n         }\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 760, 
          "faulty": "fsCalled.setInline(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2169/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:28:01.247374177 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_434/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:10:20.759973591 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3061/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:36:47.707286955 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3061/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:36:47.715287074 -0500\n@@ -883,12 +883,7 @@\n \n     void removeBlockInliningReferences() {\n       Iterator<Entry<Node, Reference>> i;\n-      for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n-        Entry<Node, Reference> entry = i.next();\n-        if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n-        }\n-      }\n+      this.module = null;\n     }\n \n     public boolean hasBlockInliningReferences() {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 886, 
          "faulty": "for (i=getReferencesInternal().entrySet().iterator(); i.hasNext(); ) {\n  Entry<Node,Reference> entry=i.next();\n  if (entry.getValue().mode == InliningMode.BLOCK) {\n    i.remove();\n  }\n}", 
          "type": "Replace", 
          "seed": "this.module=null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_945/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:15:25.252186350 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_945/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:15:25.256186409 -0500\n@@ -883,7 +883,8 @@\n \n     void removeBlockInliningReferences() {\n       Iterator<Entry<Node, Reference>> i;\n-      for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n+      this.module = null;\n+\tfor (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n         if (entry.getValue().mode == InliningMode.BLOCK) {\n           i.remove();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 886, 
          "faulty": "for (i=getReferencesInternal().entrySet().iterator(); i.hasNext(); ) {\n  Entry<Node,Reference> entry=i.next();\n  if (entry.getValue().mode == InliningMode.BLOCK) {\n    i.remove();\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "this.module=null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2524/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:31:40.226707416 -0500\n@@ -727,9 +727,6 @@\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:57:38.329845888 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_520/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:11:21.316799813 -0500\n@@ -1443,7 +1443,10 @@\n    */\n   NodeMismatch checkTreeEqualsImpl(Node node2) {\n     if (!isEquivalentTo(node2, false, false, false)) {\n-      return new NodeMismatch(this, node2);\n+      if (!isEquivalentTo(node2, false, false, false)) {\n+\t\t\treturn new NodeMismatch(this, node2);\n+\t\t}\n+\treturn new NodeMismatch(this, node2);\n     }\n \n     NodeMismatch res = null;\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_520/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:11:21.320799867 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1446, 
          "faulty": "return new NodeMismatch(this,node2);", 
          "type": "InsertBefore", 
          "seed": "if (!isEquivalentTo(node2,false,false,false)) {\n  return new NodeMismatch(this,node2);\n}"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_358/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:09:23.111194358 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_608/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:12:15.421543318 -0500\n@@ -196,22 +196,6 @@\n      */\n     private void visitBreakOrContinue(Node node) {\n       Node nameNode = node.getFirstChild();\n-      if (nameNode != null) {\n-        // This is a named break or continue;\n-        String name = nameNode.getString();\n-        Preconditions.checkState(name.length() != 0);\n-        LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n-      }\n     }\n \n     /**\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_608/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:12:15.421543318 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_608/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:12:15.421543318 -0500\n@@ -756,8 +756,6 @@\n           // For functions that can no longer be removed, check if they should\n           // still be inlined.\n           if (!mimimizeCost(fsCalled)) {\n-            // It can't be inlined remove it from the list.\n-            fsCalled.setInline(false);\n           }\n         }\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 199, 
          "faulty": "if (nameNode != null) {\n  String name=nameNode.getString();\n  Preconditions.checkState(name.length() != 0);\n  LabelInfo li=getLabelInfo(name);\n  if (li != null) {\n    String newName=getNameForId(li.id);\n    li.referenced=true;\n    if (!name.equals(newName)) {\n      nameNode.setString(newName);\n      compiler.reportCodeChange();\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 760, 
          "faulty": "fsCalled.setInline(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_234/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:08:03.602134809 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2931/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:35:29.374116479 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionToBlockMutator.java\t2018-12-01 08:57:38.101845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2931/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionToBlockMutator.java\t2018-12-01 09:35:29.374116479 -0500\n@@ -198,7 +198,7 @@\n \n     @Override\n     public String get() {\n-        return \"JSCompiler_inline_label_\" + idSupplier.get();\n+        return null;\n     }\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionToBlockMutator.java", 
          "line": 201, 
          "faulty": "return \"JSCompiler_inline_label_\" + idSupplier.get();", 
          "type": "Replace", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1403/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:19:46.743973943 -0500\n@@ -205,11 +205,6 @@\n           String newName = getNameForId(li.id);\n           // Mark the label as referenced so it isn't removed.\n           li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n         }\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1403/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:19:46.743973943 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1403/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:19:46.747974001 -0500\n@@ -501,8 +501,6 @@\n         // This reference can not be directly inlined, see if\n         // block replacement inlining is possible.\n         mode = InliningMode.BLOCK;\n-        referenceAdded = maybeAddReferenceUsingMode(\n-            t, fs, callNode, module, mode);\n       }\n \n       if (!referenceAdded) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 504, 
          "faulty": "referenceAdded=maybeAddReferenceUsingMode(t,fs,callNode,module,mode);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 208, 
          "faulty": "if (!name.equals(newName)) {\n  nameNode.setString(newName);\n  compiler.reportCodeChange();\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_456/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:10:31.608121072 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionToBlockMutator.java\t2018-12-01 08:57:38.101845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_456/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionToBlockMutator.java\t2018-12-01 09:10:31.612121127 -0500\n@@ -198,7 +198,7 @@\n \n     @Override\n     public String get() {\n-        return \"JSCompiler_inline_label_\" + idSupplier.get();\n+        return null;\n     }\n   }\n \n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_456/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:10:31.612121127 -0500\n@@ -498,9 +498,6 @@\n           t, fs, callNode, module, mode);\n       if (!referenceAdded &&\n           mode == InliningMode.DIRECT && blockFunctionInliningEnabled) {\n-        // This reference can not be directly inlined, see if\n-        // block replacement inlining is possible.\n-        mode = InliningMode.BLOCK;\n         referenceAdded = maybeAddReferenceUsingMode(\n             t, fs, callNode, module, mode);\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 503, 
          "faulty": "mode=InliningMode.BLOCK;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionToBlockMutator.java", 
          "line": 201, 
          "faulty": "return \"JSCompiler_inline_label_\" + idSupplier.get();", 
          "type": "Replace", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2026/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:26:30.754033366 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3310/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:39:16.125482516 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2717/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:33:24.360266570 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 731, 
          "faulty": "return CanInlineResult.NO;", 
          "type": "Replace", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1964/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:25:56.941528119 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\t2018-12-01 08:57:38.101845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1964/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\t2018-12-01 09:25:56.941528119 -0500\n@@ -63,10 +63,6 @@\n     if (node.isName()) {\n       Node replacementTemplate = replacements.get(node.getString());\n       if (replacementTemplate != null) {\n-        // This should not be replacing declared names.\n-        Preconditions.checkState(!parent.isFunction()\n-            || !parent.isVar()\n-            || !parent.isCatch());\n         // The name may need to be replaced more than once,\n         // so we need to clone the node.\n         Node replacement = replacementTemplate.cloneTree();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionArgumentInjector.java", 
          "line": 67, 
          "faulty": "Preconditions.checkState(!parent.isFunction() || !parent.isVar() || !parent.isCatch());", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2333/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:29:36.860825226 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1617/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:22:22.486238118 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3187/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:37:59.948358570 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2837/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:34:33.829296544 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2312/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:29:25.424648139 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3203/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:38:08.712488163 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3203/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:38:08.716488222 -0500\n@@ -689,7 +689,6 @@\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n         fs.setRemove(false);\n-        fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n         }\n@@ -742,7 +741,6 @@\n   private void resolveInlineConflictsForFunction(FunctionState fs) {\n     // Functions that aren't referenced don't cause conflicts.\n     if (!fs.hasReferences() || !fs.canInline()) {\n-      return;\n     }\n \n     Node fnNode = fs.getFn().getFunctionNode();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 745, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 692, 
          "faulty": "fs.removeBlockInliningReferences();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_859/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:14:34.951477487 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3124/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:37:22.103797993 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:57:38.329845888 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3124/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:37:22.103797993 -0500\n@@ -1427,11 +1427,7 @@\n   public String checkTreeEquals(Node node2) {\n       NodeMismatch diff = checkTreeEqualsImpl(node2);\n       if (diff != null) {\n-        return \"Node tree inequality:\" +\n-            \"\\nTree1:\\n\" + toStringTree() +\n-            \"\\n\\nTree2:\\n\" + node2.toStringTree() +\n-            \"\\n\\nSubtree1: \" + diff.nodeA.toStringTree() +\n-            \"\\n\\nSubtree2: \" + diff.nodeB.toStringTree();\n+        return \"EMPTY\";\n       }\n       return null;\n   }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1430, 
          "faulty": "return \"Node tree inequality:\" + \"\\nTree1:\\n\" + toStringTree() + \"\\n\\nTree2:\\n\"+ node2.toStringTree()+ \"\\n\\nSubtree1: \"+ diff.nodeA.toStringTree()+ \"\\n\\nSubtree2: \"+ diff.nodeB.toStringTree();", 
          "type": "Replace", 
          "seed": "return \"EMPTY\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2588/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:32:13.727211386 -0500\n@@ -196,22 +196,6 @@\n      */\n     private void visitBreakOrContinue(Node node) {\n       Node nameNode = node.getFirstChild();\n-      if (nameNode != null) {\n-        // This is a named break or continue;\n-        String name = nameNode.getString();\n-        Preconditions.checkState(name.length() != 0);\n-        LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n-      }\n     }\n \n     /**\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2588/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:32:13.727211386 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 199, 
          "faulty": "if (nameNode != null) {\n  String name=nameNode.getString();\n  Preconditions.checkState(name.length() != 0);\n  LabelInfo li=getLabelInfo(name);\n  if (li != null) {\n    String newName=getNameForId(li.id);\n    li.referenced=true;\n    if (!name.equals(newName)) {\n      nameNode.setString(newName);\n      compiler.reportCodeChange();\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2317/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:29:28.268692227 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 731, 
          "faulty": "return CanInlineResult.NO;", 
          "type": "Replace", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1500/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:21:05.357100995 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 731, 
          "faulty": "return CanInlineResult.NO;", 
          "type": "Replace", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1023/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:16:07.140798885 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_968/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:15:37.148360612 -0500\n@@ -199,7 +199,6 @@\n       if (nameNode != null) {\n         // This is a named break or continue;\n         String name = nameNode.getString();\n-        Preconditions.checkState(name.length() != 0);\n         LabelInfo li = getLabelInfo(name);\n         if (li != null) {\n           String newName = getNameForId(li.id);\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_968/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:15:37.152360670 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 202, 
          "faulty": "Preconditions.checkState(name.length() != 0);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2680/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:32:59.859901583 -0500\n@@ -185,7 +185,7 @@\n \n         case Token.BREAK:\n         case Token.CONTINUE:\n-          visitBreakOrContinue(node);\n+          ;\n           break;\n       }\n     }\n@@ -203,8 +203,6 @@\n         LabelInfo li = getLabelInfo(name);\n         if (li != null) {\n           String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n           if (!name.equals(newName)) {\n             // Give it the short name.\n             nameNode.setString(newName);\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2680/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:32:59.859901583 -0500\n@@ -727,9 +727,6 @@\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 188, 
          "faulty": "visitBreakOrContinue(node);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 207, 
          "faulty": "li.referenced=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1955/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:25:52.193456952 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1955/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:25:52.193456952 -0500\n@@ -885,9 +885,7 @@\n       Iterator<Entry<Node, Reference>> i;\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n-        if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n-        }\n+        this.module = null;\n       }\n     }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 888, 
          "faulty": "if (entry.getValue().mode == InliningMode.BLOCK) {\n  i.remove();\n}", 
          "type": "Replace", 
          "seed": "this.module=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1624/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:22:26.306298490 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2621/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:32:30.991470161 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2621/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:32:30.991470161 -0500\n@@ -690,9 +690,6 @@\n       if (fs.hasBlockInliningReferences()) {\n         fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n-        if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n-          return false;\n-        }\n       } else {\n         return false;\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 693, 
          "faulty": "if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2212/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:28:33.559849665 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_931/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:15:18.304084451 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2817/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:34:16.697043146 -0500\n@@ -199,7 +199,6 @@\n       if (nameNode != null) {\n         // This is a named break or continue;\n         String name = nameNode.getString();\n-        Preconditions.checkState(name.length() != 0);\n         LabelInfo li = getLabelInfo(name);\n         if (li != null) {\n           String newName = getNameForId(li.id);\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2817/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:34:16.697043146 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2817/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:34:16.701043206 -0500\n@@ -886,7 +886,8 @@\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n         if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n+          this.module = null;\n+\t\ti.remove();\n         }\n       }\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 202, 
          "faulty": "Preconditions.checkState(name.length() != 0);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 889, 
          "faulty": "i.remove();", 
          "type": "InsertBefore", 
          "seed": "this.module=null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_986/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:15:46.900503282 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1000/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:15:54.608615935 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1000/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:15:54.612615993 -0500\n@@ -688,7 +688,6 @@\n     if (!inliningLowersCost(fs)) {\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n-        fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 691, 
          "faulty": "fs.setRemove(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3320/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:39:20.917553051 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3320/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:39:20.917553051 -0500\n@@ -742,7 +742,6 @@\n   private void resolveInlineConflictsForFunction(FunctionState fs) {\n     // Functions that aren't referenced don't cause conflicts.\n     if (!fs.hasReferences() || !fs.canInline()) {\n-      return;\n     }\n \n     Node fnNode = fs.getFn().getFunctionNode();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 745, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1902/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:25:24.029033601 -0500\n@@ -199,7 +199,6 @@\n       if (nameNode != null) {\n         // This is a named break or continue;\n         String name = nameNode.getString();\n-        Preconditions.checkState(name.length() != 0);\n         LabelInfo li = getLabelInfo(name);\n         if (li != null) {\n           String newName = getNameForId(li.id);\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1902/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:25:24.033033662 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\t2018-12-01 08:57:38.101845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1902/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\t2018-12-01 09:25:24.033033662 -0500\n@@ -63,10 +63,6 @@\n     if (node.isName()) {\n       Node replacementTemplate = replacements.get(node.getString());\n       if (replacementTemplate != null) {\n-        // This should not be replacing declared names.\n-        Preconditions.checkState(!parent.isFunction()\n-            || !parent.isVar()\n-            || !parent.isCatch());\n         // The name may need to be replaced more than once,\n         // so we need to clone the node.\n         Node replacement = replacementTemplate.cloneTree();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 202, 
          "faulty": "Preconditions.checkState(name.length() != 0);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionArgumentInjector.java", 
          "line": 67, 
          "faulty": "Preconditions.checkState(!parent.isFunction() || !parent.isVar() || !parent.isCatch());", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_729/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:13:25.478511900 -0500\n@@ -201,16 +201,6 @@\n         String name = nameNode.getString();\n         Preconditions.checkState(name.length() != 0);\n         LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n       }\n     }\n \n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_729/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:13:25.478511900 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 210, 
          "faulty": "nameNode.setString(newName);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 204, 
          "faulty": "if (li != null) {\n  String newName=getNameForId(li.id);\n  li.referenced=true;\n  if (!name.equals(newName)) {\n    nameNode.setString(newName);\n    compiler.reportCodeChange();\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1894/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:25:20.200975893 -0500\n@@ -185,7 +185,7 @@\n \n         case Token.BREAK:\n         case Token.CONTINUE:\n-          visitBreakOrContinue(node);\n+          ;\n           break;\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1894/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:25:20.200975893 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 188, 
          "faulty": "visitBreakOrContinue(node);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2916/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:35:15.177906694 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2887/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:34:59.901681497 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_498/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:11:04.308567062 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1025/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:16:08.116813123 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1025/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:16:08.116813123 -0500\n@@ -501,8 +501,6 @@\n         // This reference can not be directly inlined, see if\n         // block replacement inlining is possible.\n         mode = InliningMode.BLOCK;\n-        referenceAdded = maybeAddReferenceUsingMode(\n-            t, fs, callNode, module, mode);\n       }\n \n       if (!referenceAdded) {\n@@ -886,7 +884,6 @@\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n         if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n         }\n       }\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 504, 
          "faulty": "referenceAdded=maybeAddReferenceUsingMode(t,fs,callNode,module,mode);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 889, 
          "faulty": "i.remove();", 
          "type": "Delete", 
          "seed": "this.module=null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2903/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:35:08.461807717 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3326/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:39:23.821595787 -0500\n@@ -196,22 +196,6 @@\n      */\n     private void visitBreakOrContinue(Node node) {\n       Node nameNode = node.getFirstChild();\n-      if (nameNode != null) {\n-        // This is a named break or continue;\n-        String name = nameNode.getString();\n-        Preconditions.checkState(name.length() != 0);\n-        LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n-      }\n     }\n \n     /**\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3326/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:39:23.825595846 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 08:57:38.089845892 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3326/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 09:39:23.825595846 -0500\n@@ -106,7 +106,6 @@\n \n   void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n-      return;\n     }\n \n     int type = n.getType();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CodeGenerator.java", 
          "line": 109, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 199, 
          "faulty": "if (nameNode != null) {\n  String name=nameNode.getString();\n  Preconditions.checkState(name.length() != 0);\n  LabelInfo li=getLabelInfo(name);\n  if (li != null) {\n    String newName=getNameForId(li.id);\n    li.referenced=true;\n    if (!name.equals(newName)) {\n      nameNode.setString(newName);\n      compiler.reportCodeChange();\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_667/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:12:53.286066093 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_667/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:12:53.286066093 -0500\n@@ -688,7 +688,6 @@\n     if (!inliningLowersCost(fs)) {\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n-        fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 691, 
          "faulty": "fs.setRemove(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1993/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:26:13.417774648 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_297/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:08:47.670719630 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_297/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:08:47.670719630 -0500\n@@ -886,7 +886,8 @@\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n         if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n+          this.module = null;\n+\t\ti.remove();\n         }\n       }\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 889, 
          "faulty": "i.remove();", 
          "type": "InsertBefore", 
          "seed": "this.module=null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_665/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:12:52.302052485 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_665/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:12:52.306052540 -0500\n@@ -688,7 +688,6 @@\n     if (!inliningLowersCost(fs)) {\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n-        fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 691, 
          "faulty": "fs.setRemove(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1908/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:25:26.937077413 -0500\n@@ -196,22 +196,6 @@\n      */\n     private void visitBreakOrContinue(Node node) {\n       Node nameNode = node.getFirstChild();\n-      if (nameNode != null) {\n-        // This is a named break or continue;\n-        String name = nameNode.getString();\n-        Preconditions.checkState(name.length() != 0);\n-        LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n-      }\n     }\n \n     /**\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1908/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:25:26.937077413 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1908/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:25:26.937077413 -0500\n@@ -498,9 +498,6 @@\n           t, fs, callNode, module, mode);\n       if (!referenceAdded &&\n           mode == InliningMode.DIRECT && blockFunctionInliningEnabled) {\n-        // This reference can not be directly inlined, see if\n-        // block replacement inlining is possible.\n-        mode = InliningMode.BLOCK;\n         referenceAdded = maybeAddReferenceUsingMode(\n             t, fs, callNode, module, mode);\n       }\n@@ -689,7 +686,6 @@\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n         fs.setRemove(false);\n-        fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n         }\n@@ -885,9 +881,6 @@\n       Iterator<Entry<Node, Reference>> i;\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n-        if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n-        }\n       }\n     }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 888, 
          "faulty": "if (entry.getValue().mode == InliningMode.BLOCK) {\n  i.remove();\n}", 
          "type": "Delete", 
          "seed": "this.module=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 503, 
          "faulty": "mode=InliningMode.BLOCK;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 199, 
          "faulty": "if (nameNode != null) {\n  String name=nameNode.getString();\n  Preconditions.checkState(name.length() != 0);\n  LabelInfo li=getLabelInfo(name);\n  if (li != null) {\n    String newName=getNameForId(li.id);\n    li.referenced=true;\n    if (!name.equals(newName)) {\n      nameNode.setString(newName);\n      compiler.reportCodeChange();\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 692, 
          "faulty": "fs.removeBlockInliningReferences();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1582/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:21:58.993868188 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_738/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:13:30.262578246 -0500\n@@ -185,7 +185,7 @@\n \n         case Token.BREAK:\n         case Token.CONTINUE:\n-          visitBreakOrContinue(node);\n+          ;\n           break;\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_738/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:13:30.266578302 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 188, 
          "faulty": "visitBreakOrContinue(node);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1015/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:16:02.356729075 -0500\n@@ -205,11 +205,6 @@\n           String newName = getNameForId(li.id);\n           // Mark the label as referenced so it isn't removed.\n           li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n         }\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1015/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:16:02.356729075 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1015/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:16:02.356729075 -0500\n@@ -501,8 +501,6 @@\n         // This reference can not be directly inlined, see if\n         // block replacement inlining is possible.\n         mode = InliningMode.BLOCK;\n-        referenceAdded = maybeAddReferenceUsingMode(\n-            t, fs, callNode, module, mode);\n       }\n \n       if (!referenceAdded) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 504, 
          "faulty": "referenceAdded=maybeAddReferenceUsingMode(t,fs,callNode,module,mode);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 208, 
          "faulty": "if (!name.equals(newName)) {\n  nameNode.setString(newName);\n  compiler.reportCodeChange();\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2937/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:35:32.230159342 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2937/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:35:32.230159342 -0500\n@@ -883,12 +883,7 @@\n \n     void removeBlockInliningReferences() {\n       Iterator<Entry<Node, Reference>> i;\n-      for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n-        Entry<Node, Reference> entry = i.next();\n-        if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n-        }\n-      }\n+      this.module = null;\n     }\n \n     public boolean hasBlockInliningReferences() {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 886, 
          "faulty": "for (i=getReferencesInternal().entrySet().iterator(); i.hasNext(); ) {\n  Entry<Node,Reference> entry=i.next();\n  if (entry.getValue().mode == InliningMode.BLOCK) {\n    i.remove();\n  }\n}", 
          "type": "Replace", 
          "seed": "this.module=null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2220/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:28:37.395906017 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2664/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:32:52.143786420 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2664/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:32:52.143786420 -0500\n@@ -498,9 +498,6 @@\n           t, fs, callNode, module, mode);\n       if (!referenceAdded &&\n           mode == InliningMode.DIRECT && blockFunctionInliningEnabled) {\n-        // This reference can not be directly inlined, see if\n-        // block replacement inlining is possible.\n-        mode = InliningMode.BLOCK;\n         referenceAdded = maybeAddReferenceUsingMode(\n             t, fs, callNode, module, mode);\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 503, 
          "faulty": "mode=InliningMode.BLOCK;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1497/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:20:58.341000543 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1550/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:21:31.089469214 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:57:38.329845888 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_187/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:07:26.541648468 -0500\n@@ -1427,11 +1427,7 @@\n   public String checkTreeEquals(Node node2) {\n       NodeMismatch diff = checkTreeEqualsImpl(node2);\n       if (diff != null) {\n-        return \"Node tree inequality:\" +\n-            \"\\nTree1:\\n\" + toStringTree() +\n-            \"\\n\\nTree2:\\n\" + node2.toStringTree() +\n-            \"\\n\\nSubtree1: \" + diff.nodeA.toStringTree() +\n-            \"\\n\\nSubtree2: \" + diff.nodeB.toStringTree();\n+        return \"RETURN\";\n       }\n       return null;\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_187/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:07:26.545648519 -0500\n@@ -728,7 +728,6 @@\n       if (fnParam != null) {\n         if (cArg != null) {\n           if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n           }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_187/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:07:26.545648519 -0500\n@@ -884,7 +884,8 @@\n     void removeBlockInliningReferences() {\n       Iterator<Entry<Node, Reference>> i;\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n-        Entry<Node, Reference> entry = i.next();\n+        this.module = null;\n+\t\tEntry<Node, Reference> entry = i.next();\n         if (entry.getValue().mode == InliningMode.BLOCK) {\n           i.remove();\n         }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 887, 
          "faulty": "Entry<Node,Reference> entry=i.next();", 
          "type": "InsertBefore", 
          "seed": "this.module=null;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1430, 
          "faulty": "return \"Node tree inequality:\" + \"\\nTree1:\\n\" + toStringTree() + \"\\n\\nTree2:\\n\"+ node2.toStringTree()+ \"\\n\\nSubtree1: \"+ diff.nodeA.toStringTree()+ \"\\n\\nSubtree2: \"+ diff.nodeB.toStringTree();", 
          "type": "Replace", 
          "seed": "return \"RETURN\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 731, 
          "faulty": "return CanInlineResult.NO;", 
          "type": "Delete", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2503/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:31:29.746549219 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2784/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:33:58.300770626 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_571/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:11:55.797273132 -0500\n@@ -727,9 +727,6 @@\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_571/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:11:55.801273186 -0500\n@@ -498,9 +498,6 @@\n           t, fs, callNode, module, mode);\n       if (!referenceAdded &&\n           mode == InliningMode.DIRECT && blockFunctionInliningEnabled) {\n-        // This reference can not be directly inlined, see if\n-        // block replacement inlining is possible.\n-        mode = InliningMode.BLOCK;\n         referenceAdded = maybeAddReferenceUsingMode(\n             t, fs, callNode, module, mode);\n       }\n@@ -886,7 +883,6 @@\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n         if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n         }\n       }\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 503, 
          "faulty": "mode=InliningMode.BLOCK;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 889, 
          "faulty": "i.remove();", 
          "type": "Delete", 
          "seed": "this.module=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2058/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:26:48.046290776 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2058/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:26:48.046290776 -0500\n@@ -498,9 +498,6 @@\n           t, fs, callNode, module, mode);\n       if (!referenceAdded &&\n           mode == InliningMode.DIRECT && blockFunctionInliningEnabled) {\n-        // This reference can not be directly inlined, see if\n-        // block replacement inlining is possible.\n-        mode = InliningMode.BLOCK;\n         referenceAdded = maybeAddReferenceUsingMode(\n             t, fs, callNode, module, mode);\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 503, 
          "faulty": "mode=InliningMode.BLOCK;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2319/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:29:29.244707350 -0500\n@@ -185,7 +185,7 @@\n \n         case Token.BREAK:\n         case Token.CONTINUE:\n-          visitBreakOrContinue(node);\n+          ;\n           break;\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2319/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:29:29.248707412 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 188, 
          "faulty": "visitBreakOrContinue(node);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1203/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:17:51.022307031 -0500\n@@ -727,9 +727,6 @@\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:57:38.329845888 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1203/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:17:51.026307088 -0500\n@@ -1456,7 +1456,8 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        sourcePosition = -1;\n+\t\treturn res;\n       }\n     }\n     return res;\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1203/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:17:51.026307088 -0500\n@@ -886,7 +886,8 @@\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n         if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n+          this.module = null;\n+\t\ti.remove();\n         }\n       }\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 889, 
          "faulty": "i.remove();", 
          "type": "InsertBefore", 
          "seed": "this.module=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1459, 
          "faulty": "return res;", 
          "type": "InsertBefore", 
          "seed": "sourcePosition=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_717/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:13:19.562429888 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_717/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:13:19.562429888 -0500\n@@ -688,7 +688,6 @@\n     if (!inliningLowersCost(fs)) {\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n-        fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 691, 
          "faulty": "fs.setRemove(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2000/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:26:17.313832850 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2000/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:26:17.317832910 -0500\n@@ -742,7 +742,6 @@\n   private void resolveInlineConflictsForFunction(FunctionState fs) {\n     // Functions that aren't referenced don't cause conflicts.\n     if (!fs.hasReferences() || !fs.canInline()) {\n-      return;\n     }\n \n     Node fnNode = fs.getFn().getFunctionNode();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 745, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2493/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:31:24.906476068 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2120/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:27:25.138840937 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2776/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:33:54.472713860 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1723/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:23:23.139187573 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1723/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:23:23.139187573 -0500\n@@ -885,9 +885,7 @@\n       Iterator<Entry<Node, Reference>> i;\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n-        if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n-        }\n+        this.module = null;\n       }\n     }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 888, 
          "faulty": "if (entry.getValue().mode == InliningMode.BLOCK) {\n  i.remove();\n}", 
          "type": "Replace", 
          "seed": "this.module=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2497/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:31:26.802504731 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1106/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:16:54.849493229 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2684/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:33:01.763929984 -0500\n@@ -203,8 +203,6 @@\n         LabelInfo li = getLabelInfo(name);\n         if (li != null) {\n           String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n           if (!name.equals(newName)) {\n             // Give it the short name.\n             nameNode.setString(newName);\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2684/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:33:01.767930044 -0500\n@@ -727,9 +727,6 @@\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 207, 
          "faulty": "li.referenced=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 731, 
          "faulty": "return CanInlineResult.NO;", 
          "type": "Replace", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2923/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:35:19.457969745 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_879/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:14:45.607625960 -0500\n@@ -201,16 +201,6 @@\n         String name = nameNode.getString();\n         Preconditions.checkState(name.length() != 0);\n         LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n       }\n     }\n \n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_879/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:14:45.607625960 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 08:57:38.089845892 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_879/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 09:14:45.607625960 -0500\n@@ -106,7 +106,6 @@\n \n   void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n-      return;\n     }\n \n     int type = n.getType();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CodeGenerator.java", 
          "line": 109, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 204, 
          "faulty": "if (li != null) {\n  String newName=getNameForId(li.id);\n  li.referenced=true;\n  if (!name.equals(newName)) {\n    nameNode.setString(newName);\n    compiler.reportCodeChange();\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1278/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:18:35.502949086 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1349/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:19:12.951488290 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1349/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:19:12.955488347 -0500\n@@ -501,8 +501,6 @@\n         // This reference can not be directly inlined, see if\n         // block replacement inlining is possible.\n         mode = InliningMode.BLOCK;\n-        referenceAdded = maybeAddReferenceUsingMode(\n-            t, fs, callNode, module, mode);\n       }\n \n       if (!referenceAdded) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 504, 
          "faulty": "referenceAdded=maybeAddReferenceUsingMode(t,fs,callNode,module,mode);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2858/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:34:44.461453621 -0500\n@@ -206,9 +206,6 @@\n           // Mark the label as referenced so it isn't removed.\n           li.referenced = true;\n           if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n           }\n         }\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2858/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:34:44.461453621 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2858/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:34:44.461453621 -0500\n@@ -689,7 +689,6 @@\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n         fs.setRemove(false);\n-        fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n         }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 210, 
          "faulty": "nameNode.setString(newName);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 211, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 692, 
          "faulty": "fs.removeBlockInliningReferences();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2326/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:29:33.072766627 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:57:38.329845888 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2326/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:29:33.076766689 -0500\n@@ -1456,7 +1456,8 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        sourcePosition = -1;\n+\t\treturn res;\n       }\n     }\n     return res;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1459, 
          "faulty": "return res;", 
          "type": "InsertBefore", 
          "seed": "sourcePosition=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:57:38.329845888 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3126/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:37:23.075812412 -0500\n@@ -1443,7 +1443,10 @@\n    */\n   NodeMismatch checkTreeEqualsImpl(Node node2) {\n     if (!isEquivalentTo(node2, false, false, false)) {\n-      return new NodeMismatch(this, node2);\n+      if (!isEquivalentTo(node2, false, false, false)) {\n+\t\t\treturn new NodeMismatch(this, node2);\n+\t\t}\n+\treturn new NodeMismatch(this, node2);\n     }\n \n     NodeMismatch res = null;\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3126/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:37:23.075812412 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1446, 
          "faulty": "return new NodeMismatch(this,node2);", 
          "type": "InsertBefore", 
          "seed": "if (!isEquivalentTo(node2,false,false,false)) {\n  return new NodeMismatch(this,node2);\n}"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1657/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:22:43.478568878 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3135/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:37:28.243889057 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_853/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:14:32.103437819 -0500\n@@ -203,8 +203,6 @@\n         LabelInfo li = getLabelInfo(name);\n         if (li != null) {\n           String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n           if (!name.equals(newName)) {\n             // Give it the short name.\n             nameNode.setString(newName);\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_853/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:14:32.103437819 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 207, 
          "faulty": "li.referenced=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_393/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:09:53.059598171 -0500\n@@ -208,7 +208,6 @@\n           if (!name.equals(newName)) {\n             // Give it the short name.\n             nameNode.setString(newName);\n-            compiler.reportCodeChange();\n           }\n         }\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_393/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:09:53.063598226 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\t2018-12-01 08:57:38.101845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_393/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\t2018-12-01 09:09:53.063598226 -0500\n@@ -63,10 +63,6 @@\n     if (node.isName()) {\n       Node replacementTemplate = replacements.get(node.getString());\n       if (replacementTemplate != null) {\n-        // This should not be replacing declared names.\n-        Preconditions.checkState(!parent.isFunction()\n-            || !parent.isVar()\n-            || !parent.isCatch());\n         // The name may need to be replaced more than once,\n         // so we need to clone the node.\n         Node replacement = replacementTemplate.cloneTree();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 211, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionArgumentInjector.java", 
          "line": 67, 
          "faulty": "Preconditions.checkState(!parent.isFunction() || !parent.isVar() || !parent.isCatch());", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3066/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:36:50.767332483 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1997/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:26:15.369803814 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2024/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:26:29.810019295 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2024/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:26:29.810019295 -0500\n@@ -756,8 +756,6 @@\n           // For functions that can no longer be removed, check if they should\n           // still be inlined.\n           if (!mimimizeCost(fsCalled)) {\n-            // It can't be inlined remove it from the list.\n-            fsCalled.setInline(false);\n           }\n         }\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 760, 
          "faulty": "fsCalled.setInline(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2133/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:27:37.931030094 -0500\n@@ -206,8 +206,6 @@\n           // Mark the label as referenced so it isn't removed.\n           li.referenced = true;\n           if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n             compiler.reportCodeChange();\n           }\n         }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2133/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:27:37.931030094 -0500\n@@ -727,9 +727,6 @@\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 210, 
          "faulty": "nameNode.setString(newName);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2499/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:31:27.750519059 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_813/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:14:10.951143423 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2819/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:34:17.693057889 -0500\n@@ -203,8 +203,6 @@\n         LabelInfo li = getLabelInfo(name);\n         if (li != null) {\n           String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n           if (!name.equals(newName)) {\n             // Give it the short name.\n             nameNode.setString(newName);\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2819/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:34:17.741058599 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2819/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:34:17.741058599 -0500\n@@ -688,7 +688,6 @@\n     if (!inliningLowersCost(fs)) {\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n-        fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 207, 
          "faulty": "li.referenced=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 691, 
          "faulty": "fs.setRemove(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2692/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:33:05.627987603 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionToBlockMutator.java\t2018-12-01 08:57:38.101845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2692/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionToBlockMutator.java\t2018-12-01 09:33:05.631987663 -0500\n@@ -198,7 +198,7 @@\n \n     @Override\n     public String get() {\n-        return \"JSCompiler_inline_label_\" + idSupplier.get();\n+        return null;\n     }\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionToBlockMutator.java", 
          "line": 201, 
          "faulty": "return \"JSCompiler_inline_label_\" + idSupplier.get();", 
          "type": "Replace", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2127/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:27:28.950897335 -0500\n@@ -185,7 +185,7 @@\n \n         case Token.BREAK:\n         case Token.CONTINUE:\n-          visitBreakOrContinue(node);\n+          ;\n           break;\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2127/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:27:28.950897335 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 188, 
          "faulty": "visitBreakOrContinue(node);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2411/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:30:35.409724349 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_311/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:08:55.662826365 -0500\n@@ -203,8 +203,6 @@\n         LabelInfo li = getLabelInfo(name);\n         if (li != null) {\n           String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n           if (!name.equals(newName)) {\n             // Give it the short name.\n             nameNode.setString(newName);\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_311/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:08:55.662826365 -0500\n@@ -727,9 +727,6 @@\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 207, 
          "faulty": "li.referenced=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2186/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:28:09.879501349 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\t2018-12-01 08:57:38.101845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2186/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\t2018-12-01 09:28:09.883501408 -0500\n@@ -63,10 +63,6 @@\n     if (node.isName()) {\n       Node replacementTemplate = replacements.get(node.getString());\n       if (replacementTemplate != null) {\n-        // This should not be replacing declared names.\n-        Preconditions.checkState(!parent.isFunction()\n-            || !parent.isVar()\n-            || !parent.isCatch());\n         // The name may need to be replaced more than once,\n         // so we need to clone the node.\n         Node replacement = replacementTemplate.cloneTree();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionArgumentInjector.java", 
          "line": 67, 
          "faulty": "Preconditions.checkState(!parent.isFunction() || !parent.isVar() || !parent.isCatch());", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2552/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:31:55.526937901 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2501/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:31:28.722533747 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2501/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:31:28.722533747 -0500\n@@ -689,7 +689,6 @@\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n         fs.setRemove(false);\n-        fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n         }\n@@ -886,7 +885,8 @@\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n         if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n+          this.module = null;\n+\t\ti.remove();\n         }\n       }\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 889, 
          "faulty": "i.remove();", 
          "type": "InsertBefore", 
          "seed": "this.module=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 692, 
          "faulty": "fs.removeBlockInliningReferences();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2569/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:32:04.147067520 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2569/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:32:04.147067520 -0500\n@@ -690,9 +690,6 @@\n       if (fs.hasBlockInliningReferences()) {\n         fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n-        if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n-          return false;\n-        }\n       } else {\n         return false;\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 693, 
          "faulty": "if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_927/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:15:10.379971444 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_270/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:08:26.030431632 -0500\n@@ -201,16 +201,6 @@\n         String name = nameNode.getString();\n         Preconditions.checkState(name.length() != 0);\n         LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n       }\n     }\n \n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_270/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:08:26.030431632 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 204, 
          "faulty": "if (li != null) {\n  String newName=getNameForId(li.id);\n  li.referenced=true;\n  if (!name.equals(newName)) {\n    nameNode.setString(newName);\n    compiler.reportCodeChange();\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2831/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:34:24.837163591 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2831/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:34:24.841163650 -0500\n@@ -886,7 +886,8 @@\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n         if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n+          this.module = null;\n+\t\ti.remove();\n         }\n       }\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 889, 
          "faulty": "i.remove();", 
          "type": "InsertBefore", 
          "seed": "this.module=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1930/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:25:38.313248577 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1983/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:26:07.641688297 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1983/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:26:07.641688297 -0500\n@@ -498,9 +498,6 @@\n           t, fs, callNode, module, mode);\n       if (!referenceAdded &&\n           mode == InliningMode.DIRECT && blockFunctionInliningEnabled) {\n-        // This reference can not be directly inlined, see if\n-        // block replacement inlining is possible.\n-        mode = InliningMode.BLOCK;\n         referenceAdded = maybeAddReferenceUsingMode(\n             t, fs, callNode, module, mode);\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 503, 
          "faulty": "mode=InliningMode.BLOCK;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_366/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:09:33.151329480 -0500\n@@ -201,16 +201,6 @@\n         String name = nameNode.getString();\n         Preconditions.checkState(name.length() != 0);\n         LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n       }\n     }\n \n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_366/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:09:33.155329534 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_366/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:09:33.155329534 -0500\n@@ -498,9 +498,6 @@\n           t, fs, callNode, module, mode);\n       if (!referenceAdded &&\n           mode == InliningMode.DIRECT && blockFunctionInliningEnabled) {\n-        // This reference can not be directly inlined, see if\n-        // block replacement inlining is possible.\n-        mode = InliningMode.BLOCK;\n         referenceAdded = maybeAddReferenceUsingMode(\n             t, fs, callNode, module, mode);\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 503, 
          "faulty": "mode=InliningMode.BLOCK;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 204, 
          "faulty": "if (li != null) {\n  String newName=getNameForId(li.id);\n  li.referenced=true;\n  if (!name.equals(newName)) {\n    nameNode.setString(newName);\n    compiler.reportCodeChange();\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:57:38.329845888 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_865/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:14:37.931518999 -0500\n@@ -1443,7 +1443,10 @@\n    */\n   NodeMismatch checkTreeEqualsImpl(Node node2) {\n     if (!isEquivalentTo(node2, false, false, false)) {\n-      return new NodeMismatch(this, node2);\n+      if (!isEquivalentTo(node2, false, false, false)) {\n+\t\t\treturn new NodeMismatch(this, node2);\n+\t\t}\n+\treturn new NodeMismatch(this, node2);\n     }\n \n     NodeMismatch res = null;\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_865/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:14:37.931518999 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_865/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:14:37.931518999 -0500\n@@ -691,7 +691,6 @@\n         fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n-          return false;\n         }\n       } else {\n         return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1446, 
          "faulty": "return new NodeMismatch(this,node2);", 
          "type": "InsertBefore", 
          "seed": "if (!isEquivalentTo(node2,false,false,false)) {\n  return new NodeMismatch(this,node2);\n}"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 694, 
          "faulty": "return false;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3143/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:37:32.151946995 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2648/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:32:44.407670851 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2648/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:32:44.407670851 -0500\n@@ -883,12 +883,6 @@\n \n     void removeBlockInliningReferences() {\n       Iterator<Entry<Node, Reference>> i;\n-      for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n-        Entry<Node, Reference> entry = i.next();\n-        if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n-        }\n-      }\n     }\n \n     public boolean hasBlockInliningReferences() {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 886, 
          "faulty": "for (i=getReferencesInternal().entrySet().iterator(); i.hasNext(); ) {\n  Entry<Node,Reference> entry=i.next();\n  if (entry.getValue().mode == InliningMode.BLOCK) {\n    i.remove();\n  }\n}", 
          "type": "Delete", 
          "seed": "this.module=null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3151/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:37:37.012019021 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_632/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:12:34.409805250 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_632/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:12:34.413805306 -0500\n@@ -689,7 +689,6 @@\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n         fs.setRemove(false);\n-        fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n         }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 692, 
          "faulty": "fs.removeBlockInliningReferences();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3289/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:38:59.321235028 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2109/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:27:19.346755196 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2109/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:27:19.350755256 -0500\n@@ -742,7 +742,6 @@\n   private void resolveInlineConflictsForFunction(FunctionState fs) {\n     // Functions that aren't referenced don't cause conflicts.\n     if (!fs.hasReferences() || !fs.canInline()) {\n-      return;\n     }\n \n     Node fnNode = fs.getFn().getFunctionNode();\n@@ -885,9 +884,7 @@\n       Iterator<Entry<Node, Reference>> i;\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n-        if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n-        }\n+        this.module = null;\n       }\n     }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 888, 
          "faulty": "if (entry.getValue().mode == InliningMode.BLOCK) {\n  i.remove();\n}", 
          "type": "Replace", 
          "seed": "this.module=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 745, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1700/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:23:11.603008396 -0500\n@@ -728,7 +728,7 @@\n       if (fnParam != null) {\n         if (cArg != null) {\n           if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n+            return null;\n           }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1700/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:23:11.607008458 -0500\n@@ -689,7 +689,6 @@\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n         fs.setRemove(false);\n-        fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n         }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 731, 
          "faulty": "return CanInlineResult.NO;", 
          "type": "Replace", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 692, 
          "faulty": "fs.removeBlockInliningReferences();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_407/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:10:00.019692336 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_407/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:10:00.019692336 -0500\n@@ -883,11 +883,9 @@\n \n     void removeBlockInliningReferences() {\n       Iterator<Entry<Node, Reference>> i;\n-      for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n+      this.module = null;\n+\tfor (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n-        if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n-        }\n       }\n     }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 888, 
          "faulty": "if (entry.getValue().mode == InliningMode.BLOCK) {\n  i.remove();\n}", 
          "type": "Delete", 
          "seed": "this.module=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 886, 
          "faulty": "for (i=getReferencesInternal().entrySet().iterator(); i.hasNext(); ) {\n  Entry<Node,Reference> entry=i.next();\n  if (entry.getValue().mode == InliningMode.BLOCK) {\n    i.remove();\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "this.module=null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2089/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:27:03.654522596 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1599/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:22:12.866085710 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1648/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:22:38.646492956 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2641/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:32:40.539613025 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2641/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:32:40.543613085 -0500\n@@ -501,8 +501,6 @@\n         // This reference can not be directly inlined, see if\n         // block replacement inlining is possible.\n         mode = InliningMode.BLOCK;\n-        referenceAdded = maybeAddReferenceUsingMode(\n-            t, fs, callNode, module, mode);\n       }\n \n       if (!referenceAdded) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 504, 
          "faulty": "referenceAdded=maybeAddReferenceUsingMode(t,fs,callNode,module,mode);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3278/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:38:53.581150435 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3278/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:38:53.581150435 -0500\n@@ -885,9 +885,6 @@\n       Iterator<Entry<Node, Reference>> i;\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n-        if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n-        }\n       }\n     }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 888, 
          "faulty": "if (entry.getValue().mode == InliningMode.BLOCK) {\n  i.remove();\n}", 
          "type": "Delete", 
          "seed": "this.module=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1517/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:21:13.925223635 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1517/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:21:13.925223635 -0500\n@@ -501,8 +501,6 @@\n         // This reference can not be directly inlined, see if\n         // block replacement inlining is possible.\n         mode = InliningMode.BLOCK;\n-        referenceAdded = maybeAddReferenceUsingMode(\n-            t, fs, callNode, module, mode);\n       }\n \n       if (!referenceAdded) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 504, 
          "faulty": "referenceAdded=maybeAddReferenceUsingMode(t,fs,callNode,module,mode);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2733/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:33:32.028380603 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2231/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:28:43.131990244 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2482/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:31:13.994310922 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_782/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:13:54.518914987 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1679/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:22:54.958748765 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1679/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:22:54.958748765 -0500\n@@ -688,7 +688,6 @@\n     if (!inliningLowersCost(fs)) {\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n-        fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 691, 
          "faulty": "fs.setRemove(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2741/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:33:36.344444748 -0500\n@@ -727,9 +727,6 @@\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_683/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:13:01.966186182 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 08:57:38.089845892 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_683/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 09:13:01.966186182 -0500\n@@ -106,7 +106,6 @@\n \n   void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n-      return;\n     }\n \n     int type = n.getType();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CodeGenerator.java", 
          "line": 109, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_916/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:15:04.371887612 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1756/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:23:51.631627585 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1199/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:17:49.066278752 -0500\n@@ -196,22 +196,6 @@\n      */\n     private void visitBreakOrContinue(Node node) {\n       Node nameNode = node.getFirstChild();\n-      if (nameNode != null) {\n-        // This is a named break or continue;\n-        String name = nameNode.getString();\n-        Preconditions.checkState(name.length() != 0);\n-        LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n-      }\n     }\n \n     /**\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1199/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:17:49.070278810 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 199, 
          "faulty": "if (nameNode != null) {\n  String name=nameNode.getString();\n  Preconditions.checkState(name.length() != 0);\n  LabelInfo li=getLabelInfo(name);\n  if (li != null) {\n    String newName=getNameForId(li.id);\n    li.referenced=true;\n    if (!name.equals(newName)) {\n      nameNode.setString(newName);\n      compiler.reportCodeChange();\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2291/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:29:14.836483710 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1078/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:16:41.369297362 -0500\n@@ -208,7 +208,6 @@\n           if (!name.equals(newName)) {\n             // Give it the short name.\n             nameNode.setString(newName);\n-            compiler.reportCodeChange();\n           }\n         }\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1078/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:16:41.373297421 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 211, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1883/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:25:14.444889040 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2196/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:28:14.679572018 -0500\n@@ -201,16 +201,6 @@\n         String name = nameNode.getString();\n         Preconditions.checkState(name.length() != 0);\n         LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n       }\n     }\n \n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2196/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:28:14.679572018 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 204, 
          "faulty": "if (li != null) {\n  String newName=getNameForId(li.id);\n  li.referenced=true;\n  if (!name.equals(newName)) {\n    nameNode.setString(newName);\n    compiler.reportCodeChange();\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_906/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:14:59.095814016 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2310/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:29:24.476633436 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2310/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:29:24.476633436 -0500\n@@ -756,8 +756,6 @@\n           // For functions that can no longer be removed, check if they should\n           // still be inlined.\n           if (!mimimizeCost(fsCalled)) {\n-            // It can't be inlined remove it from the list.\n-            fsCalled.setInline(false);\n           }\n         }\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 760, 
          "faulty": "fsCalled.setInline(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1120/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:17:02.629606166 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 731, 
          "faulty": "return CanInlineResult.NO;", 
          "type": "Delete", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:57:38.329845888 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1840/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:24:40.128369155 -0500\n@@ -1443,7 +1443,8 @@\n    */\n   NodeMismatch checkTreeEqualsImpl(Node node2) {\n     if (!isEquivalentTo(node2, false, false, false)) {\n-      return new NodeMismatch(this, node2);\n+      this.sourcePosition = sourcePosition;\n+\treturn new NodeMismatch(this, node2);\n     }\n \n     NodeMismatch res = null;\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1840/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:24:40.128369155 -0500\n@@ -727,9 +727,6 @@\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1446, 
          "faulty": "return new NodeMismatch(this,node2);", 
          "type": "InsertBefore", 
          "seed": "this.sourcePosition=sourcePosition;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_978/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:15:43.048446947 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_978/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:15:43.052447006 -0500\n@@ -756,8 +756,6 @@\n           // For functions that can no longer be removed, check if they should\n           // still be inlined.\n           if (!mimimizeCost(fsCalled)) {\n-            // It can't be inlined remove it from the list.\n-            fsCalled.setInline(false);\n           }\n         }\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 760, 
          "faulty": "fsCalled.setInline(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3181/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:37:57.092316320 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:57:38.329845888 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3181/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:37:57.092316320 -0500\n@@ -1456,7 +1456,10 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        if (!isEquivalentTo(node2, false, false, false)) {\n+\t\t\treturn new NodeMismatch(this, node2);\n+\t\t}\n+\t\treturn res;\n       }\n     }\n     return res;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1459, 
          "faulty": "return res;", 
          "type": "InsertBefore", 
          "seed": "if (!isEquivalentTo(node2,false,false,false)) {\n  return new NodeMismatch(this,node2);\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1721/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:23:22.179172685 -0500\n@@ -206,8 +206,6 @@\n           // Mark the label as referenced so it isn't removed.\n           li.referenced = true;\n           if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n             compiler.reportCodeChange();\n           }\n         }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1721/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:23:22.179172685 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 210, 
          "faulty": "nameNode.setString(newName);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1082/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:16:43.277325100 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1615/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:22:21.546223250 -0500\n@@ -185,7 +185,7 @@\n \n         case Token.BREAK:\n         case Token.CONTINUE:\n-          visitBreakOrContinue(node);\n+          ;\n           break;\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1615/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:22:21.546223250 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 188, 
          "faulty": "visitBreakOrContinue(node);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2165/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:27:59.339346052 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2188/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:28:10.831515368 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2198/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:28:15.663586501 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2198/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:28:15.663586501 -0500\n@@ -689,7 +689,6 @@\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n         fs.setRemove(false);\n-        fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n         }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 692, 
          "faulty": "fs.removeBlockInliningReferences();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3156/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:37:42.816105001 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_877/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:14:44.607612023 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_811/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:14:10.003130237 -0500\n@@ -727,9 +727,6 @@\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 08:57:38.089845892 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_811/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 09:14:10.003130237 -0500\n@@ -106,7 +106,6 @@\n \n   void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n-      return;\n     }\n \n     int type = n.getType();\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_811/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:14:10.007130292 -0500\n@@ -885,9 +885,7 @@\n       Iterator<Entry<Node, Reference>> i;\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n-        if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n-        }\n+        this.module = null;\n       }\n     }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 888, 
          "faulty": "if (entry.getValue().mode == InliningMode.BLOCK) {\n  i.remove();\n}", 
          "type": "Replace", 
          "seed": "this.module=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CodeGenerator.java", 
          "line": 109, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_339/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:09:13.251061921 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_339/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:09:13.255061975 -0500\n@@ -690,9 +690,6 @@\n       if (fs.hasBlockInliningReferences()) {\n         fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n-        if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n-          return false;\n-        }\n       } else {\n         return false;\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 693, 
          "faulty": "if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_824/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:14:16.735223888 -0500\n@@ -196,22 +196,6 @@\n      */\n     private void visitBreakOrContinue(Node node) {\n       Node nameNode = node.getFirstChild();\n-      if (nameNode != null) {\n-        // This is a named break or continue;\n-        String name = nameNode.getString();\n-        Preconditions.checkState(name.length() != 0);\n-        LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n-      }\n     }\n \n     /**\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_824/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:14:16.739223943 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 202, 
          "faulty": "Preconditions.checkState(name.length() != 0);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 208, 
          "faulty": "if (!name.equals(newName)) {\n  nameNode.setString(newName);\n  compiler.reportCodeChange();\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 199, 
          "faulty": "if (nameNode != null) {\n  String name=nameNode.getString();\n  Preconditions.checkState(name.length() != 0);\n  LabelInfo li=getLabelInfo(name);\n  if (li != null) {\n    String newName=getNameForId(li.id);\n    li.referenced=true;\n    if (!name.equals(newName)) {\n      nameNode.setString(newName);\n      compiler.reportCodeChange();\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_467/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:10:42.568270322 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1918/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:25:31.713149316 -0500\n@@ -185,7 +185,7 @@\n \n         case Token.BREAK:\n         case Token.CONTINUE:\n-          visitBreakOrContinue(node);\n+          ;\n           break;\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1918/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:25:31.713149316 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 188, 
          "faulty": "visitBreakOrContinue(node);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3104/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:37:11.375638768 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3104/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:37:11.379638828 -0500\n@@ -498,9 +498,6 @@\n           t, fs, callNode, module, mode);\n       if (!referenceAdded &&\n           mode == InliningMode.DIRECT && blockFunctionInliningEnabled) {\n-        // This reference can not be directly inlined, see if\n-        // block replacement inlining is possible.\n-        mode = InliningMode.BLOCK;\n         referenceAdded = maybeAddReferenceUsingMode(\n             t, fs, callNode, module, mode);\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 503, 
          "faulty": "mode=InliningMode.BLOCK;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1330/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:19:02.395336410 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2458/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:31:01.314118621 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1321/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:18:57.651268125 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_690/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:13:05.918240888 -0500\n@@ -199,7 +199,6 @@\n       if (nameNode != null) {\n         // This is a named break or continue;\n         String name = nameNode.getString();\n-        Preconditions.checkState(name.length() != 0);\n         LabelInfo li = getLabelInfo(name);\n         if (li != null) {\n           String newName = getNameForId(li.id);\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_690/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:13:05.922240944 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 202, 
          "faulty": "Preconditions.checkState(name.length() != 0);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1216/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:17:57.738404097 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1314/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:18:53.843213300 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1314/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:18:53.843213300 -0500\n@@ -886,7 +886,6 @@\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n         if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n         }\n       }\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 889, 
          "faulty": "i.remove();", 
          "type": "Delete", 
          "seed": "this.module=null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1063/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:16:33.669185371 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:57:38.329845888 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2083/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:27:00.634477779 -0500\n@@ -1443,7 +1443,8 @@\n    */\n   NodeMismatch checkTreeEqualsImpl(Node node2) {\n     if (!isEquivalentTo(node2, false, false, false)) {\n-      return new NodeMismatch(this, node2);\n+      sourcePosition = -1;\n+\treturn new NodeMismatch(this, node2);\n     }\n \n     NodeMismatch res = null;\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2083/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:27:00.634477779 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1446, 
          "faulty": "return new NodeMismatch(this,node2);", 
          "type": "InsertBefore", 
          "seed": "sourcePosition=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3322/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:39:21.873567120 -0500\n@@ -199,7 +199,6 @@\n       if (nameNode != null) {\n         // This is a named break or continue;\n         String name = nameNode.getString();\n-        Preconditions.checkState(name.length() != 0);\n         LabelInfo li = getLabelInfo(name);\n         if (li != null) {\n           String newName = getNameForId(li.id);\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3322/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:39:21.877567179 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 202, 
          "faulty": "Preconditions.checkState(name.length() != 0);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1567/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:21:50.953753264 -0500\n@@ -728,7 +728,7 @@\n       if (fnParam != null) {\n         if (cArg != null) {\n           if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n+            return null;\n           }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1567/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:21:50.953753264 -0500\n@@ -885,9 +885,6 @@\n       Iterator<Entry<Node, Reference>> i;\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n-        if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n-        }\n       }\n     }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 888, 
          "faulty": "if (entry.getValue().mode == InliningMode.BLOCK) {\n  i.remove();\n}", 
          "type": "Delete", 
          "seed": "this.module=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 731, 
          "faulty": "return CanInlineResult.NO;", 
          "type": "Replace", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2489/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:31:22.962446669 -0500\n@@ -201,16 +201,6 @@\n         String name = nameNode.getString();\n         Preconditions.checkState(name.length() != 0);\n         LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n       }\n     }\n \n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2489/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:31:22.966446729 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2489/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:31:22.966446729 -0500\n@@ -756,8 +756,6 @@\n           // For functions that can no longer be removed, check if they should\n           // still be inlined.\n           if (!mimimizeCost(fsCalled)) {\n-            // It can't be inlined remove it from the list.\n-            fsCalled.setInline(false);\n           }\n         }\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 760, 
          "faulty": "fsCalled.setInline(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 204, 
          "faulty": "if (li != null) {\n  String newName=getNameForId(li.id);\n  li.referenced=true;\n  if (!name.equals(newName)) {\n    nameNode.setString(newName);\n    compiler.reportCodeChange();\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1384/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:19:32.011762315 -0500\n@@ -206,8 +206,6 @@\n           // Mark the label as referenced so it isn't removed.\n           li.referenced = true;\n           if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n             compiler.reportCodeChange();\n           }\n         }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1384/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:19:32.015762373 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 210, 
          "faulty": "nameNode.setString(newName);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3260/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:38:43.833006710 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_582/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:12:01.761355187 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_582/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:12:01.765355242 -0500\n@@ -501,8 +501,6 @@\n         // This reference can not be directly inlined, see if\n         // block replacement inlining is possible.\n         mode = InliningMode.BLOCK;\n-        referenceAdded = maybeAddReferenceUsingMode(\n-            t, fs, callNode, module, mode);\n       }\n \n       if (!referenceAdded) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 504, 
          "faulty": "referenceAdded=maybeAddReferenceUsingMode(t,fs,callNode,module,mode);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_353/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:09:20.219155485 -0500\n@@ -201,16 +201,6 @@\n         String name = nameNode.getString();\n         Preconditions.checkState(name.length() != 0);\n         LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n       }\n     }\n \n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_353/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:09:20.219155485 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_353/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:09:20.223155540 -0500\n@@ -742,7 +742,6 @@\n   private void resolveInlineConflictsForFunction(FunctionState fs) {\n     // Functions that aren't referenced don't cause conflicts.\n     if (!fs.hasReferences() || !fs.canInline()) {\n-      return;\n     }\n \n     Node fnNode = fs.getFn().getFunctionNode();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 745, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 204, 
          "faulty": "if (li != null) {\n  String newName=getNameForId(li.id);\n  li.referenced=true;\n  if (!name.equals(newName)) {\n    nameNode.setString(newName);\n    compiler.reportCodeChange();\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2407/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:30:33.497695168 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2543/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:31:50.754866072 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2543/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:31:50.754866072 -0500\n@@ -688,7 +688,6 @@\n     if (!inliningLowersCost(fs)) {\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n-        fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 691, 
          "faulty": "fs.setRemove(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1846/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:24:42.956412141 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1167/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:17:32.750042706 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1167/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:17:32.750042706 -0500\n@@ -688,7 +688,6 @@\n     if (!inliningLowersCost(fs)) {\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n-        fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 691, 
          "faulty": "fs.setRemove(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1475/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:20:35.356671295 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1228/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:18:04.474501406 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1449/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:20:11.720332407 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1449/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:20:11.720332407 -0500\n@@ -886,7 +886,8 @@\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n         if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n+          this.module = null;\n+\t\ti.remove();\n         }\n       }\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 889, 
          "faulty": "i.remove();", 
          "type": "InsertBefore", 
          "seed": "this.module=null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2933/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:35:30.322130708 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1295/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:18:44.159073823 -0500\n@@ -205,11 +205,6 @@\n           String newName = getNameForId(li.id);\n           // Mark the label as referenced so it isn't removed.\n           li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n         }\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1295/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:18:44.159073823 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1295/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:18:44.163073881 -0500\n@@ -756,8 +756,6 @@\n           // For functions that can no longer be removed, check if they should\n           // still be inlined.\n           if (!mimimizeCost(fsCalled)) {\n-            // It can't be inlined remove it from the list.\n-            fsCalled.setInline(false);\n           }\n         }\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 208, 
          "faulty": "if (!name.equals(newName)) {\n  nameNode.setString(newName);\n  compiler.reportCodeChange();\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 760, 
          "faulty": "fsCalled.setInline(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2539/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:31:48.842837278 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1985/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:26:08.605702714 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1985/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:26:08.605702714 -0500\n@@ -883,7 +883,8 @@\n \n     void removeBlockInliningReferences() {\n       Iterator<Entry<Node, Reference>> i;\n-      for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n+      this.module = null;\n+\tfor (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n         if (entry.getValue().mode == InliningMode.BLOCK) {\n           i.remove();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 886, 
          "faulty": "for (i=getReferencesInternal().entrySet().iterator(); i.hasNext(); ) {\n  Entry<Node,Reference> entry=i.next();\n  if (entry.getValue().mode == InliningMode.BLOCK) {\n    i.remove();\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "this.module=null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3132/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:37:26.283859993 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3132/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:37:26.287860052 -0500\n@@ -501,8 +501,6 @@\n         // This reference can not be directly inlined, see if\n         // block replacement inlining is possible.\n         mode = InliningMode.BLOCK;\n-        referenceAdded = maybeAddReferenceUsingMode(\n-            t, fs, callNode, module, mode);\n       }\n \n       if (!referenceAdded) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 504, 
          "faulty": "referenceAdded=maybeAddReferenceUsingMode(t,fs,callNode,module,mode);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3264/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:38:45.745034907 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_803/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:14:06.163076836 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:57:38.329845888 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_803/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:14:06.163076836 -0500\n@@ -1456,7 +1456,8 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        sourcePosition = -1;\n+\t\treturn res;\n       }\n     }\n     return res;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1459, 
          "faulty": "return res;", 
          "type": "InsertBefore", 
          "seed": "sourcePosition=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2611/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:32:26.143397554 -0500\n@@ -196,22 +196,6 @@\n      */\n     private void visitBreakOrContinue(Node node) {\n       Node nameNode = node.getFirstChild();\n-      if (nameNode != null) {\n-        // This is a named break or continue;\n-        String name = nameNode.getString();\n-        Preconditions.checkState(name.length() != 0);\n-        LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n-      }\n     }\n \n     /**\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2611/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:32:26.147397614 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 199, 
          "faulty": "if (nameNode != null) {\n  String name=nameNode.getString();\n  Preconditions.checkState(name.length() != 0);\n  LabelInfo li=getLabelInfo(name);\n  if (li != null) {\n    String newName=getNameForId(li.id);\n    li.referenced=true;\n    if (!name.equals(newName)) {\n      nameNode.setString(newName);\n      compiler.reportCodeChange();\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3302/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:39:12.281425923 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1206/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:17:52.938334727 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2143/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:27:48.819190881 -0500\n@@ -208,7 +208,6 @@\n           if (!name.equals(newName)) {\n             // Give it the short name.\n             nameNode.setString(newName);\n-            compiler.reportCodeChange();\n           }\n         }\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2143/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:27:48.819190881 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2143/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:27:48.819190881 -0500\n@@ -689,7 +689,6 @@\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n         fs.setRemove(false);\n-        fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n         }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 211, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 692, 
          "faulty": "fs.removeBlockInliningReferences();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1280/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:18:36.458962865 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1280/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:18:36.462962923 -0500\n@@ -690,9 +690,6 @@\n       if (fs.hasBlockInliningReferences()) {\n         fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n-        if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n-          return false;\n-        }\n       } else {\n         return false;\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 693, 
          "faulty": "if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2567/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:32:03.159052672 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_925/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:15:09.403957824 -0500\n@@ -205,11 +205,6 @@\n           String newName = getNameForId(li.id);\n           // Mark the label as referenced so it isn't removed.\n           li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n         }\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_925/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:15:09.403957824 -0500\n@@ -727,9 +727,6 @@\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_925/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:15:09.403957824 -0500\n@@ -756,8 +756,6 @@\n           // For functions that can no longer be removed, check if they should\n           // still be inlined.\n           if (!mimimizeCost(fsCalled)) {\n-            // It can't be inlined remove it from the list.\n-            fsCalled.setInline(false);\n           }\n         }\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 208, 
          "faulty": "if (!name.equals(newName)) {\n  nameNode.setString(newName);\n  compiler.reportCodeChange();\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 760, 
          "faulty": "fsCalled.setInline(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1242/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:18:11.218598786 -0500\n@@ -185,7 +185,7 @@\n \n         case Token.BREAK:\n         case Token.CONTINUE:\n-          visitBreakOrContinue(node);\n+          ;\n           break;\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1242/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:18:11.218598786 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 188, 
          "faulty": "visitBreakOrContinue(node);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1480/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:20:38.420715204 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2698/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:33:08.588031724 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_539/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:11:33.112961528 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:57:38.329845888 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_539/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:11:33.112961528 -0500\n@@ -1427,11 +1427,7 @@\n   public String checkTreeEquals(Node node2) {\n       NodeMismatch diff = checkTreeEqualsImpl(node2);\n       if (diff != null) {\n-        return \"Node tree inequality:\" +\n-            \"\\nTree1:\\n\" + toStringTree() +\n-            \"\\n\\nTree2:\\n\" + node2.toStringTree() +\n-            \"\\n\\nSubtree1: \" + diff.nodeA.toStringTree() +\n-            \"\\n\\nSubtree2: \" + diff.nodeB.toStringTree();\n+        return \"SCRIPT\";\n       }\n       return null;\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_539/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:11:33.116961582 -0500\n@@ -689,7 +689,6 @@\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n         fs.setRemove(false);\n-        fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n         }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1430, 
          "faulty": "return \"Node tree inequality:\" + \"\\nTree1:\\n\" + toStringTree() + \"\\n\\nTree2:\\n\"+ node2.toStringTree()+ \"\\n\\nSubtree1: \"+ diff.nodeA.toStringTree()+ \"\\n\\nSubtree2: \"+ diff.nodeB.toStringTree();", 
          "type": "Replace", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 692, 
          "faulty": "fs.removeBlockInliningReferences();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1431/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:20:02.044193580 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 08:57:38.089845892 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1431/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 09:20:02.048193637 -0500\n@@ -106,7 +106,6 @@\n \n   void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n-      return;\n     }\n \n     int type = n.getType();\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1431/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:20:02.048193637 -0500\n@@ -688,7 +688,6 @@\n     if (!inliningLowersCost(fs)) {\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n-        fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CodeGenerator.java", 
          "line": 109, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 691, 
          "faulty": "fs.setRemove(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_598/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:12:10.565476410 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1382/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:19:31.063748692 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_663/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:12:51.314038822 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1405/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:19:47.695987614 -0500\n@@ -196,22 +196,6 @@\n      */\n     private void visitBreakOrContinue(Node node) {\n       Node nameNode = node.getFirstChild();\n-      if (nameNode != null) {\n-        // This is a named break or continue;\n-        String name = nameNode.getString();\n-        Preconditions.checkState(name.length() != 0);\n-        LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n-      }\n     }\n \n     /**\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1405/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:19:47.695987614 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 199, 
          "faulty": "if (nameNode != null) {\n  String name=nameNode.getString();\n  Preconditions.checkState(name.length() != 0);\n  LabelInfo li=getLabelInfo(name);\n  if (li != null) {\n    String newName=getNameForId(li.id);\n    li.referenced=true;\n    if (!name.equals(newName)) {\n      nameNode.setString(newName);\n      compiler.reportCodeChange();\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3294/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:39:02.189277285 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3294/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:39:02.189277285 -0500\n@@ -885,9 +885,7 @@\n       Iterator<Entry<Node, Reference>> i;\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n-        if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n-        }\n+        this.module = null;\n       }\n     }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 888, 
          "faulty": "if (entry.getValue().mode == InliningMode.BLOCK) {\n  i.remove();\n}", 
          "type": "Replace", 
          "seed": "this.module=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1308/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:18:50.959171770 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1544/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:21:28.233428360 -0500\n@@ -185,7 +185,7 @@\n \n         case Token.BREAK:\n         case Token.CONTINUE:\n-          visitBreakOrContinue(node);\n+          ;\n           break;\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1544/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:21:28.237428417 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 188, 
          "faulty": "visitBreakOrContinue(node);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3328/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:39:24.789610031 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3328/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:39:24.789610031 -0500\n@@ -498,9 +498,6 @@\n           t, fs, callNode, module, mode);\n       if (!referenceAdded &&\n           mode == InliningMode.DIRECT && blockFunctionInliningEnabled) {\n-        // This reference can not be directly inlined, see if\n-        // block replacement inlining is possible.\n-        mode = InliningMode.BLOCK;\n         referenceAdded = maybeAddReferenceUsingMode(\n             t, fs, callNode, module, mode);\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 503, 
          "faulty": "mode=InliningMode.BLOCK;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1780/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:24:04.191820487 -0500\n@@ -203,8 +203,6 @@\n         LabelInfo li = getLabelInfo(name);\n         if (li != null) {\n           String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n           if (!name.equals(newName)) {\n             // Give it the short name.\n             nameNode.setString(newName);\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1780/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:24:04.191820487 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:57:38.329845888 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1780/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:24:04.191820487 -0500\n@@ -1456,7 +1456,8 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        sourcePosition = -1;\n+\t\treturn res;\n       }\n     }\n     return res;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 207, 
          "faulty": "li.referenced=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1459, 
          "faulty": "return res;", 
          "type": "InsertBefore", 
          "seed": "sourcePosition=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2593/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:32:16.591254357 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2593/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:32:16.595254418 -0500\n@@ -690,9 +690,6 @@\n       if (fs.hasBlockInliningReferences()) {\n         fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n-        if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n-          return false;\n-        }\n       } else {\n         return false;\n       }\n@@ -742,7 +739,6 @@\n   private void resolveInlineConflictsForFunction(FunctionState fs) {\n     // Functions that aren't referenced don't cause conflicts.\n     if (!fs.hasReferences() || !fs.canInline()) {\n-      return;\n     }\n \n     Node fnNode = fs.getFn().getFunctionNode();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 745, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 693, 
          "faulty": "if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2295/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:29:16.756513562 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3296/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:39:03.165291662 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3111/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:37:15.255696372 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2735/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:33:33.040395646 -0500\n@@ -185,7 +185,7 @@\n \n         case Token.BREAK:\n         case Token.CONTINUE:\n-          visitBreakOrContinue(node);\n+          ;\n           break;\n       }\n     }\n@@ -205,11 +205,6 @@\n           String newName = getNameForId(li.id);\n           // Mark the label as referenced so it isn't removed.\n           li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n         }\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2735/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:33:33.040395646 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 188, 
          "faulty": "visitBreakOrContinue(node);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 208, 
          "faulty": "if (!name.equals(newName)) {\n  nameNode.setString(newName);\n  compiler.reportCodeChange();\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_401/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:09:57.027651842 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_401/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:09:57.027651842 -0500\n@@ -498,9 +498,6 @@\n           t, fs, callNode, module, mode);\n       if (!referenceAdded &&\n           mode == InliningMode.DIRECT && blockFunctionInliningEnabled) {\n-        // This reference can not be directly inlined, see if\n-        // block replacement inlining is possible.\n-        mode = InliningMode.BLOCK;\n         referenceAdded = maybeAddReferenceUsingMode(\n             t, fs, callNode, module, mode);\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 503, 
          "faulty": "mode=InliningMode.BLOCK;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2970/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:35:48.878408893 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\t2018-12-01 08:57:38.101845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2970/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\t2018-12-01 09:35:48.882408952 -0500\n@@ -63,10 +63,6 @@\n     if (node.isName()) {\n       Node replacementTemplate = replacements.get(node.getString());\n       if (replacementTemplate != null) {\n-        // This should not be replacing declared names.\n-        Preconditions.checkState(!parent.isFunction()\n-            || !parent.isVar()\n-            || !parent.isCatch());\n         // The name may need to be replaced more than once,\n         // so we need to clone the node.\n         Node replacement = replacementTemplate.cloneTree();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionArgumentInjector.java", 
          "line": 67, 
          "faulty": "Preconditions.checkState(!parent.isFunction() || !parent.isVar() || !parent.isCatch());", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1681/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:22:55.942764152 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1681/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:22:55.942764152 -0500\n@@ -688,7 +688,6 @@\n     if (!inliningLowersCost(fs)) {\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n-        fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 691, 
          "faulty": "fs.setRemove(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1787/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:24:08.059879771 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_998/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:15:53.612601383 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_998/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:15:53.616601442 -0500\n@@ -886,7 +886,6 @@\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n         if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n         }\n       }\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 889, 
          "faulty": "i.remove();", 
          "type": "Delete", 
          "seed": "this.module=null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2725/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:33:28.188323509 -0500\n@@ -185,7 +185,7 @@\n \n         case Token.BREAK:\n         case Token.CONTINUE:\n-          visitBreakOrContinue(node);\n+          ;\n           break;\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2725/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:33:28.188323509 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 188, 
          "faulty": "visitBreakOrContinue(node);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3092/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:37:04.715539847 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\t2018-12-01 08:57:38.101845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3092/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\t2018-12-01 09:37:04.715539847 -0500\n@@ -63,10 +63,6 @@\n     if (node.isName()) {\n       Node replacementTemplate = replacements.get(node.getString());\n       if (replacementTemplate != null) {\n-        // This should not be replacing declared names.\n-        Preconditions.checkState(!parent.isFunction()\n-            || !parent.isVar()\n-            || !parent.isCatch());\n         // The name may need to be replaced more than once,\n         // so we need to clone the node.\n         Node replacement = replacementTemplate.cloneTree();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionArgumentInjector.java", 
          "line": 67, 
          "faulty": "Preconditions.checkState(!parent.isFunction() || !parent.isVar() || !parent.isCatch());", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_881/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:14:46.591639675 -0500\n@@ -199,7 +199,6 @@\n       if (nameNode != null) {\n         // This is a named break or continue;\n         String name = nameNode.getString();\n-        Preconditions.checkState(name.length() != 0);\n         LabelInfo li = getLabelInfo(name);\n         if (li != null) {\n           String newName = getNameForId(li.id);\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:57:38.329845888 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_881/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:14:46.595639730 -0500\n@@ -1443,7 +1443,10 @@\n    */\n   NodeMismatch checkTreeEqualsImpl(Node node2) {\n     if (!isEquivalentTo(node2, false, false, false)) {\n-      return new NodeMismatch(this, node2);\n+      if (!isEquivalentTo(node2, false, false, false)) {\n+\t\t\treturn new NodeMismatch(this, node2);\n+\t\t}\n+\treturn new NodeMismatch(this, node2);\n     }\n \n     NodeMismatch res = null;\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_881/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:14:46.595639730 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1446, 
          "faulty": "return new NodeMismatch(this,node2);", 
          "type": "InsertBefore", 
          "seed": "if (!isEquivalentTo(node2,false,false,false)) {\n  return new NodeMismatch(this,node2);\n}"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 202, 
          "faulty": "Preconditions.checkState(name.length() != 0);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2972/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:35:49.862423627 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2972/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:35:49.866423687 -0500\n@@ -756,8 +756,6 @@\n           // For functions that can no longer be removed, check if they should\n           // still be inlined.\n           if (!mimimizeCost(fsCalled)) {\n-            // It can't be inlined remove it from the list.\n-            fsCalled.setInline(false);\n           }\n         }\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 760, 
          "faulty": "fsCalled.setInline(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1502/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:21:06.301114509 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_701/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:13:11.762321816 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionToBlockMutator.java\t2018-12-01 08:57:38.101845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_701/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionToBlockMutator.java\t2018-12-01 09:13:11.762321816 -0500\n@@ -198,7 +198,7 @@\n \n     @Override\n     public String get() {\n-        return \"JSCompiler_inline_label_\" + idSupplier.get();\n+        return null;\n     }\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionToBlockMutator.java", 
          "line": 201, 
          "faulty": "return \"JSCompiler_inline_label_\" + idSupplier.get();", 
          "type": "Replace", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1300/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:18:47.035115253 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:57:38.329845888 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1300/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:18:47.035115253 -0500\n@@ -1456,7 +1456,8 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        sourcePosition = -1;\n+\t\treturn res;\n       }\n     }\n     return res;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1459, 
          "faulty": "return res;", 
          "type": "InsertBefore", 
          "seed": "sourcePosition=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1702/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:23:12.567023392 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 08:57:38.089845892 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1702/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 09:23:12.571023455 -0500\n@@ -106,7 +106,6 @@\n \n   void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n-      return;\n     }\n \n     int type = n.getType();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CodeGenerator.java", 
          "line": 109, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2247/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:28:51.948126615 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\t2018-12-01 08:57:38.101845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2247/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\t2018-12-01 09:28:51.948126615 -0500\n@@ -63,10 +63,6 @@\n     if (node.isName()) {\n       Node replacementTemplate = replacements.get(node.getString());\n       if (replacementTemplate != null) {\n-        // This should not be replacing declared names.\n-        Preconditions.checkState(!parent.isFunction()\n-            || !parent.isVar()\n-            || !parent.isCatch());\n         // The name may need to be replaced more than once,\n         // so we need to clone the node.\n         Node replacement = replacementTemplate.cloneTree();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionArgumentInjector.java", 
          "line": 67, 
          "faulty": "Preconditions.checkState(!parent.isFunction() || !parent.isVar() || !parent.isCatch());", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1115/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:16:59.689563498 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1115/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:16:59.693563555 -0500\n@@ -756,8 +756,6 @@\n           // For functions that can no longer be removed, check if they should\n           // still be inlined.\n           if (!mimimizeCost(fsCalled)) {\n-            // It can't be inlined remove it from the list.\n-            fsCalled.setInline(false);\n           }\n         }\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 760, 
          "faulty": "fsCalled.setInline(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1613/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:22:20.594208186 -0500\n@@ -206,8 +206,6 @@\n           // Mark the label as referenced so it isn't removed.\n           li.referenced = true;\n           if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n             compiler.reportCodeChange();\n           }\n         }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1613/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:22:20.594208186 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1613/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:22:20.598208249 -0500\n@@ -885,9 +885,6 @@\n       Iterator<Entry<Node, Reference>> i;\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n-        if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n-        }\n       }\n     }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 888, 
          "faulty": "if (entry.getValue().mode == InliningMode.BLOCK) {\n  i.remove();\n}", 
          "type": "Delete", 
          "seed": "this.module=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 210, 
          "faulty": "nameNode.setString(newName);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_625/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:12:25.365680432 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_250/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:08:14.226275192 -0500\n@@ -206,8 +206,6 @@\n           // Mark the label as referenced so it isn't removed.\n           li.referenced = true;\n           if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n             compiler.reportCodeChange();\n           }\n         }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_250/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:08:14.226275192 -0500\n@@ -727,9 +727,6 @@\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:57:38.329845888 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_250/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:08:14.226275192 -0500\n@@ -1427,11 +1427,12 @@\n   public String checkTreeEquals(Node node2) {\n       NodeMismatch diff = checkTreeEqualsImpl(node2);\n       if (diff != null) {\n-        return \"Node tree inequality:\" +\n-            \"\\nTree1:\\n\" + toStringTree() +\n-            \"\\n\\nTree2:\\n\" + node2.toStringTree() +\n-            \"\\n\\nSubtree1: \" + diff.nodeA.toStringTree() +\n-            \"\\n\\nSubtree2: \" + diff.nodeB.toStringTree();\n+        if (diff != null) {\n+\t\t\treturn \"Node tree inequality:\" + \"\\nTree1:\\n\" + toStringTree()\n+\t\t\t\t\t+ \"\\n\\nTree2:\\n\" + node2.toStringTree() + \"\\n\\nSubtree1: \"\n+\t\t\t\t\t+ diff.nodeA.toStringTree() + \"\\n\\nSubtree2: \"\n+\t\t\t\t\t+ diff.nodeB.toStringTree();\n+\t\t}\n       }\n       return null;\n   }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 210, 
          "faulty": "nameNode.setString(newName);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1430, 
          "faulty": "return \"Node tree inequality:\" + \"\\nTree1:\\n\" + toStringTree() + \"\\n\\nTree2:\\n\"+ node2.toStringTree()+ \"\\n\\nSubtree1: \"+ diff.nodeA.toStringTree()+ \"\\n\\nSubtree2: \"+ diff.nodeB.toStringTree();", 
          "type": "Replace", 
          "seed": "if (diff != null) {\n  return \"Node tree inequality:\" + \"\\nTree1:\\n\" + toStringTree() + \"\\n\\nTree2:\\n\"+ node2.toStringTree()+ \"\\n\\nSubtree1: \"+ diff.nodeA.toStringTree()+ \"\\n\\nSubtree2: \"+ diff.nodeB.toStringTree();\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2974/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:35:50.862438599 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2974/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:35:50.862438599 -0500\n@@ -894,7 +894,7 @@\n     public boolean hasBlockInliningReferences() {\n       for (Reference r : getReferencesInternal().values()) {\n         if (r.mode == InliningMode.BLOCK) {\n-          return true;\n+          return false;\n         }\n       }\n       return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 897, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2206/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:28:30.691807520 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionToBlockMutator.java\t2018-12-01 08:57:38.101845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2206/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionToBlockMutator.java\t2018-12-01 09:28:30.695807579 -0500\n@@ -198,7 +198,7 @@\n \n     @Override\n     public String get() {\n-        return \"JSCompiler_inline_label_\" + idSupplier.get();\n+        return null;\n     }\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionToBlockMutator.java", 
          "line": 201, 
          "faulty": "return \"JSCompiler_inline_label_\" + idSupplier.get();", 
          "type": "Replace", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1187/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:17:43.278195048 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1187/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:17:43.278195048 -0500\n@@ -894,7 +894,7 @@\n     public boolean hasBlockInliningReferences() {\n       for (Reference r : getReferencesInternal().values()) {\n         if (r.mode == InliningMode.BLOCK) {\n-          return true;\n+          return false;\n         }\n       }\n       return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 897, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2293/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:29:15.808498825 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_193/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:07:29.501687108 -0500\n@@ -728,7 +728,6 @@\n       if (fnParam != null) {\n         if (cArg != null) {\n           if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n           }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_193/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:07:29.505687161 -0500\n@@ -688,7 +688,6 @@\n     if (!inliningLowersCost(fs)) {\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n-        fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n@@ -886,7 +885,6 @@\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n         if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n         }\n       }\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 889, 
          "faulty": "i.remove();", 
          "type": "Delete", 
          "seed": "this.module=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 691, 
          "faulty": "fs.setRemove(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 731, 
          "faulty": "return CanInlineResult.NO;", 
          "type": "Delete", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_535/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:11:31.096933873 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3057/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:36:45.619255880 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:57:38.329845888 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_362/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:09:25.095221038 -0500\n@@ -1443,7 +1443,8 @@\n    */\n   NodeMismatch checkTreeEqualsImpl(Node node2) {\n     if (!isEquivalentTo(node2, false, false, false)) {\n-      return new NodeMismatch(this, node2);\n+      this.sourcePosition = sourcePosition;\n+\treturn new NodeMismatch(this, node2);\n     }\n \n     NodeMismatch res = null;\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_362/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:09:25.095221038 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1446, 
          "faulty": "return new NodeMismatch(this,node2);", 
          "type": "InsertBefore", 
          "seed": "this.sourcePosition=sourcePosition;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1256/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:18:17.894695142 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2578/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:32:08.975140048 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2578/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:32:08.975140048 -0500\n@@ -886,7 +886,8 @@\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n         if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n+          this.module = null;\n+\t\ti.remove();\n         }\n       }\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 889, 
          "faulty": "i.remove();", 
          "type": "InsertBefore", 
          "seed": "this.module=null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2715/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:33:23.416252525 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_799/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:14:04.215049751 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2678/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:32:58.883887022 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\t2018-12-01 08:57:38.101845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2678/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\t2018-12-01 09:32:58.883887022 -0500\n@@ -63,10 +63,6 @@\n     if (node.isName()) {\n       Node replacementTemplate = replacements.get(node.getString());\n       if (replacementTemplate != null) {\n-        // This should not be replacing declared names.\n-        Preconditions.checkState(!parent.isFunction()\n-            || !parent.isVar()\n-            || !parent.isCatch());\n         // The name may need to be replaced more than once,\n         // so we need to clone the node.\n         Node replacement = replacementTemplate.cloneTree();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionArgumentInjector.java", 
          "line": 67, 
          "faulty": "Preconditions.checkState(!parent.isFunction() || !parent.isVar() || !parent.isCatch());", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2635/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:32:37.679570250 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2790/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:34:01.200813618 -0500\n@@ -199,12 +199,9 @@\n       if (nameNode != null) {\n         // This is a named break or continue;\n         String name = nameNode.getString();\n-        Preconditions.checkState(name.length() != 0);\n         LabelInfo li = getLabelInfo(name);\n         if (li != null) {\n           String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n           if (!name.equals(newName)) {\n             // Give it the short name.\n             nameNode.setString(newName);\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2790/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:34:01.204813677 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 207, 
          "faulty": "li.referenced=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 202, 
          "faulty": "Preconditions.checkState(name.length() != 0);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1074/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:16:39.469269735 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1074/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:16:39.469269735 -0500\n@@ -501,8 +501,6 @@\n         // This reference can not be directly inlined, see if\n         // block replacement inlining is possible.\n         mode = InliningMode.BLOCK;\n-        referenceAdded = maybeAddReferenceUsingMode(\n-            t, fs, callNode, module, mode);\n       }\n \n       if (!referenceAdded) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 504, 
          "faulty": "referenceAdded=maybeAddReferenceUsingMode(t,fs,callNode,module,mode);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2688/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:33:03.687958678 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1354/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:19:15.791529137 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2420/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:30:40.197797375 -0500\n@@ -201,16 +201,6 @@\n         String name = nameNode.getString();\n         Preconditions.checkState(name.length() != 0);\n         LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n       }\n     }\n \n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2420/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:30:40.197797375 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 204, 
          "faulty": "if (li != null) {\n  String newName=getNameForId(li.id);\n  li.referenced=true;\n  if (!name.equals(newName)) {\n    nameNode.setString(newName);\n    compiler.reportCodeChange();\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_958/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:15:32.276289273 -0500\n@@ -727,9 +727,6 @@\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_368/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:09:34.111342414 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1604/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:22:15.778131902 -0500\n@@ -196,22 +196,6 @@\n      */\n     private void visitBreakOrContinue(Node node) {\n       Node nameNode = node.getFirstChild();\n-      if (nameNode != null) {\n-        // This is a named break or continue;\n-        String name = nameNode.getString();\n-        Preconditions.checkState(name.length() != 0);\n-        LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n-      }\n     }\n \n     /**\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1604/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:22:15.782131965 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 199, 
          "faulty": "if (nameNode != null) {\n  String name=nameNode.getString();\n  Preconditions.checkState(name.length() != 0);\n  LabelInfo li=getLabelInfo(name);\n  if (li != null) {\n    String newName=getNameForId(li.id);\n    li.referenced=true;\n    if (!name.equals(newName)) {\n      nameNode.setString(newName);\n      compiler.reportCodeChange();\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_374/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:09:37.047381985 -0500\n@@ -196,22 +196,6 @@\n      */\n     private void visitBreakOrContinue(Node node) {\n       Node nameNode = node.getFirstChild();\n-      if (nameNode != null) {\n-        // This is a named break or continue;\n-        String name = nameNode.getString();\n-        Preconditions.checkState(name.length() != 0);\n-        LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n-      }\n     }\n \n     /**\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_374/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:09:37.047381985 -0500\n@@ -728,7 +728,7 @@\n       if (fnParam != null) {\n         if (cArg != null) {\n           if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n+            return null;\n           }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 199, 
          "faulty": "if (nameNode != null) {\n  String name=nameNode.getString();\n  Preconditions.checkState(name.length() != 0);\n  LabelInfo li=getLabelInfo(name);\n  if (li != null) {\n    String newName=getNameForId(li.id);\n    li.referenced=true;\n    if (!name.equals(newName)) {\n      nameNode.setString(newName);\n      compiler.reportCodeChange();\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 731, 
          "faulty": "return CanInlineResult.NO;", 
          "type": "Replace", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1609/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:22:18.658177537 -0500\n@@ -205,11 +205,6 @@\n           String newName = getNameForId(li.id);\n           // Mark the label as referenced so it isn't removed.\n           li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n         }\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1609/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:22:18.662177600 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:57:38.329845888 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1609/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:22:18.662177600 -0500\n@@ -1427,11 +1427,7 @@\n   public String checkTreeEquals(Node node2) {\n       NodeMismatch diff = checkTreeEqualsImpl(node2);\n       if (diff != null) {\n-        return \"Node tree inequality:\" +\n-            \"\\nTree1:\\n\" + toStringTree() +\n-            \"\\n\\nTree2:\\n\" + node2.toStringTree() +\n-            \"\\n\\nSubtree1: \" + diff.nodeA.toStringTree() +\n-            \"\\n\\nSubtree2: \" + diff.nodeB.toStringTree();\n+        return \"SCRIPT\";\n       }\n       return null;\n   }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 208, 
          "faulty": "if (!name.equals(newName)) {\n  nameNode.setString(newName);\n  compiler.reportCodeChange();\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1430, 
          "faulty": "return \"Node tree inequality:\" + \"\\nTree1:\\n\" + toStringTree() + \"\\n\\nTree2:\\n\"+ node2.toStringTree()+ \"\\n\\nSubtree1: \"+ diff.nodeA.toStringTree()+ \"\\n\\nSubtree2: \"+ diff.nodeB.toStringTree();", 
          "type": "Replace", 
          "seed": "return \"SCRIPT\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_146/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:06:47.357140616 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:57:38.329845888 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_146/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:06:47.357140616 -0500\n@@ -1427,11 +1427,7 @@\n   public String checkTreeEquals(Node node2) {\n       NodeMismatch diff = checkTreeEqualsImpl(node2);\n       if (diff != null) {\n-        return \"Node tree inequality:\" +\n-            \"\\nTree1:\\n\" + toStringTree() +\n-            \"\\n\\nTree2:\\n\" + node2.toStringTree() +\n-            \"\\n\\nSubtree1: \" + diff.nodeA.toStringTree() +\n-            \"\\n\\nSubtree2: \" + diff.nodeB.toStringTree();\n+        return \"SCRIPT\";\n       }\n       return null;\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_146/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:06:47.361140668 -0500\n@@ -742,7 +742,6 @@\n   private void resolveInlineConflictsForFunction(FunctionState fs) {\n     // Functions that aren't referenced don't cause conflicts.\n     if (!fs.hasReferences() || !fs.canInline()) {\n-      return;\n     }\n \n     Node fnNode = fs.getFn().getFunctionNode();\n@@ -885,9 +884,7 @@\n       Iterator<Entry<Node, Reference>> i;\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n-        if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n-        }\n+        this.module = null;\n       }\n     }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 888, 
          "faulty": "if (entry.getValue().mode == InliningMode.BLOCK) {\n  i.remove();\n}", 
          "type": "Replace", 
          "seed": "this.module=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 745, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1430, 
          "faulty": "return \"Node tree inequality:\" + \"\\nTree1:\\n\" + toStringTree() + \"\\n\\nTree2:\\n\"+ node2.toStringTree()+ \"\\n\\nSubtree1: \"+ diff.nodeA.toStringTree()+ \"\\n\\nSubtree2: \"+ diff.nodeB.toStringTree();", 
          "type": "Replace", 
          "seed": "return \"SCRIPT\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_282/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:08:32.754520957 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionToBlockMutator.java\t2018-12-01 08:57:38.101845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_282/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionToBlockMutator.java\t2018-12-01 09:08:32.754520957 -0500\n@@ -198,7 +198,7 @@\n \n     @Override\n     public String get() {\n-        return \"JSCompiler_inline_label_\" + idSupplier.get();\n+        return null;\n     }\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionToBlockMutator.java", 
          "line": 201, 
          "faulty": "return \"JSCompiler_inline_label_\" + idSupplier.get();", 
          "type": "Replace", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1778/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:24:03.211805459 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2881/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:34:57.029639129 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2176/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:28:05.043430116 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\t2018-12-01 08:57:38.101845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2176/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\t2018-12-01 09:28:05.043430116 -0500\n@@ -63,10 +63,6 @@\n     if (node.isName()) {\n       Node replacementTemplate = replacements.get(node.getString());\n       if (replacementTemplate != null) {\n-        // This should not be replacing declared names.\n-        Preconditions.checkState(!parent.isFunction()\n-            || !parent.isVar()\n-            || !parent.isCatch());\n         // The name may need to be replaced more than once,\n         // so we need to clone the node.\n         Node replacement = replacementTemplate.cloneTree();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionArgumentInjector.java", 
          "line": 67, 
          "faulty": "Preconditions.checkState(!parent.isFunction() || !parent.isVar() || !parent.isCatch());", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2069/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:26:53.782376027 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1889/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:25:17.328932569 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1506/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:21:08.197141650 -0500\n@@ -196,22 +196,6 @@\n      */\n     private void visitBreakOrContinue(Node node) {\n       Node nameNode = node.getFirstChild();\n-      if (nameNode != null) {\n-        // This is a named break or continue;\n-        String name = nameNode.getString();\n-        Preconditions.checkState(name.length() != 0);\n-        LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n-      }\n     }\n \n     /**\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1506/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:21:08.201141706 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 199, 
          "faulty": "if (nameNode != null) {\n  String name=nameNode.getString();\n  Preconditions.checkState(name.length() != 0);\n  LabelInfo li=getLabelInfo(name);\n  if (li != null) {\n    String newName=getNameForId(li.id);\n    li.referenced=true;\n    if (!name.equals(newName)) {\n      nameNode.setString(newName);\n      compiler.reportCodeChange();\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2180/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:28:06.991458814 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2180/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:28:06.991458814 -0500\n@@ -501,8 +501,6 @@\n         // This reference can not be directly inlined, see if\n         // block replacement inlining is possible.\n         mode = InliningMode.BLOCK;\n-        referenceAdded = maybeAddReferenceUsingMode(\n-            t, fs, callNode, module, mode);\n       }\n \n       if (!referenceAdded) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 504, 
          "faulty": "referenceAdded=maybeAddReferenceUsingMode(t,fs,callNode,module,mode);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2462/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:31:03.242147889 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2462/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:31:03.246147949 -0500\n@@ -886,7 +886,6 @@\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n         if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n         }\n       }\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 889, 
          "faulty": "i.remove();", 
          "type": "Delete", 
          "seed": "this.module=null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2167/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:28:00.299360204 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2167/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:28:00.299360204 -0500\n@@ -894,7 +894,8 @@\n     public boolean hasBlockInliningReferences() {\n       for (Reference r : getReferencesInternal().values()) {\n         if (r.mode == InliningMode.BLOCK) {\n-          return true;\n+          this.module = null;\n+\t\treturn true;\n         }\n       }\n       return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 897, 
          "faulty": "return true;", 
          "type": "InsertBefore", 
          "seed": "this.module=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3068/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:36:51.751347121 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2122/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:27:26.086854965 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_493/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:11:01.400527318 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2537/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:31:47.874822696 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2512/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:31:34.498620985 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1416/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:19:53.424069856 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:57:38.329845888 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1416/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:19:53.424069856 -0500\n@@ -1456,7 +1456,6 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n       }\n     }\n     return res;\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1416/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:19:53.428069913 -0500\n@@ -498,9 +498,6 @@\n           t, fs, callNode, module, mode);\n       if (!referenceAdded &&\n           mode == InliningMode.DIRECT && blockFunctionInliningEnabled) {\n-        // This reference can not be directly inlined, see if\n-        // block replacement inlining is possible.\n-        mode = InliningMode.BLOCK;\n         referenceAdded = maybeAddReferenceUsingMode(\n             t, fs, callNode, module, mode);\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 503, 
          "faulty": "mode=InliningMode.BLOCK;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1459, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2338/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:29:39.736869680 -0500\n@@ -208,7 +208,6 @@\n           if (!name.equals(newName)) {\n             // Give it the short name.\n             nameNode.setString(newName);\n-            compiler.reportCodeChange();\n           }\n         }\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2338/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:29:39.736869680 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 211, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1029/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:16:10.052841362 -0500\n@@ -185,7 +185,7 @@\n \n         case Token.BREAK:\n         case Token.CONTINUE:\n-          visitBreakOrContinue(node);\n+          ;\n           break;\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1029/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:16:10.056841420 -0500\n@@ -728,7 +728,6 @@\n       if (fnParam != null) {\n         if (cArg != null) {\n           if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n           }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 188, 
          "faulty": "visitBreakOrContinue(node);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 731, 
          "faulty": "return CanInlineResult.NO;", 
          "type": "Delete", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1017/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:16:03.304742911 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1226/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:18:03.510487482 -0500\n@@ -727,9 +727,6 @@\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3192/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:38:02.884401993 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3230/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:38:28.392778884 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2079/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:26:58.598447553 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2079/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:26:58.598447553 -0500\n@@ -688,7 +688,6 @@\n     if (!inliningLowersCost(fs)) {\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n-        fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 691, 
          "faulty": "fs.setRemove(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1891/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:25:18.308947355 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1891/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:25:18.308947355 -0500\n@@ -883,11 +883,10 @@\n \n     void removeBlockInliningReferences() {\n       Iterator<Entry<Node, Reference>> i;\n-      for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n+      this.module = null;\n+\tfor (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n-        if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n-        }\n+        this.module = null;\n       }\n     }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 888, 
          "faulty": "if (entry.getValue().mode == InliningMode.BLOCK) {\n  i.remove();\n}", 
          "type": "Replace", 
          "seed": "this.module=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 886, 
          "faulty": "for (i=getReferencesInternal().entrySet().iterator(); i.hasNext(); ) {\n  Entry<Node,Reference> entry=i.next();\n  if (entry.getValue().mode == InliningMode.BLOCK) {\n    i.remove();\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "this.module=null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_731/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:13:26.426525045 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2943/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:35:35.146203089 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionToBlockMutator.java\t2018-12-01 08:57:38.101845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2943/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionToBlockMutator.java\t2018-12-01 09:35:35.146203089 -0500\n@@ -198,7 +198,7 @@\n \n     @Override\n     public String get() {\n-        return \"JSCompiler_inline_label_\" + idSupplier.get();\n+        return null;\n     }\n   }\n \n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2943/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:35:35.150203150 -0500\n@@ -885,9 +885,7 @@\n       Iterator<Entry<Node, Reference>> i;\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n-        if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n-        }\n+        this.module = null;\n       }\n     }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 888, 
          "faulty": "if (entry.getValue().mode == InliningMode.BLOCK) {\n  i.remove();\n}", 
          "type": "Replace", 
          "seed": "this.module=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionToBlockMutator.java", 
          "line": 201, 
          "faulty": "return \"JSCompiler_inline_label_\" + idSupplier.get();", 
          "type": "Replace", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1054/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:16:28.865115457 -0500\n@@ -728,7 +728,6 @@\n       if (fnParam != null) {\n         if (cArg != null) {\n           if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n           }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\t2018-12-01 08:57:38.101845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1054/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\t2018-12-01 09:16:28.865115457 -0500\n@@ -63,10 +63,6 @@\n     if (node.isName()) {\n       Node replacementTemplate = replacements.get(node.getString());\n       if (replacementTemplate != null) {\n-        // This should not be replacing declared names.\n-        Preconditions.checkState(!parent.isFunction()\n-            || !parent.isVar()\n-            || !parent.isCatch());\n         // The name may need to be replaced more than once,\n         // so we need to clone the node.\n         Node replacement = replacementTemplate.cloneTree();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 731, 
          "faulty": "return CanInlineResult.NO;", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionArgumentInjector.java", 
          "line": 67, 
          "faulty": "Preconditions.checkState(!parent.isFunction() || !parent.isVar() || !parent.isCatch());", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_838/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:14:23.495317967 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_618/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:12:21.297624324 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3292/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:39:01.229263140 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 731, 
          "faulty": "return CanInlineResult.NO;", 
          "type": "Delete", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_107/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:06:19.964790042 -0500\n@@ -728,7 +728,6 @@\n       if (fnParam != null) {\n         if (cArg != null) {\n           if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n           }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_107/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:06:19.964790042 -0500\n@@ -886,7 +886,7 @@\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n         if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n+          this.module = null;\n         }\n       }\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 889, 
          "faulty": "i.remove();", 
          "type": "Replace", 
          "seed": "this.module=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 731, 
          "faulty": "return CanInlineResult.NO;", 
          "type": "Delete", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1441/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:20:07.892277491 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1111/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:16:57.769535625 -0500\n@@ -206,8 +206,6 @@\n           // Mark the label as referenced so it isn't removed.\n           li.referenced = true;\n           if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n             compiler.reportCodeChange();\n           }\n         }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1111/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:16:57.769535625 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1111/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:16:57.769535625 -0500\n@@ -883,12 +883,7 @@\n \n     void removeBlockInliningReferences() {\n       Iterator<Entry<Node, Reference>> i;\n-      for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n-        Entry<Node, Reference> entry = i.next();\n-        if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n-        }\n-      }\n+      this.module = null;\n     }\n \n     public boolean hasBlockInliningReferences() {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 210, 
          "faulty": "nameNode.setString(newName);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 889, 
          "faulty": "i.remove();", 
          "type": "Replace", 
          "seed": "this.module=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 886, 
          "faulty": "for (i=getReferencesInternal().entrySet().iterator(); i.hasNext(); ) {\n  Entry<Node,Reference> entry=i.next();\n  if (entry.getValue().mode == InliningMode.BLOCK) {\n    i.remove();\n  }\n}", 
          "type": "Replace", 
          "seed": "this.module=null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2061/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:26:49.966319319 -0500\n@@ -201,16 +201,6 @@\n         String name = nameNode.getString();\n         Preconditions.checkState(name.length() != 0);\n         LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n       }\n     }\n \n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2061/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:26:49.966319319 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 204, 
          "faulty": "if (li != null) {\n  String newName=getNameForId(li.id);\n  li.referenced=true;\n  if (!name.equals(newName)) {\n    nameNode.setString(newName);\n    compiler.reportCodeChange();\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3036/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:36:28.663003301 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2257/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:28:56.724201322 -0500\n@@ -196,22 +196,6 @@\n      */\n     private void visitBreakOrContinue(Node node) {\n       Node nameNode = node.getFirstChild();\n-      if (nameNode != null) {\n-        // This is a named break or continue;\n-        String name = nameNode.getString();\n-        Preconditions.checkState(name.length() != 0);\n-        LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n-      }\n     }\n \n     /**\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2257/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:28:56.724201322 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 199, 
          "faulty": "if (nameNode != null) {\n  String name=nameNode.getString();\n  Preconditions.checkState(name.length() != 0);\n  LabelInfo li=getLabelInfo(name);\n  if (li != null) {\n    String newName=getNameForId(li.id);\n    li.referenced=true;\n    if (!name.equals(newName)) {\n      nameNode.setString(newName);\n      compiler.reportCodeChange();\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_485/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:10:57.492473932 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_485/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:10:57.492473932 -0500\n@@ -501,8 +501,6 @@\n         // This reference can not be directly inlined, see if\n         // block replacement inlining is possible.\n         mode = InliningMode.BLOCK;\n-        referenceAdded = maybeAddReferenceUsingMode(\n-            t, fs, callNode, module, mode);\n       }\n \n       if (!referenceAdded) {\n@@ -690,9 +688,6 @@\n       if (fs.hasBlockInliningReferences()) {\n         fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n-        if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n-          return false;\n-        }\n       } else {\n         return false;\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 504, 
          "faulty": "referenceAdded=maybeAddReferenceUsingMode(t,fs,callNode,module,mode);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 693, 
          "faulty": "if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2373/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:30:10.117337390 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2373/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:30:10.121337452 -0500\n@@ -688,7 +688,6 @@\n     if (!inliningLowersCost(fs)) {\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n-        fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 691, 
          "faulty": "fs.setRemove(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_602/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:12:12.513503246 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2438/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:30:50.749958069 -0500\n@@ -185,7 +185,7 @@\n \n         case Token.BREAK:\n         case Token.CONTINUE:\n-          visitBreakOrContinue(node);\n+          ;\n           break;\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2438/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:30:50.749958069 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2438/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:30:50.749958069 -0500\n@@ -501,8 +501,6 @@\n         // This reference can not be directly inlined, see if\n         // block replacement inlining is possible.\n         mode = InliningMode.BLOCK;\n-        referenceAdded = maybeAddReferenceUsingMode(\n-            t, fs, callNode, module, mode);\n       }\n \n       if (!referenceAdded) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 188, 
          "faulty": "visitBreakOrContinue(node);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 504, 
          "faulty": "referenceAdded=maybeAddReferenceUsingMode(t,fs,callNode,module,mode);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2487/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:31:21.986431905 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2487/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:31:21.990431966 -0500\n@@ -742,7 +742,6 @@\n   private void resolveInlineConflictsForFunction(FunctionState fs) {\n     // Functions that aren't referenced don't cause conflicts.\n     if (!fs.hasReferences() || !fs.canInline()) {\n-      return;\n     }\n \n     Node fnNode = fs.getFn().getFunctionNode();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 745, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_688/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:13:04.934227266 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_688/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:13:04.938227321 -0500\n@@ -689,7 +689,6 @@\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n         fs.setRemove(false);\n-        fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n         }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 692, 
          "faulty": "fs.removeBlockInliningReferences();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_386/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:09:43.835473556 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1410/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:19:50.560028738 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1482/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:20:39.380728959 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2900/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:35:06.569779826 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3223/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:38:19.452646866 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:57:38.329845888 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3223/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:38:19.452646866 -0500\n@@ -1456,7 +1456,10 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        if (!isEquivalentTo(node2, false, false, false)) {\n+\t\t\treturn new NodeMismatch(this, node2);\n+\t\t}\n+\t\treturn res;\n       }\n     }\n     return res;\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3223/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:38:19.456646925 -0500\n@@ -885,9 +885,6 @@\n       Iterator<Entry<Node, Reference>> i;\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n-        if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n-        }\n       }\n     }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 888, 
          "faulty": "if (entry.getValue().mode == InliningMode.BLOCK) {\n  i.remove();\n}", 
          "type": "Delete", 
          "seed": "this.module=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1459, 
          "faulty": "return res;", 
          "type": "InsertBefore", 
          "seed": "if (!isEquivalentTo(node2,false,false,false)) {\n  return new NodeMismatch(this,node2);\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1460/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:20:22.580488155 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2949/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:35:38.002245921 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_569/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:11:54.813259599 -0500\n@@ -203,8 +203,6 @@\n         LabelInfo li = getLabelInfo(name);\n         if (li != null) {\n           String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n           if (!name.equals(newName)) {\n             // Give it the short name.\n             nameNode.setString(newName);\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_569/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:11:54.813259599 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 207, 
          "faulty": "li.referenced=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1088/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:16:46.141366728 -0500\n@@ -196,22 +196,6 @@\n      */\n     private void visitBreakOrContinue(Node node) {\n       Node nameNode = node.getFirstChild();\n-      if (nameNode != null) {\n-        // This is a named break or continue;\n-        String name = nameNode.getString();\n-        Preconditions.checkState(name.length() != 0);\n-        LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n-      }\n     }\n \n     /**\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1088/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:16:46.145366786 -0500\n@@ -727,9 +727,6 @@\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 199, 
          "faulty": "if (nameNode != null) {\n  String name=nameNode.getString();\n  Preconditions.checkState(name.length() != 0);\n  LabelInfo li=getLabelInfo(name);\n  if (li != null) {\n    String newName=getNameForId(li.id);\n    li.referenced=true;\n    if (!name.equals(newName)) {\n      nameNode.setString(newName);\n      compiler.reportCodeChange();\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_224/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:07:56.858045910 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_224/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:07:56.858045910 -0500\n@@ -883,12 +883,6 @@\n \n     void removeBlockInliningReferences() {\n       Iterator<Entry<Node, Reference>> i;\n-      for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n-        Entry<Node, Reference> entry = i.next();\n-        if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n-        }\n-      }\n     }\n \n     public boolean hasBlockInliningReferences() {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 886, 
          "faulty": "for (i=getReferencesInternal().entrySet().iterator(); i.hasNext(); ) {\n  Entry<Node,Reference> entry=i.next();\n  if (entry.getValue().mode == InliningMode.BLOCK) {\n    i.remove();\n  }\n}", 
          "type": "Delete", 
          "seed": "this.module=null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1376/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:19:27.247693847 -0500\n@@ -205,11 +205,6 @@\n           String newName = getNameForId(li.id);\n           // Mark the label as referenced so it isn't removed.\n           li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n         }\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1376/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:19:27.247693847 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 208, 
          "faulty": "if (!name.equals(newName)) {\n  nameNode.setString(newName);\n  compiler.reportCodeChange();\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2545/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:31:51.702880346 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1836/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:24:38.208339956 -0500\n@@ -185,7 +185,7 @@\n \n         case Token.BREAK:\n         case Token.CONTINUE:\n-          visitBreakOrContinue(node);\n+          ;\n           break;\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1836/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:24:38.208339956 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\t2018-12-01 08:57:38.101845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1836/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\t2018-12-01 09:24:38.208339956 -0500\n@@ -63,10 +63,6 @@\n     if (node.isName()) {\n       Node replacementTemplate = replacements.get(node.getString());\n       if (replacementTemplate != null) {\n-        // This should not be replacing declared names.\n-        Preconditions.checkState(!parent.isFunction()\n-            || !parent.isVar()\n-            || !parent.isCatch());\n         // The name may need to be replaced more than once,\n         // so we need to clone the node.\n         Node replacement = replacementTemplate.cloneTree();\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1836/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:24:38.212340016 -0500\n@@ -885,9 +885,7 @@\n       Iterator<Entry<Node, Reference>> i;\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n-        if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n-        }\n+        this.module = null;\n       }\n     }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 888, 
          "faulty": "if (entry.getValue().mode == InliningMode.BLOCK) {\n  i.remove();\n}", 
          "type": "Replace", 
          "seed": "this.module=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 188, 
          "faulty": "visitBreakOrContinue(node);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionArgumentInjector.java", 
          "line": 67, 
          "faulty": "Preconditions.checkState(!parent.isFunction() || !parent.isVar() || !parent.isCatch());", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3330/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:39:25.761624334 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:57:38.329845888 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3330/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:39:25.765624392 -0500\n@@ -1427,11 +1427,7 @@\n   public String checkTreeEquals(Node node2) {\n       NodeMismatch diff = checkTreeEqualsImpl(node2);\n       if (diff != null) {\n-        return \"Node tree inequality:\" +\n-            \"\\nTree1:\\n\" + toStringTree() +\n-            \"\\n\\nTree2:\\n\" + node2.toStringTree() +\n-            \"\\n\\nSubtree1: \" + diff.nodeA.toStringTree() +\n-            \"\\n\\nSubtree2: \" + diff.nodeB.toStringTree();\n+        return \"SCRIPT\";\n       }\n       return null;\n   }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1430, 
          "faulty": "return \"Node tree inequality:\" + \"\\nTree1:\\n\" + toStringTree() + \"\\n\\nTree2:\\n\"+ node2.toStringTree()+ \"\\n\\nSubtree1: \"+ diff.nodeA.toStringTree()+ \"\\n\\nSubtree2: \"+ diff.nodeB.toStringTree();", 
          "type": "Replace", 
          "seed": "return \"SCRIPT\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1791/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:24:09.987909299 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:57:38.329845888 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1791/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:24:09.991909361 -0500\n@@ -1456,7 +1456,9 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        Preconditions.checkState(this.propListHead == null,\n+\t\t\t\t\"Node has existing properties.\");\n+\t\treturn res;\n       }\n     }\n     return res;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1459, 
          "faulty": "return res;", 
          "type": "InsertBefore", 
          "seed": "Preconditions.checkState(this.propListHead == null,\"Node has existing properties.\");"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3208/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:38:11.584530613 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2073/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:26:55.674404132 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3007/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:36:08.166697400 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2803/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:34:09.028929609 -0500\n@@ -203,8 +203,6 @@\n         LabelInfo li = getLabelInfo(name);\n         if (li != null) {\n           String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n           if (!name.equals(newName)) {\n             // Give it the short name.\n             nameNode.setString(newName);\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2803/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:34:09.028929609 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2803/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:34:09.028929609 -0500\n@@ -501,8 +501,6 @@\n         // This reference can not be directly inlined, see if\n         // block replacement inlining is possible.\n         mode = InliningMode.BLOCK;\n-        referenceAdded = maybeAddReferenceUsingMode(\n-            t, fs, callNode, module, mode);\n       }\n \n       if (!referenceAdded) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 207, 
          "faulty": "li.referenced=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 504, 
          "faulty": "referenceAdded=maybeAddReferenceUsingMode(t,fs,callNode,module,mode);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2239/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:28:47.148051425 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:57:38.329845888 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2239/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:28:47.148051425 -0500\n@@ -1456,7 +1456,9 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        Preconditions.checkState(this.propListHead == null,\n+\t\t\t\t\"Node has existing properties.\");\n+\t\treturn res;\n       }\n     }\n     return res;\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2239/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:28:47.152051488 -0500\n@@ -885,9 +885,7 @@\n       Iterator<Entry<Node, Reference>> i;\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n-        if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n-        }\n+        this.module = null;\n       }\n     }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 888, 
          "faulty": "if (entry.getValue().mode == InliningMode.BLOCK) {\n  i.remove();\n}", 
          "type": "Replace", 
          "seed": "this.module=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1459, 
          "faulty": "return res;", 
          "type": "InsertBefore", 
          "seed": "Preconditions.checkState(this.propListHead == null,\"Node has existing properties.\");"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1838/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:24:39.156354375 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2582/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:32:10.871168517 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1675/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:22:53.054718977 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2774/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:33:53.500699442 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1715/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:23:19.307128122 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2340/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:29:40.684884327 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1189/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:17:44.222208703 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_809/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:14:09.027116663 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2002/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:26:18.265847067 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2422/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:30:41.145811825 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1995/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:26:14.417789590 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1995/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:26:14.417789590 -0500\n@@ -498,9 +498,6 @@\n           t, fs, callNode, module, mode);\n       if (!referenceAdded &&\n           mode == InliningMode.DIRECT && blockFunctionInliningEnabled) {\n-        // This reference can not be directly inlined, see if\n-        // block replacement inlining is possible.\n-        mode = InliningMode.BLOCK;\n         referenceAdded = maybeAddReferenceUsingMode(\n             t, fs, callNode, module, mode);\n       }\n@@ -885,7 +882,8 @@\n       Iterator<Entry<Node, Reference>> i;\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n-        if (entry.getValue().mode == InliningMode.BLOCK) {\n+        this.module = null;\n+\t\tif (entry.getValue().mode == InliningMode.BLOCK) {\n           i.remove();\n         }\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 888, 
          "faulty": "if (entry.getValue().mode == InliningMode.BLOCK) {\n  i.remove();\n}", 
          "type": "InsertBefore", 
          "seed": "this.module=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 503, 
          "faulty": "mode=InliningMode.BLOCK;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 731, 
          "faulty": "return CanInlineResult.NO;", 
          "type": "Replace", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2913/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:35:13.269878579 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1397/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:19:43.843932296 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1822/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:24:25.388144665 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_384/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:09:42.871460544 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1942/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:25:45.405355109 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1942/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:25:45.405355109 -0500\n@@ -501,8 +501,6 @@\n         // This reference can not be directly inlined, see if\n         // block replacement inlining is possible.\n         mode = InliningMode.BLOCK;\n-        referenceAdded = maybeAddReferenceUsingMode(\n-            t, fs, callNode, module, mode);\n       }\n \n       if (!referenceAdded) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 504, 
          "faulty": "referenceAdded=maybeAddReferenceUsingMode(t,fs,callNode,module,mode);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2245/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:28:50.996111711 -0500\n@@ -196,22 +196,6 @@\n      */\n     private void visitBreakOrContinue(Node node) {\n       Node nameNode = node.getFirstChild();\n-      if (nameNode != null) {\n-        // This is a named break or continue;\n-        String name = nameNode.getString();\n-        Preconditions.checkState(name.length() != 0);\n-        LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n-      }\n     }\n \n     /**\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2245/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:28:51.000111774 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 199, 
          "faulty": "if (nameNode != null) {\n  String name=nameNode.getString();\n  Preconditions.checkState(name.length() != 0);\n  LabelInfo li=getLabelInfo(name);\n  if (li != null) {\n    String newName=getNameForId(li.id);\n    li.referenced=true;\n    if (!name.equals(newName)) {\n      nameNode.setString(newName);\n      compiler.reportCodeChange();\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2182/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:28:07.959473072 -0500\n@@ -196,22 +196,6 @@\n      */\n     private void visitBreakOrContinue(Node node) {\n       Node nameNode = node.getFirstChild();\n-      if (nameNode != null) {\n-        // This is a named break or continue;\n-        String name = nameNode.getString();\n-        Preconditions.checkState(name.length() != 0);\n-        LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n-      }\n     }\n \n     /**\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2182/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:28:07.959473072 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2182/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:28:07.959473072 -0500\n@@ -894,7 +894,7 @@\n     public boolean hasBlockInliningReferences() {\n       for (Reference r : getReferencesInternal().values()) {\n         if (r.mode == InliningMode.BLOCK) {\n-          return true;\n+          return false;\n         }\n       }\n       return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 897, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 199, 
          "faulty": "if (nameNode != null) {\n  String name=nameNode.getString();\n  Preconditions.checkState(name.length() != 0);\n  LabelInfo li=getLabelInfo(name);\n  if (li != null) {\n    String newName=getNameForId(li.id);\n    li.referenced=true;\n    if (!name.equals(newName)) {\n      nameNode.setString(newName);\n      compiler.reportCodeChange();\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3026/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:36:23.850931542 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3026/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:36:23.854931602 -0500\n@@ -501,8 +501,6 @@\n         // This reference can not be directly inlined, see if\n         // block replacement inlining is possible.\n         mode = InliningMode.BLOCK;\n-        referenceAdded = maybeAddReferenceUsingMode(\n-            t, fs, callNode, module, mode);\n       }\n \n       if (!referenceAdded) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 504, 
          "faulty": "referenceAdded=maybeAddReferenceUsingMode(t,fs,callNode,module,mode);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2052/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:26:45.162247888 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2113/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:27:21.254783448 -0500\n@@ -208,7 +208,6 @@\n           if (!name.equals(newName)) {\n             // Give it the short name.\n             nameNode.setString(newName);\n-            compiler.reportCodeChange();\n           }\n         }\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2113/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:27:21.254783448 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 211, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2389/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:30:18.773470059 -0500\n@@ -727,9 +727,6 @@\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1631/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:22:30.102358401 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\t2018-12-01 08:57:38.101845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1631/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\t2018-12-01 09:22:30.102358401 -0500\n@@ -63,10 +63,6 @@\n     if (node.isName()) {\n       Node replacementTemplate = replacements.get(node.getString());\n       if (replacementTemplate != null) {\n-        // This should not be replacing declared names.\n-        Preconditions.checkState(!parent.isFunction()\n-            || !parent.isVar()\n-            || !parent.isCatch());\n         // The name may need to be replaced more than once,\n         // so we need to clone the node.\n         Node replacement = replacementTemplate.cloneTree();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionArgumentInjector.java", 
          "line": 67, 
          "faulty": "Preconditions.checkState(!parent.isFunction() || !parent.isVar() || !parent.isCatch());", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1958/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:25:54.093485437 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2980/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:35:54.746496734 -0500\n@@ -727,9 +727,6 @@\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2980/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:35:54.750496793 -0500\n@@ -742,7 +742,6 @@\n   private void resolveInlineConflictsForFunction(FunctionState fs) {\n     // Functions that aren't referenced don't cause conflicts.\n     if (!fs.hasReferences() || !fs.canInline()) {\n-      return;\n     }\n \n     Node fnNode = fs.getFn().getFunctionNode();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 745, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2696/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:33:07.604017059 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2696/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:33:07.608017118 -0500\n@@ -883,7 +883,8 @@\n \n     void removeBlockInliningReferences() {\n       Iterator<Entry<Node, Reference>> i;\n-      for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n+      this.module = null;\n+\tfor (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n         if (entry.getValue().mode == InliningMode.BLOCK) {\n           i.remove();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 886, 
          "faulty": "for (i=getReferencesInternal().entrySet().iterator(); i.hasNext(); ) {\n  Entry<Node,Reference> entry=i.next();\n  if (entry.getValue().mode == InliningMode.BLOCK) {\n    i.remove();\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "this.module=null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1677/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:22:54.002733811 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1629/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:22:29.154343446 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1629/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:22:29.154343446 -0500\n@@ -690,9 +690,6 @@\n       if (fs.hasBlockInliningReferences()) {\n         fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n-        if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n-          return false;\n-        }\n       } else {\n         return false;\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 693, 
          "faulty": "if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1569/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:21:51.969767789 -0500\n@@ -185,7 +185,7 @@\n \n         case Token.BREAK:\n         case Token.CONTINUE:\n-          visitBreakOrContinue(node);\n+          ;\n           break;\n       }\n     }\n@@ -201,16 +201,6 @@\n         String name = nameNode.getString();\n         Preconditions.checkState(name.length() != 0);\n         LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n       }\n     }\n \n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1569/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:21:51.969767789 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1569/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:21:51.969767789 -0500\n@@ -742,7 +742,6 @@\n   private void resolveInlineConflictsForFunction(FunctionState fs) {\n     // Functions that aren't referenced don't cause conflicts.\n     if (!fs.hasReferences() || !fs.canInline()) {\n-      return;\n     }\n \n     Node fnNode = fs.getFn().getFunctionNode();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 188, 
          "faulty": "visitBreakOrContinue(node);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 745, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 204, 
          "faulty": "if (li != null) {\n  String newName=getNameForId(li.id);\n  li.referenced=true;\n  if (!name.equals(newName)) {\n    nameNode.setString(newName);\n    compiler.reportCodeChange();\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_855/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:14:33.051451023 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_988/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:15:47.856517259 -0500\n@@ -727,9 +727,6 @@\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_462/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:10:34.536160922 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_462/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:10:34.536160922 -0500\n@@ -742,7 +742,6 @@\n   private void resolveInlineConflictsForFunction(FunctionState fs) {\n     // Functions that aren't referenced don't cause conflicts.\n     if (!fs.hasReferences() || !fs.canInline()) {\n-      return;\n     }\n \n     Node fnNode = fs.getFn().getFunctionNode();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 745, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1639/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:22:33.914418484 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_656/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:12:47.325983686 -0500\n@@ -208,7 +208,6 @@\n           if (!name.equals(newName)) {\n             // Give it the short name.\n             nameNode.setString(newName);\n-            compiler.reportCodeChange();\n           }\n         }\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_656/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:12:47.329983742 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 211, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 731, 
          "faulty": "return CanInlineResult.NO;", 
          "type": "Replace", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_144/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:06:46.345127596 -0500\n@@ -196,22 +196,6 @@\n      */\n     private void visitBreakOrContinue(Node node) {\n       Node nameNode = node.getFirstChild();\n-      if (nameNode != null) {\n-        // This is a named break or continue;\n-        String name = nameNode.getString();\n-        Preconditions.checkState(name.length() != 0);\n-        LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n-      }\n     }\n \n     /**\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_144/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:06:46.349127647 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:57:38.329845888 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_144/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:06:46.349127647 -0500\n@@ -1456,7 +1456,8 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        parent = null;\n+\t\treturn res;\n       }\n     }\n     return res;\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 08:57:38.089845892 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_144/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 09:06:46.349127647 -0500\n@@ -106,7 +106,6 @@\n \n   void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n-      return;\n     }\n \n     int type = n.getType();\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_144/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:06:46.353127699 -0500\n@@ -688,7 +688,6 @@\n     if (!inliningLowersCost(fs)) {\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n-        fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CodeGenerator.java", 
          "line": 109, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 208, 
          "faulty": "if (!name.equals(newName)) {\n  nameNode.setString(newName);\n  compiler.reportCodeChange();\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 199, 
          "faulty": "if (nameNode != null) {\n  String name=nameNode.getString();\n  Preconditions.checkState(name.length() != 0);\n  LabelInfo li=getLabelInfo(name);\n  if (li != null) {\n    String newName=getNameForId(li.id);\n    li.referenced=true;\n    if (!name.equals(newName)) {\n      nameNode.setString(newName);\n      compiler.reportCodeChange();\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 691, 
          "faulty": "fs.setRemove(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1459, 
          "faulty": "return res;", 
          "type": "InsertBefore", 
          "seed": "parent=null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_645/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:12:41.377901488 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1272/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:18:26.526819669 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1048/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:16:25.965073237 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1048/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:16:25.969073296 -0500\n@@ -688,7 +688,6 @@\n     if (!inliningLowersCost(fs)) {\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n-        fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 691, 
          "faulty": "fs.setRemove(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1304/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:18:49.055144349 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\t2018-12-01 08:57:38.101845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1304/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\t2018-12-01 09:18:49.055144349 -0500\n@@ -63,10 +63,6 @@\n     if (node.isName()) {\n       Node replacementTemplate = replacements.get(node.getString());\n       if (replacementTemplate != null) {\n-        // This should not be replacing declared names.\n-        Preconditions.checkState(!parent.isFunction()\n-            || !parent.isVar()\n-            || !parent.isCatch());\n         // The name may need to be replaced more than once,\n         // so we need to clone the node.\n         Node replacement = replacementTemplate.cloneTree();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionArgumentInjector.java", 
          "line": 67, 
          "faulty": "Preconditions.checkState(!parent.isFunction() || !parent.isVar() || !parent.isCatch());", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2558/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:31:58.394981045 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_817/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:14:12.911170686 -0500\n@@ -208,7 +208,6 @@\n           if (!name.equals(newName)) {\n             // Give it the short name.\n             nameNode.setString(newName);\n-            compiler.reportCodeChange();\n           }\n         }\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_817/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:14:12.915170742 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:57:38.329845888 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_817/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:14:12.915170742 -0500\n@@ -1427,11 +1427,7 @@\n   public String checkTreeEquals(Node node2) {\n       NodeMismatch diff = checkTreeEqualsImpl(node2);\n       if (diff != null) {\n-        return \"Node tree inequality:\" +\n-            \"\\nTree1:\\n\" + toStringTree() +\n-            \"\\n\\nTree2:\\n\" + node2.toStringTree() +\n-            \"\\n\\nSubtree1: \" + diff.nodeA.toStringTree() +\n-            \"\\n\\nSubtree2: \" + diff.nodeB.toStringTree();\n+        return \"SCRIPT\";\n       }\n       return null;\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_817/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:14:12.915170742 -0500\n@@ -690,9 +690,7 @@\n       if (fs.hasBlockInliningReferences()) {\n         fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n-        if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n-          return false;\n-        }\n+        return false;\n       } else {\n         return false;\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 211, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 693, 
          "faulty": "if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1430, 
          "faulty": "return \"Node tree inequality:\" + \"\\nTree1:\\n\" + toStringTree() + \"\\n\\nTree2:\\n\"+ node2.toStringTree()+ \"\\n\\nSubtree1: \"+ diff.nodeA.toStringTree()+ \"\\n\\nSubtree2: \"+ diff.nodeB.toStringTree();", 
          "type": "Replace", 
          "seed": "return \"SCRIPT\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:57:38.329845888 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2794/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:34:03.176842905 -0500\n@@ -1443,7 +1443,10 @@\n    */\n   NodeMismatch checkTreeEqualsImpl(Node node2) {\n     if (!isEquivalentTo(node2, false, false, false)) {\n-      return new NodeMismatch(this, node2);\n+      if (!isEquivalentTo(node2, false, false, false)) {\n+\t\t\treturn new NodeMismatch(this, node2);\n+\t\t}\n+\treturn new NodeMismatch(this, node2);\n     }\n \n     NodeMismatch res = null;\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2794/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:34:03.180842964 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2794/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:34:03.180842964 -0500\n@@ -688,7 +688,6 @@\n     if (!inliningLowersCost(fs)) {\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n-        fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1446, 
          "faulty": "return new NodeMismatch(this,node2);", 
          "type": "InsertBefore", 
          "seed": "if (!isEquivalentTo(node2,false,false,false)) {\n  return new NodeMismatch(this,node2);\n}"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 691, 
          "faulty": "fs.setRemove(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1575/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:21:54.957810501 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1575/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:21:54.961810559 -0500\n@@ -886,7 +886,6 @@\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n         if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n         }\n       }\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 889, 
          "faulty": "i.remove();", 
          "type": "Delete", 
          "seed": "this.module=null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_328/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:09:06.366969618 -0500\n@@ -185,7 +185,7 @@\n \n         case Token.BREAK:\n         case Token.CONTINUE:\n-          visitBreakOrContinue(node);\n+          ;\n           break;\n       }\n     }\n@@ -203,12 +203,9 @@\n         LabelInfo li = getLabelInfo(name);\n         if (li != null) {\n           String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n           if (!name.equals(newName)) {\n             // Give it the short name.\n             nameNode.setString(newName);\n-            compiler.reportCodeChange();\n           }\n         }\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_328/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:09:06.370969671 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 188, 
          "faulty": "visitBreakOrContinue(node);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 207, 
          "faulty": "li.referenced=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 211, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2520/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:31:38.318678634 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2520/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:31:38.322678695 -0500\n@@ -756,8 +756,6 @@\n           // For functions that can no longer be removed, check if they should\n           // still be inlined.\n           if (!mimimizeCost(fsCalled)) {\n-            // It can't be inlined remove it from the list.\n-            fsCalled.setInline(false);\n           }\n         }\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 760, 
          "faulty": "fsCalled.setInline(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_134/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:06:40.361050709 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_134/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:06:40.361050709 -0500\n@@ -498,11 +498,6 @@\n           t, fs, callNode, module, mode);\n       if (!referenceAdded &&\n           mode == InliningMode.DIRECT && blockFunctionInliningEnabled) {\n-        // This reference can not be directly inlined, see if\n-        // block replacement inlining is possible.\n-        mode = InliningMode.BLOCK;\n-        referenceAdded = maybeAddReferenceUsingMode(\n-            t, fs, callNode, module, mode);\n       }\n \n       if (!referenceAdded) {\n@@ -742,7 +737,6 @@\n   private void resolveInlineConflictsForFunction(FunctionState fs) {\n     // Functions that aren't referenced don't cause conflicts.\n     if (!fs.hasReferences() || !fs.canInline()) {\n-      return;\n     }\n \n     Node fnNode = fs.getFn().getFunctionNode();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 503, 
          "faulty": "mode=InliningMode.BLOCK;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 504, 
          "faulty": "referenceAdded=maybeAddReferenceUsingMode(t,fs,callNode,module,mode);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 745, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1726/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:23:25.055217273 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1795/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:24:11.891938446 -0500\n@@ -196,22 +196,6 @@\n      */\n     private void visitBreakOrContinue(Node node) {\n       Node nameNode = node.getFirstChild();\n-      if (nameNode != null) {\n-        // This is a named break or continue;\n-        String name = nameNode.getString();\n-        Preconditions.checkState(name.length() != 0);\n-        LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n-      }\n     }\n \n     /**\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1795/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:24:11.891938446 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 199, 
          "faulty": "if (nameNode != null) {\n  String name=nameNode.getString();\n  Preconditions.checkState(name.length() != 0);\n  LabelInfo li=getLabelInfo(name);\n  if (li != null) {\n    String newName=getNameForId(li.id);\n    li.referenced=true;\n    if (!name.equals(newName)) {\n      nameNode.setString(newName);\n      compiler.reportCodeChange();\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_166/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:07:12.021459463 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_166/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:07:12.021459463 -0500\n@@ -688,7 +688,6 @@\n     if (!inliningLowersCost(fs)) {\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n-        fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 691, 
          "faulty": "fs.setRemove(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2283/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:29:10.052409261 -0500\n@@ -208,7 +208,6 @@\n           if (!name.equals(newName)) {\n             // Give it the short name.\n             nameNode.setString(newName);\n-            compiler.reportCodeChange();\n           }\n         }\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2283/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:29:10.052409261 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2283/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:29:10.052409261 -0500\n@@ -691,7 +691,6 @@\n         fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n-          return false;\n         }\n       } else {\n         return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 694, 
          "faulty": "return false;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 211, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_458/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:10:32.600134571 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 731, 
          "faulty": "return CanInlineResult.NO;", 
          "type": "Replace", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2351/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:29:47.396987928 -0500\n@@ -727,9 +727,6 @@\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1748/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:23:47.787568420 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 08:57:38.089845892 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1748/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 09:23:47.791568482 -0500\n@@ -106,7 +106,6 @@\n \n   void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n-      return;\n     }\n \n     int type = n.getType();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CodeGenerator.java", 
          "line": 109, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1879/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:25:12.512859866 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3308/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:39:15.137467971 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_370/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:09:35.095355674 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionToBlockMutator.java\t2018-12-01 08:57:38.101845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_370/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionToBlockMutator.java\t2018-12-01 09:09:35.095355674 -0500\n@@ -198,7 +198,7 @@\n \n     @Override\n     public String get() {\n-        return \"JSCompiler_inline_label_\" + idSupplier.get();\n+        return null;\n     }\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionToBlockMutator.java", 
          "line": 201, 
          "faulty": "return \"JSCompiler_inline_label_\" + idSupplier.get();", 
          "type": "Replace", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 731, 
          "faulty": "return CanInlineResult.NO;", 
          "type": "Replace", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1659/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:22:44.422583696 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1268/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:18:24.638792438 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1268/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:18:24.642792496 -0500\n@@ -885,9 +885,7 @@\n       Iterator<Entry<Node, Reference>> i;\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n-        if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n-        }\n+        this.module = null;\n       }\n     }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 888, 
          "faulty": "if (entry.getValue().mode == InliningMode.BLOCK) {\n  i.remove();\n}", 
          "type": "Replace", 
          "seed": "this.module=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2222/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:28:38.343919940 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2855/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:34:42.541425265 -0500\n@@ -205,11 +205,6 @@\n           String newName = getNameForId(li.id);\n           // Mark the label as referenced so it isn't removed.\n           li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n         }\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2855/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:34:42.541425265 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 208, 
          "faulty": "if (!name.equals(newName)) {\n  nameNode.setString(newName);\n  compiler.reportCodeChange();\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1641/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:22:34.858433350 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2778/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:33:55.420727920 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3268/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:38:47.685063514 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3214/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:38:14.480573410 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3214/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:38:14.480573410 -0500\n@@ -501,8 +501,6 @@\n         // This reference can not be directly inlined, see if\n         // block replacement inlining is possible.\n         mode = InliningMode.BLOCK;\n-        referenceAdded = maybeAddReferenceUsingMode(\n-            t, fs, callNode, module, mode);\n       }\n \n       if (!referenceAdded) {\n@@ -688,7 +686,6 @@\n     if (!inliningLowersCost(fs)) {\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n-        fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 504, 
          "faulty": "referenceAdded=maybeAddReferenceUsingMode(t,fs,callNode,module,mode);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 691, 
          "faulty": "fs.setRemove(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_627/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:12:26.337693842 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1456/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:20:20.680460911 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2829/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:34:23.877149390 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1009/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:15:59.428686330 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_604/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:12:13.469516419 -0500\n@@ -208,7 +208,6 @@\n           if (!name.equals(newName)) {\n             // Give it the short name.\n             nameNode.setString(newName);\n-            compiler.reportCodeChange();\n           }\n         }\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_604/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:12:13.473516473 -0500\n@@ -728,7 +728,7 @@\n       if (fnParam != null) {\n         if (cArg != null) {\n           if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n+            return null;\n           }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 211, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 731, 
          "faulty": "return CanInlineResult.NO;", 
          "type": "Replace", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2208/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:28:31.643821511 -0500\n@@ -196,22 +196,6 @@\n      */\n     private void visitBreakOrContinue(Node node) {\n       Node nameNode = node.getFirstChild();\n-      if (nameNode != null) {\n-        // This is a named break or continue;\n-        String name = nameNode.getString();\n-        Preconditions.checkState(name.length() != 0);\n-        LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n-      }\n     }\n \n     /**\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2208/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:28:31.647821570 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 199, 
          "faulty": "if (nameNode != null) {\n  String name=nameNode.getString();\n  Preconditions.checkState(name.length() != 0);\n  LabelInfo li=getLabelInfo(name);\n  if (li != null) {\n    String newName=getNameForId(li.id);\n    li.referenced=true;\n    if (!name.equals(newName)) {\n      nameNode.setString(newName);\n      compiler.reportCodeChange();\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1158/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:17:22.853899397 -0500\n@@ -206,8 +206,6 @@\n           // Mark the label as referenced so it isn't removed.\n           li.referenced = true;\n           if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n             compiler.reportCodeChange();\n           }\n         }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1158/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:17:22.853899397 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1158/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:17:22.857899455 -0500\n@@ -498,9 +498,6 @@\n           t, fs, callNode, module, mode);\n       if (!referenceAdded &&\n           mode == InliningMode.DIRECT && blockFunctionInliningEnabled) {\n-        // This reference can not be directly inlined, see if\n-        // block replacement inlining is possible.\n-        mode = InliningMode.BLOCK;\n         referenceAdded = maybeAddReferenceUsingMode(\n             t, fs, callNode, module, mode);\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 210, 
          "faulty": "nameNode.setString(newName);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 503, 
          "faulty": "mode=InliningMode.BLOCK;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_152/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:06:51.193190016 -0500\n@@ -196,22 +196,6 @@\n      */\n     private void visitBreakOrContinue(Node node) {\n       Node nameNode = node.getFirstChild();\n-      if (nameNode != null) {\n-        // This is a named break or continue;\n-        String name = nameNode.getString();\n-        Preconditions.checkState(name.length() != 0);\n-        LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n-      }\n     }\n \n     /**\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_152/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:06:51.193190016 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 199, 
          "faulty": "if (nameNode != null) {\n  String name=nameNode.getString();\n  Preconditions.checkState(name.length() != 0);\n  LabelInfo li=getLabelInfo(name);\n  if (li != null) {\n    String newName=getNameForId(li.id);\n    li.referenced=true;\n    if (!name.equals(newName)) {\n      nameNode.setString(newName);\n      compiler.reportCodeChange();\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1803/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:24:15.795998167 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 08:57:38.089845892 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1803/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 09:24:15.795998167 -0500\n@@ -106,7 +106,6 @@\n \n   void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n-      return;\n     }\n \n     int type = n.getType();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CodeGenerator.java", 
          "line": 109, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2171/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:28:02.199388208 -0500\n@@ -196,22 +196,6 @@\n      */\n     private void visitBreakOrContinue(Node node) {\n       Node nameNode = node.getFirstChild();\n-      if (nameNode != null) {\n-        // This is a named break or continue;\n-        String name = nameNode.getString();\n-        Preconditions.checkState(name.length() != 0);\n-        LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n-      }\n     }\n \n     /**\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2171/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:28:02.203388267 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 199, 
          "faulty": "if (nameNode != null) {\n  String name=nameNode.getString();\n  Preconditions.checkState(name.length() != 0);\n  LabelInfo li=getLabelInfo(name);\n  if (li != null) {\n    String newName=getNameForId(li.id);\n    li.referenced=true;\n    if (!name.equals(newName)) {\n      nameNode.setString(newName);\n      compiler.reportCodeChange();\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_514/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:11:18.316758722 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1412/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:19:51.504042291 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_379/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:09:39.987421632 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_379/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:09:39.987421632 -0500\n@@ -688,7 +688,6 @@\n     if (!inliningLowersCost(fs)) {\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n-        fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 691, 
          "faulty": "fs.setRemove(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_793/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:14:01.271008823 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1362/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:19:19.591583782 -0500\n@@ -206,8 +206,6 @@\n           // Mark the label as referenced so it isn't removed.\n           li.referenced = true;\n           if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n             compiler.reportCodeChange();\n           }\n         }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1362/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:19:19.591583782 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 210, 
          "faulty": "nameNode.setString(newName);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1102/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:16:52.913465113 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1072/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:16:38.477255309 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1072/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:16:38.481255368 -0500\n@@ -688,7 +688,6 @@\n     if (!inliningLowersCost(fs)) {\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n-        fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 691, 
          "faulty": "fs.setRemove(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_850/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:14:30.195411248 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2349/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:29:46.448973304 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1981/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:26:06.637673278 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2304/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:29:21.596588745 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 08:57:38.089845892 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2304/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 09:29:21.600588807 -0500\n@@ -106,7 +106,6 @@\n \n   void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n-      return;\n     }\n \n     int type = n.getType();\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2304/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:29:21.600588807 -0500\n@@ -894,7 +894,7 @@\n     public boolean hasBlockInliningReferences() {\n       for (Reference r : getReferencesInternal().values()) {\n         if (r.mode == InliningMode.BLOCK) {\n-          return true;\n+          this.module = null;\n         }\n       }\n       return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 897, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "this.module=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CodeGenerator.java", 
          "line": 109, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2360/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:29:58.305155936 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2360/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:29:58.309155998 -0500\n@@ -886,7 +886,7 @@\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n         if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n+          this.module = null;\n         }\n       }\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 889, 
          "faulty": "i.remove();", 
          "type": "Replace", 
          "seed": "this.module=null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1126/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:17:05.613649462 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1126/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:17:05.613649462 -0500\n@@ -885,9 +885,6 @@\n       Iterator<Entry<Node, Reference>> i;\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n-        if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n-        }\n       }\n     }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 888, 
          "faulty": "if (entry.getValue().mode == InliningMode.BLOCK) {\n  i.remove();\n}", 
          "type": "Delete", 
          "seed": "this.module=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1491/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:20:49.356871879 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\t2018-12-01 08:57:38.101845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1491/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\t2018-12-01 09:20:49.356871879 -0500\n@@ -63,10 +63,6 @@\n     if (node.isName()) {\n       Node replacementTemplate = replacements.get(node.getString());\n       if (replacementTemplate != null) {\n-        // This should not be replacing declared names.\n-        Preconditions.checkState(!parent.isFunction()\n-            || !parent.isVar()\n-            || !parent.isCatch());\n         // The name may need to be replaced more than once,\n         // so we need to clone the node.\n         Node replacement = replacementTemplate.cloneTree();\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1491/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:20:49.356871879 -0500\n@@ -756,8 +756,6 @@\n           // For functions that can no longer be removed, check if they should\n           // still be inlined.\n           if (!mimimizeCost(fsCalled)) {\n-            // It can't be inlined remove it from the list.\n-            fsCalled.setInline(false);\n           }\n         }\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 760, 
          "faulty": "fsCalled.setInline(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionArgumentInjector.java", 
          "line": 67, 
          "faulty": "Preconditions.checkState(!parent.isFunction() || !parent.isVar() || !parent.isCatch());", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_290/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:08:42.678653061 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 731, 
          "faulty": "return CanInlineResult.NO;", 
          "type": "Replace", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2982/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:35:55.706511098 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2982/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:35:55.710511159 -0500\n@@ -885,9 +885,7 @@\n       Iterator<Entry<Node, Reference>> i;\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n-        if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n-        }\n+        this.module = null;\n       }\n     }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 888, 
          "faulty": "if (entry.getValue().mode == InliningMode.BLOCK) {\n  i.remove();\n}", 
          "type": "Replace", 
          "seed": "this.module=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2281/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:29:09.088394247 -0500\n@@ -205,11 +205,6 @@\n           String newName = getNameForId(li.id);\n           // Mark the label as referenced so it isn't removed.\n           li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n         }\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2281/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:29:09.088394247 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 208, 
          "faulty": "if (!name.equals(newName)) {\n  nameNode.setString(newName);\n  compiler.reportCodeChange();\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3162/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:37:46.668162042 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 731, 
          "faulty": "return CanInlineResult.NO;", 
          "type": "Replace", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_286/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:08:34.682546597 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1635/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:22:32.022388674 -0500\n@@ -727,9 +727,6 @@\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 731, 
          "faulty": "return CanInlineResult.NO;", 
          "type": "Replace", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1181/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:17:40.390153271 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_871/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:14:40.767558511 -0500\n@@ -727,9 +727,6 @@\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1558/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:21:46.145684526 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_544/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:11:36.089002362 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1052/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:16:27.909101541 -0500\n@@ -203,8 +203,6 @@\n         LabelInfo li = getLabelInfo(name);\n         if (li != null) {\n           String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n           if (!name.equals(newName)) {\n             // Give it the short name.\n             nameNode.setString(newName);\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1052/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:16:27.909101541 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionToBlockMutator.java\t2018-12-01 08:57:38.101845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1052/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionToBlockMutator.java\t2018-12-01 09:16:27.909101541 -0500\n@@ -198,7 +198,7 @@\n \n     @Override\n     public String get() {\n-        return \"JSCompiler_inline_label_\" + idSupplier.get();\n+        return null;\n     }\n   }\n \n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1052/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:16:27.909101541 -0500\n@@ -690,9 +690,6 @@\n       if (fs.hasBlockInliningReferences()) {\n         fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n-        if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n-          return false;\n-        }\n       } else {\n         return false;\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 207, 
          "faulty": "li.referenced=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionToBlockMutator.java", 
          "line": 201, 
          "faulty": "return \"JSCompiler_inline_label_\" + idSupplier.get();", 
          "type": "Replace", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 693, 
          "faulty": "if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1829/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:24:34.320280788 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2656/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:32:48.247728232 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2656/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:32:48.247728232 -0500\n@@ -883,7 +883,8 @@\n \n     void removeBlockInliningReferences() {\n       Iterator<Entry<Node, Reference>> i;\n-      for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n+      this.module = null;\n+\tfor (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n         if (entry.getValue().mode == InliningMode.BLOCK) {\n           i.remove();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 886, 
          "faulty": "for (i=getReferencesInternal().entrySet().iterator(); i.hasNext(); ) {\n  Entry<Node,Reference> entry=i.next();\n  if (entry.getValue().mode == InliningMode.BLOCK) {\n    i.remove();\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "this.module=null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_995/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:15:51.676573095 -0500\n@@ -727,9 +727,6 @@\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_634/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:12:35.393818837 -0500\n@@ -727,9 +727,6 @@\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_634/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:12:35.397818893 -0500\n@@ -689,7 +689,6 @@\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n         fs.setRemove(false);\n-        fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n         }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 692, 
          "faulty": "fs.removeBlockInliningReferences();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2046/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:26:42.270204864 -0500\n@@ -206,8 +206,6 @@\n           // Mark the label as referenced so it isn't removed.\n           li.referenced = true;\n           if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n             compiler.reportCodeChange();\n           }\n         }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2046/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:26:42.270204864 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\t2018-12-01 08:57:38.101845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2046/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\t2018-12-01 09:26:42.274204922 -0500\n@@ -63,10 +63,6 @@\n     if (node.isName()) {\n       Node replacementTemplate = replacements.get(node.getString());\n       if (replacementTemplate != null) {\n-        // This should not be replacing declared names.\n-        Preconditions.checkState(!parent.isFunction()\n-            || !parent.isVar()\n-            || !parent.isCatch());\n         // The name may need to be replaced more than once,\n         // so we need to clone the node.\n         Node replacement = replacementTemplate.cloneTree();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 210, 
          "faulty": "nameNode.setString(newName);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionArgumentInjector.java", 
          "line": 67, 
          "faulty": "Preconditions.checkState(!parent.isFunction() || !parent.isVar() || !parent.isCatch());", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2666/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:32:53.087800516 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_556/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:11:42.853095226 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_556/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:11:42.857095280 -0500\n@@ -498,9 +498,6 @@\n           t, fs, callNode, module, mode);\n       if (!referenceAdded &&\n           mode == InliningMode.DIRECT && blockFunctionInliningEnabled) {\n-        // This reference can not be directly inlined, see if\n-        // block replacement inlining is possible.\n-        mode = InliningMode.BLOCK;\n         referenceAdded = maybeAddReferenceUsingMode(\n             t, fs, callNode, module, mode);\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 503, 
          "faulty": "mode=InliningMode.BLOCK;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2953/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:35:39.910274528 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_590/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:12:05.749410084 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2394/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:30:26.793592759 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2905/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:35:09.417821809 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2477/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:31:11.098267040 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\t2018-12-01 08:57:38.101845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2477/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\t2018-12-01 09:31:11.098267040 -0500\n@@ -63,10 +63,6 @@\n     if (node.isName()) {\n       Node replacementTemplate = replacements.get(node.getString());\n       if (replacementTemplate != null) {\n-        // This should not be replacing declared names.\n-        Preconditions.checkState(!parent.isFunction()\n-            || !parent.isVar()\n-            || !parent.isCatch());\n         // The name may need to be replaced more than once,\n         // so we need to clone the node.\n         Node replacement = replacementTemplate.cloneTree();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionArgumentInjector.java", 
          "line": 67, 
          "faulty": "Preconditions.checkState(!parent.isFunction() || !parent.isVar() || !parent.isCatch());", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1326/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:19:00.511309294 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2939/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:35:33.206173986 -0500\n@@ -208,7 +208,6 @@\n           if (!name.equals(newName)) {\n             // Give it the short name.\n             nameNode.setString(newName);\n-            compiler.reportCodeChange();\n           }\n         }\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2939/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:35:33.210174047 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 211, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2839/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:34:34.833311383 -0500\n@@ -185,7 +185,7 @@\n \n         case Token.BREAK:\n         case Token.CONTINUE:\n-          visitBreakOrContinue(node);\n+          ;\n           break;\n       }\n     }\n@@ -203,8 +203,6 @@\n         LabelInfo li = getLabelInfo(name);\n         if (li != null) {\n           String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n           if (!name.equals(newName)) {\n             // Give it the short name.\n             nameNode.setString(newName);\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2839/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:34:34.833311383 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 188, 
          "faulty": "visitBreakOrContinue(node);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 207, 
          "faulty": "li.referenced=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3100/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:37:09.471610494 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3100/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:37:09.471610494 -0500\n@@ -689,7 +689,6 @@\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n         fs.setRemove(false);\n-        fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n         }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 692, 
          "faulty": "fs.removeBlockInliningReferences();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_836/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:14:22.547304772 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_836/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:14:22.547304772 -0500\n@@ -691,7 +691,6 @@\n         fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n-          return false;\n         }\n       } else {\n         return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 694, 
          "faulty": "return false;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1447/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:20:10.764318693 -0500\n@@ -208,7 +208,6 @@\n           if (!name.equals(newName)) {\n             // Give it the short name.\n             nameNode.setString(newName);\n-            compiler.reportCodeChange();\n           }\n         }\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1447/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:20:10.764318693 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 211, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1584/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:21:59.961882023 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_972/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:15:39.132389651 -0500\n@@ -208,7 +208,6 @@\n           if (!name.equals(newName)) {\n             // Give it the short name.\n             nameNode.setString(newName);\n-            compiler.reportCodeChange();\n           }\n         }\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_972/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:15:39.132389651 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 211, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2321/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:29:30.196722097 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1137/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:17:11.341732543 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2686/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:33:02.731944421 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1976/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:26:03.761630245 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1976/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:26:03.765630306 -0500\n@@ -742,7 +742,6 @@\n   private void resolveInlineConflictsForFunction(FunctionState fs) {\n     // Functions that aren't referenced don't cause conflicts.\n     if (!fs.hasReferences() || !fs.canInline()) {\n-      return;\n     }\n \n     Node fnNode = fs.getFn().getFunctionNode();\n@@ -756,8 +755,6 @@\n           // For functions that can no longer be removed, check if they should\n           // still be inlined.\n           if (!mimimizeCost(fsCalled)) {\n-            // It can't be inlined remove it from the list.\n-            fsCalled.setInline(false);\n           }\n         }\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 745, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 760, 
          "faulty": "fsCalled.setInline(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2043/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:26:40.354176349 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionToBlockMutator.java\t2018-12-01 08:57:38.101845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2043/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionToBlockMutator.java\t2018-12-01 09:26:40.354176349 -0500\n@@ -198,7 +198,7 @@\n \n     @Override\n     public String get() {\n-        return \"JSCompiler_inline_label_\" + idSupplier.get();\n+        return null;\n     }\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionToBlockMutator.java", 
          "line": 201, 
          "faulty": "return \"JSCompiler_inline_label_\" + idSupplier.get();", 
          "type": "Replace", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1335/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:19:05.271377798 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2600/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:32:20.411311647 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_221/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:07:54.934020579 -0500\n@@ -203,8 +203,6 @@\n         LabelInfo li = getLabelInfo(name);\n         if (li != null) {\n           String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n           if (!name.equals(newName)) {\n             // Give it the short name.\n             nameNode.setString(newName);\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_221/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:07:54.934020579 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 207, 
          "faulty": "li.referenced=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 731, 
          "faulty": "return CanInlineResult.NO;", 
          "type": "Delete", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2377/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:30:12.045366962 -0500\n@@ -205,11 +205,6 @@\n           String newName = getNameForId(li.id);\n           // Mark the label as referenced so it isn't removed.\n           li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n         }\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2377/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:30:12.049367023 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 208, 
          "faulty": "if (!name.equals(newName)) {\n  nameNode.setString(newName);\n  compiler.reportCodeChange();\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2851/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:34:40.589396432 -0500\n@@ -185,7 +185,7 @@\n \n         case Token.BREAK:\n         case Token.CONTINUE:\n-          visitBreakOrContinue(node);\n+          ;\n           break;\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2851/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:34:40.589396432 -0500\n@@ -727,9 +727,6 @@\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 188, 
          "faulty": "visitBreakOrContinue(node);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_436/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:10:21.775987393 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_898/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:14:55.291760966 -0500\n@@ -727,9 +727,6 @@\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1966/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:25:57.913542682 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1966/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:25:57.913542682 -0500\n@@ -756,8 +756,6 @@\n           // For functions that can no longer be removed, check if they should\n           // still be inlined.\n           if (!mimimizeCost(fsCalled)) {\n-            // It can't be inlined remove it from the list.\n-            fsCalled.setInline(false);\n           }\n         }\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 760, 
          "faulty": "fsCalled.setInline(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1745/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:23:45.863538784 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1248/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:18:14.102640416 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1619/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:22:23.430253045 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2889/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:35:00.849695479 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1932/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:25:39.261262825 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3001/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:36:05.302654601 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1987/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:26:09.561717009 -0500\n@@ -208,7 +208,6 @@\n           if (!name.equals(newName)) {\n             // Give it the short name.\n             nameNode.setString(newName);\n-            compiler.reportCodeChange();\n           }\n         }\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1987/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:26:09.561717009 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 211, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_305/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:08:51.654772813 -0500\n@@ -185,7 +185,7 @@\n \n         case Token.BREAK:\n         case Token.CONTINUE:\n-          visitBreakOrContinue(node);\n+          ;\n           break;\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_305/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:08:51.654772813 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 188, 
          "faulty": "visitBreakOrContinue(node);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2470/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:31:07.066205909 -0500\n@@ -727,9 +727,6 @@\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2843/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:34:36.737339520 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_170/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:07:14.045485753 -0500\n@@ -203,8 +203,6 @@\n         LabelInfo li = getLabelInfo(name);\n         if (li != null) {\n           String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n           if (!name.equals(newName)) {\n             // Give it the short name.\n             nameNode.setString(newName);\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_170/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:07:14.045485753 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 08:57:38.089845892 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_170/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 09:07:14.049485806 -0500\n@@ -106,7 +106,6 @@\n \n   void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n-      return;\n     }\n \n     int type = n.getType();\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_170/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:07:14.049485806 -0500\n@@ -498,9 +498,6 @@\n           t, fs, callNode, module, mode);\n       if (!referenceAdded &&\n           mode == InliningMode.DIRECT && blockFunctionInliningEnabled) {\n-        // This reference can not be directly inlined, see if\n-        // block replacement inlining is possible.\n-        mode = InliningMode.BLOCK;\n         referenceAdded = maybeAddReferenceUsingMode(\n             t, fs, callNode, module, mode);\n       }\n@@ -689,7 +686,6 @@\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n         fs.setRemove(false);\n-        fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n         }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 503, 
          "faulty": "mode=InliningMode.BLOCK;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 207, 
          "faulty": "li.referenced=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CodeGenerator.java", 
          "line": 109, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 692, 
          "faulty": "fs.removeBlockInliningReferences();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2827/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:34:22.925135307 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2764/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:33:48.168620331 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_766/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:13:45.646791753 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_751/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:13:37.994685525 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_751/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:13:37.994685525 -0500\n@@ -501,8 +501,6 @@\n         // This reference can not be directly inlined, see if\n         // block replacement inlining is possible.\n         mode = InliningMode.BLOCK;\n-        referenceAdded = maybeAddReferenceUsingMode(\n-            t, fs, callNode, module, mode);\n       }\n \n       if (!referenceAdded) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 504, 
          "faulty": "referenceAdded=maybeAddReferenceUsingMode(t,fs,callNode,module,mode);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2729/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:33:30.116352178 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2729/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:33:30.120352238 -0500\n@@ -690,9 +690,7 @@\n       if (fs.hasBlockInliningReferences()) {\n         fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n-        if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n-          return false;\n-        }\n+        return false;\n       } else {\n         return false;\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 693, 
          "faulty": "if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3258/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:38:42.884992728 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1473/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:20:34.408657709 -0500\n@@ -185,7 +185,7 @@\n \n         case Token.BREAK:\n         case Token.CONTINUE:\n-          visitBreakOrContinue(node);\n+          ;\n           break;\n       }\n     }\n@@ -201,16 +201,6 @@\n         String name = nameNode.getString();\n         Preconditions.checkState(name.length() != 0);\n         LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n       }\n     }\n \n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1473/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:20:34.408657709 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1473/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:20:34.412657766 -0500\n@@ -690,9 +690,7 @@\n       if (fs.hasBlockInliningReferences()) {\n         fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n-        if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n-          return false;\n-        }\n+        return false;\n       } else {\n         return false;\n       }\n@@ -756,8 +754,6 @@\n           // For functions that can no longer be removed, check if they should\n           // still be inlined.\n           if (!mimimizeCost(fsCalled)) {\n-            // It can't be inlined remove it from the list.\n-            fsCalled.setInline(false);\n           }\n         }\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 188, 
          "faulty": "visitBreakOrContinue(node);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 693, 
          "faulty": "if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 760, 
          "faulty": "fsCalled.setInline(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 204, 
          "faulty": "if (li != null) {\n  String newName=getNameForId(li.id);\n  li.referenced=true;\n  if (!name.equals(newName)) {\n    nameNode.setString(newName);\n    compiler.reportCodeChange();\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2719/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:33:25.316280793 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2719/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:33:25.320280852 -0500\n@@ -688,7 +688,6 @@\n     if (!inliningLowersCost(fs)) {\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n-        fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 691, 
          "faulty": "fs.setRemove(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1484/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:20:40.388743402 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1876/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:25:10.628831407 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1876/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:25:10.628831407 -0500\n@@ -498,9 +498,6 @@\n           t, fs, callNode, module, mode);\n       if (!referenceAdded &&\n           mode == InliningMode.DIRECT && blockFunctionInliningEnabled) {\n-        // This reference can not be directly inlined, see if\n-        // block replacement inlining is possible.\n-        mode = InliningMode.BLOCK;\n         referenceAdded = maybeAddReferenceUsingMode(\n             t, fs, callNode, module, mode);\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 503, 
          "faulty": "mode=InliningMode.BLOCK;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2727/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:33:29.156337904 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_651/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:12:44.413943439 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_481/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:10:55.492446621 -0500\n@@ -199,7 +199,6 @@\n       if (nameNode != null) {\n         // This is a named break or continue;\n         String name = nameNode.getString();\n-        Preconditions.checkState(name.length() != 0);\n         LabelInfo li = getLabelInfo(name);\n         if (li != null) {\n           String newName = getNameForId(li.id);\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_481/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:10:55.492446621 -0500\n@@ -727,9 +727,6 @@\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 202, 
          "faulty": "Preconditions.checkState(name.length() != 0);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1759/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:23:53.559657237 -0500\n@@ -201,16 +201,6 @@\n         String name = nameNode.getString();\n         Preconditions.checkState(name.length() != 0);\n         LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n       }\n     }\n \n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1759/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:23:53.559657237 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 08:57:38.089845892 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1759/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 09:23:53.563657298 -0500\n@@ -106,7 +106,6 @@\n \n   void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n-      return;\n     }\n \n     int type = n.getType();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CodeGenerator.java", 
          "line": 109, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 204, 
          "faulty": "if (li != null) {\n  String newName=getNameForId(li.id);\n  li.referenced=true;\n  if (!name.equals(newName)) {\n    nameNode.setString(newName);\n    compiler.reportCodeChange();\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2190/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:28:11.803529680 -0500\n@@ -201,16 +201,6 @@\n         String name = nameNode.getString();\n         Preconditions.checkState(name.length() != 0);\n         LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n       }\n     }\n \n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2190/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:28:11.807529739 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2190/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:28:11.807529739 -0500\n@@ -756,8 +756,6 @@\n           // For functions that can no longer be removed, check if they should\n           // still be inlined.\n           if (!mimimizeCost(fsCalled)) {\n-            // It can't be inlined remove it from the list.\n-            fsCalled.setInline(false);\n           }\n         }\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 760, 
          "faulty": "fsCalled.setInline(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 204, 
          "faulty": "if (li != null) {\n  String newName=getNameForId(li.id);\n  li.referenced=true;\n  if (!name.equals(newName)) {\n    nameNode.setString(newName);\n    compiler.reportCodeChange();\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1799/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:24:13.787967457 -0500\n@@ -201,16 +201,6 @@\n         String name = nameNode.getString();\n         Preconditions.checkState(name.length() != 0);\n         LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n       }\n     }\n \n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1799/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:24:13.787967457 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 207, 
          "faulty": "li.referenced=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 204, 
          "faulty": "if (li != null) {\n  String newName=getNameForId(li.id);\n  li.referenced=true;\n  if (!name.equals(newName)) {\n    nameNode.setString(newName);\n    compiler.reportCodeChange();\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3304/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:39:13.229439881 -0500\n@@ -727,9 +727,6 @@\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2510/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:31:33.550606673 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2510/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:31:33.550606673 -0500\n@@ -691,7 +691,6 @@\n         fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n-          return false;\n         }\n       } else {\n         return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 694, 
          "faulty": "return false;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_319/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:09:00.534891525 -0500\n@@ -185,7 +185,7 @@\n \n         case Token.BREAK:\n         case Token.CONTINUE:\n-          visitBreakOrContinue(node);\n+          ;\n           break;\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_319/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:09:00.538891579 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_319/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:09:00.538891579 -0500\n@@ -498,9 +498,6 @@\n           t, fs, callNode, module, mode);\n       if (!referenceAdded &&\n           mode == InliningMode.DIRECT && blockFunctionInliningEnabled) {\n-        // This reference can not be directly inlined, see if\n-        // block replacement inlining is possible.\n-        mode = InliningMode.BLOCK;\n         referenceAdded = maybeAddReferenceUsingMode(\n             t, fs, callNode, module, mode);\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 188, 
          "faulty": "visitBreakOrContinue(node);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 503, 
          "faulty": "mode=InliningMode.BLOCK;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 731, 
          "faulty": "return CanInlineResult.NO;", 
          "type": "Delete", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1090/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:16:47.197382073 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1210/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:17:54.862362536 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2460/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:31:02.258132952 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2214/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:28:34.511863652 -0500\n@@ -203,8 +203,6 @@\n         LabelInfo li = getLabelInfo(name);\n         if (li != null) {\n           String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n           if (!name.equals(newName)) {\n             // Give it the short name.\n             nameNode.setString(newName);\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2214/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:28:34.511863652 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 207, 
          "faulty": "li.referenced=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2766/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:33:49.136634696 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 08:57:38.089845892 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2766/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 09:33:49.136634696 -0500\n@@ -106,7 +106,6 @@\n \n   void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n-      return;\n     }\n \n     int type = n.getType();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CodeGenerator.java", 
          "line": 109, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1869/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:25:01.532693853 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1337/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:19:06.227391555 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1337/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:19:06.231391612 -0500\n@@ -688,7 +688,6 @@\n     if (!inliningLowersCost(fs)) {\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n-        fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 691, 
          "faulty": "fs.setRemove(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_116/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:06:26.852877826 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:57:38.329845888 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_116/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:06:26.856877877 -0500\n@@ -1456,7 +1456,7 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        parent = null;\n       }\n     }\n     return res;\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 08:57:38.089845892 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_116/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 09:06:26.856877877 -0500\n@@ -106,7 +106,6 @@\n \n   void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n-      return;\n     }\n \n     int type = n.getType();\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_116/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:06:26.856877877 -0500\n@@ -688,7 +688,6 @@\n     if (!inliningLowersCost(fs)) {\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n-        fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CodeGenerator.java", 
          "line": 109, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 691, 
          "faulty": "fs.setRemove(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1459, 
          "faulty": "return res;", 
          "type": "Replace", 
          "seed": "parent=null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_479/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:10:54.492432968 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_636/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:12:36.381832480 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_636/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:12:36.381832480 -0500\n@@ -894,7 +894,8 @@\n     public boolean hasBlockInliningReferences() {\n       for (Reference r : getReferencesInternal().values()) {\n         if (r.mode == InliningMode.BLOCK) {\n-          return true;\n+          this.module = null;\n+\t\treturn true;\n         }\n       }\n       return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 897, 
          "faulty": "return true;", 
          "type": "InsertBefore", 
          "seed": "this.module=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_388/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:09:44.843487164 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_388/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:09:44.847487218 -0500\n@@ -688,7 +688,6 @@\n     if (!inliningLowersCost(fs)) {\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n-        fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 691, 
          "faulty": "fs.setRemove(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1887/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:25:16.376918203 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1887/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:25:16.380918263 -0500\n@@ -688,7 +688,6 @@\n     if (!inliningLowersCost(fs)) {\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n-        fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 691, 
          "faulty": "fs.setRemove(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1443/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:20:08.864291436 -0500\n@@ -205,11 +205,6 @@\n           String newName = getNameForId(li.id);\n           // Mark the label as referenced so it isn't removed.\n           li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n         }\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1443/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:20:08.864291436 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 208, 
          "faulty": "if (!name.equals(newName)) {\n  nameNode.setString(newName);\n  compiler.reportCodeChange();\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2874/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:34:53.137581701 -0500\n@@ -203,8 +203,6 @@\n         LabelInfo li = getLabelInfo(name);\n         if (li != null) {\n           String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n           if (!name.equals(newName)) {\n             // Give it the short name.\n             nameNode.setString(newName);\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2874/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:34:53.141581760 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 207, 
          "faulty": "li.referenced=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3109/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:37:14.279681884 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1104/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:16:53.869478997 -0500\n@@ -205,11 +205,6 @@\n           String newName = getNameForId(li.id);\n           // Mark the label as referenced so it isn't removed.\n           li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n         }\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1104/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:16:53.869478997 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 208, 
          "faulty": "if (!name.equals(newName)) {\n  nameNode.setString(newName);\n  compiler.reportCodeChange();\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_914/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:15:03.375873718 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_914/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:15:03.375873718 -0500\n@@ -501,8 +501,6 @@\n         // This reference can not be directly inlined, see if\n         // block replacement inlining is possible.\n         mode = InliningMode.BLOCK;\n-        referenceAdded = maybeAddReferenceUsingMode(\n-            t, fs, callNode, module, mode);\n       }\n \n       if (!referenceAdded) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 504, 
          "faulty": "referenceAdded=maybeAddReferenceUsingMode(t,fs,callNode,module,mode);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_764/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:13:44.702778645 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3090/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:37:03.743525405 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3090/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:37:03.747525464 -0500\n@@ -742,7 +742,6 @@\n   private void resolveInlineConflictsForFunction(FunctionState fs) {\n     // Functions that aren't referenced don't cause conflicts.\n     if (!fs.hasReferences() || !fs.canInline()) {\n-      return;\n     }\n \n     Node fnNode = fs.getFn().getFunctionNode();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 745, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3228/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:38:27.444764889 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3228/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:38:27.444764889 -0500\n@@ -690,9 +690,7 @@\n       if (fs.hasBlockInliningReferences()) {\n         fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n-        if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n-          return false;\n-        }\n+        return false;\n       } else {\n         return false;\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 693, 
          "faulty": "if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3139/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:37:30.147917287 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_502/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:11:06.268593858 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2672/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:32:55.943843150 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2095/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:27:06.518565083 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1100/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:16:51.969451403 -0500\n@@ -185,7 +185,7 @@\n \n         case Token.BREAK:\n         case Token.CONTINUE:\n-          visitBreakOrContinue(node);\n+          ;\n           break;\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1100/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:16:51.969451403 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 188, 
          "faulty": "visitBreakOrContinue(node);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2959/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:35:42.786317633 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_554/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:11:41.885081931 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2255/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:28:55.772186439 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1552/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:21:32.049482946 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1552/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:21:32.049482946 -0500\n@@ -742,7 +742,6 @@\n   private void resolveInlineConflictsForFunction(FunctionState fs) {\n     // Functions that aren't referenced don't cause conflicts.\n     if (!fs.hasReferences() || !fs.canInline()) {\n-      return;\n     }\n \n     Node fnNode = fs.getFn().getFunctionNode();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 745, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_427/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:10:11.767851533 -0500\n@@ -206,8 +206,6 @@\n           // Mark the label as referenced so it isn't removed.\n           li.referenced = true;\n           if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n             compiler.reportCodeChange();\n           }\n         }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_427/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:10:11.771851587 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 210, 
          "faulty": "nameNode.setString(newName);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1533/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:21:22.513346527 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1533/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:21:22.513346527 -0500\n@@ -886,7 +886,7 @@\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n         if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n+          this.module = null;\n         }\n       }\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 889, 
          "faulty": "i.remove();", 
          "type": "Replace", 
          "seed": "this.module=null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3072/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:36:54.003380611 -0500\n@@ -201,16 +201,6 @@\n         String name = nameNode.getString();\n         Preconditions.checkState(name.length() != 0);\n         LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n       }\n     }\n \n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3072/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:36:54.007380670 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 204, 
          "faulty": "if (li != null) {\n  String newName=getNameForId(li.id);\n  li.referenced=true;\n  if (!name.equals(newName)) {\n    nameNode.setString(newName);\n    compiler.reportCodeChange();\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_721/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:13:21.486456556 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_266/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:08:24.046405305 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_303/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:08:50.662759566 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1542/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:21:27.257414398 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2615/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:32:28.111427034 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:57:38.329845888 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2615/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:32:28.111427034 -0500\n@@ -1456,7 +1456,8 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        sourcePosition = -1;\n+\t\treturn res;\n       }\n     }\n     return res;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1459, 
          "faulty": "return res;", 
          "type": "InsertBefore", 
          "seed": "sourcePosition=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_784/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:13:55.486928438 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_784/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:13:55.486928438 -0500\n@@ -756,8 +756,6 @@\n           // For functions that can no longer be removed, check if they should\n           // still be inlined.\n           if (!mimimizeCost(fsCalled)) {\n-            // It can't be inlined remove it from the list.\n-            fsCalled.setInline(false);\n           }\n         }\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 760, 
          "faulty": "fsCalled.setInline(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_124/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:06:33.548963408 -0500\n@@ -201,16 +201,6 @@\n         String name = nameNode.getString();\n         Preconditions.checkState(name.length() != 0);\n         LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n       }\n     }\n \n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_124/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:06:33.548963408 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 204, 
          "faulty": "if (li != null) {\n  String newName=getNameForId(li.id);\n  li.referenced=true;\n  if (!name.equals(newName)) {\n    nameNode.setString(newName);\n    compiler.reportCodeChange();\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1092/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:16:48.169396197 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3055/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:36:44.607240817 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3113/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:37:16.275711512 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3113/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:37:16.279711572 -0500\n@@ -498,9 +498,6 @@\n           t, fs, callNode, module, mode);\n       if (!referenceAdded &&\n           mode == InliningMode.DIRECT && blockFunctionInliningEnabled) {\n-        // This reference can not be directly inlined, see if\n-        // block replacement inlining is possible.\n-        mode = InliningMode.BLOCK;\n         referenceAdded = maybeAddReferenceUsingMode(\n             t, fs, callNode, module, mode);\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 503, 
          "faulty": "mode=InliningMode.BLOCK;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3274/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:38:51.665122192 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3274/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:38:51.665122192 -0500\n@@ -885,9 +885,7 @@\n       Iterator<Entry<Node, Reference>> i;\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n-        if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n-        }\n+        this.module = null;\n       }\n     }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 888, 
          "faulty": "if (entry.getValue().mode == InliningMode.BLOCK) {\n  i.remove();\n}", 
          "type": "Replace", 
          "seed": "this.module=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1990/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:26:11.441745115 -0500\n@@ -727,9 +727,6 @@\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1588/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:22:01.989912737 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\t2018-12-01 08:57:38.101845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1588/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\t2018-12-01 09:22:01.989912737 -0500\n@@ -63,10 +63,6 @@\n     if (node.isName()) {\n       Node replacementTemplate = replacements.get(node.getString());\n       if (replacementTemplate != null) {\n-        // This should not be replacing declared names.\n-        Preconditions.checkState(!parent.isFunction()\n-            || !parent.isVar()\n-            || !parent.isCatch());\n         // The name may need to be replaced more than once,\n         // so we need to clone the node.\n         Node replacement = replacementTemplate.cloneTree();\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1588/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:22:01.989912737 -0500\n@@ -498,9 +498,6 @@\n           t, fs, callNode, module, mode);\n       if (!referenceAdded &&\n           mode == InliningMode.DIRECT && blockFunctionInliningEnabled) {\n-        // This reference can not be directly inlined, see if\n-        // block replacement inlining is possible.\n-        mode = InliningMode.BLOCK;\n         referenceAdded = maybeAddReferenceUsingMode(\n             t, fs, callNode, module, mode);\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 503, 
          "faulty": "mode=InliningMode.BLOCK;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionArgumentInjector.java", 
          "line": 67, 
          "faulty": "Preconditions.checkState(!parent.isFunction() || !parent.isVar() || !parent.isCatch());", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2758/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:33:45.296577701 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2758/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:33:45.296577701 -0500\n@@ -688,7 +688,6 @@\n     if (!inliningLowersCost(fs)) {\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n-        fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 691, 
          "faulty": "fs.setRemove(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2413/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:30:36.357738812 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1393/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:19:41.939904949 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1978/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:26:04.729644731 -0500\n@@ -199,7 +199,6 @@\n       if (nameNode != null) {\n         // This is a named break or continue;\n         String name = nameNode.getString();\n-        Preconditions.checkState(name.length() != 0);\n         LabelInfo li = getLabelInfo(name);\n         if (li != null) {\n           String newName = getNameForId(li.id);\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1978/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:26:04.733644792 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 202, 
          "faulty": "Preconditions.checkState(name.length() != 0);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2708/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:33:19.488194069 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_142/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:06:45.293114066 -0500\n@@ -728,7 +728,6 @@\n       if (fnParam != null) {\n         if (cArg != null) {\n           if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n           }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_142/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:06:45.293114066 -0500\n@@ -884,7 +884,8 @@\n     void removeBlockInliningReferences() {\n       Iterator<Entry<Node, Reference>> i;\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n-        Entry<Node, Reference> entry = i.next();\n+        this.module = null;\n+\t\tEntry<Node, Reference> entry = i.next();\n         if (entry.getValue().mode == InliningMode.BLOCK) {\n           i.remove();\n         }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 887, 
          "faulty": "Entry<Node,Reference> entry=i.next();", 
          "type": "InsertBefore", 
          "seed": "this.module=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 731, 
          "faulty": "return CanInlineResult.NO;", 
          "type": "Delete", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1124/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:17:04.601634781 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1969/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:25:59.881572158 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1969/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:25:59.885572219 -0500\n@@ -742,7 +742,6 @@\n   private void resolveInlineConflictsForFunction(FunctionState fs) {\n     // Functions that aren't referenced don't cause conflicts.\n     if (!fs.hasReferences() || !fs.canInline()) {\n-      return;\n     }\n \n     Node fnNode = fs.getFn().getFunctionNode();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 745, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1512/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:21:11.029182187 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_337/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:09:12.263048665 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_747/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:13:35.046644616 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2723/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:33:27.232309292 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2287/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:29:11.968439090 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_867/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:14:38.875532150 -0500\n@@ -727,9 +727,6 @@\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 731, 
          "faulty": "return CanInlineResult.NO;", 
          "type": "Delete", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2961/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:35:43.754332139 -0500\n@@ -727,9 +727,6 @@\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1709/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:23:16.423083335 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 08:57:38.089845892 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1709/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 09:23:16.423083335 -0500\n@@ -106,7 +106,6 @@\n \n   void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n-      return;\n     }\n \n     int type = n.getType();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CodeGenerator.java", 
          "line": 109, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_947/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:15:26.224200598 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3312/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:39:17.081496589 -0500\n@@ -185,7 +185,7 @@\n \n         case Token.BREAK:\n         case Token.CONTINUE:\n-          visitBreakOrContinue(node);\n+          ;\n           break;\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3312/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:39:17.081496589 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 188, 
          "faulty": "visitBreakOrContinue(node);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2792/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:34:02.172828024 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2737/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:33:34.112411579 -0500\n@@ -201,16 +201,6 @@\n         String name = nameNode.getString();\n         Preconditions.checkState(name.length() != 0);\n         LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n       }\n     }\n \n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2737/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:33:34.112411579 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2737/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:33:34.116411638 -0500\n@@ -885,9 +885,6 @@\n       Iterator<Entry<Node, Reference>> i;\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n-        if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n-        }\n       }\n     }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 888, 
          "faulty": "if (entry.getValue().mode == InliningMode.BLOCK) {\n  i.remove();\n}", 
          "type": "Delete", 
          "seed": "this.module=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 204, 
          "faulty": "if (li != null) {\n  String newName=getNameForId(li.id);\n  li.referenced=true;\n  if (!name.equals(newName)) {\n    nameNode.setString(newName);\n    compiler.reportCodeChange();\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_525/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:11:24.248839987 -0500\n@@ -185,7 +185,7 @@\n \n         case Token.BREAK:\n         case Token.CONTINUE:\n-          visitBreakOrContinue(node);\n+          ;\n           break;\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_525/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:11:24.252840041 -0500\n@@ -727,9 +727,6 @@\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 188, 
          "faulty": "visitBreakOrContinue(node);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1264/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:18:22.734764973 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 08:57:38.089845892 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1264/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 09:18:22.738765031 -0500\n@@ -106,7 +106,6 @@\n \n   void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n-      return;\n     }\n \n     int type = n.getType();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CodeGenerator.java", 
          "line": 109, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1527/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:21:19.661305719 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1527/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:21:19.665305777 -0500\n@@ -690,9 +690,6 @@\n       if (fs.hasBlockInliningReferences()) {\n         fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n-        if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n-          return false;\n-        }\n       } else {\n         return false;\n       }\n@@ -742,7 +739,6 @@\n   private void resolveInlineConflictsForFunction(FunctionState fs) {\n     // Functions that aren't referenced don't cause conflicts.\n     if (!fs.hasReferences() || !fs.canInline()) {\n-      return;\n     }\n \n     Node fnNode = fs.getFn().getFunctionNode();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 745, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 693, 
          "faulty": "if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1586/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:22:01.017897247 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:57:38.329845888 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1586/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:22:01.021897310 -0500\n@@ -1427,11 +1427,7 @@\n   public String checkTreeEquals(Node node2) {\n       NodeMismatch diff = checkTreeEqualsImpl(node2);\n       if (diff != null) {\n-        return \"Node tree inequality:\" +\n-            \"\\nTree1:\\n\" + toStringTree() +\n-            \"\\n\\nTree2:\\n\" + node2.toStringTree() +\n-            \"\\n\\nSubtree1: \" + diff.nodeA.toStringTree() +\n-            \"\\n\\nSubtree2: \" + diff.nodeB.toStringTree();\n+        return \"SCRIPT\";\n       }\n       return null;\n   }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1430, 
          "faulty": "return \"Node tree inequality:\" + \"\\nTree1:\\n\" + toStringTree() + \"\\n\\nTree2:\\n\"+ node2.toStringTree()+ \"\\n\\nSubtree1: \"+ diff.nodeA.toStringTree()+ \"\\n\\nSubtree2: \"+ diff.nodeB.toStringTree();", 
          "type": "Replace", 
          "seed": "return \"SCRIPT\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2203/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:28:23.647703962 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1191/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:17:45.178222530 -0500\n@@ -727,9 +727,6 @@\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1191/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:17:45.178222530 -0500\n@@ -501,8 +501,6 @@\n         // This reference can not be directly inlined, see if\n         // block replacement inlining is possible.\n         mode = InliningMode.BLOCK;\n-        referenceAdded = maybeAddReferenceUsingMode(\n-            t, fs, callNode, module, mode);\n       }\n \n       if (!referenceAdded) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 504, 
          "faulty": "referenceAdded=maybeAddReferenceUsingMode(t,fs,callNode,module,mode);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2613/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:32:27.107411995 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 08:57:38.089845892 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2613/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 09:32:27.111412055 -0500\n@@ -106,7 +106,6 @@\n \n   void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n-      return;\n     }\n \n     int type = n.getType();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CodeGenerator.java", 
          "line": 109, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1391/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:19:40.967890988 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1391/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:19:40.971891045 -0500\n@@ -756,8 +756,6 @@\n           // For functions that can no longer be removed, check if they should\n           // still be inlined.\n           if (!mimimizeCost(fsCalled)) {\n-            // It can't be inlined remove it from the list.\n-            fsCalled.setInline(false);\n           }\n         }\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 760, 
          "faulty": "fsCalled.setInline(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2111/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:27:20.298769293 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_422/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:10:08.811811447 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_182/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:07:22.665597925 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_182/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:07:22.669597976 -0500\n@@ -883,12 +883,6 @@\n \n     void removeBlockInliningReferences() {\n       Iterator<Entry<Node, Reference>> i;\n-      for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n-        Entry<Node, Reference> entry = i.next();\n-        if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n-        }\n-      }\n     }\n \n     public boolean hasBlockInliningReferences() {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 886, 
          "faulty": "for (i=getReferencesInternal().entrySet().iterator(); i.hasNext(); ) {\n  Entry<Node,Reference> entry=i.next();\n  if (entry.getValue().mode == InliningMode.BLOCK) {\n    i.remove();\n  }\n}", 
          "type": "Delete", 
          "seed": "this.module=null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:57:38.329845888 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2218/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:28:36.447892092 -0500\n@@ -1443,7 +1443,9 @@\n    */\n   NodeMismatch checkTreeEqualsImpl(Node node2) {\n     if (!isEquivalentTo(node2, false, false, false)) {\n-      return new NodeMismatch(this, node2);\n+      if (!isEquivalentTo(node2, false, false, false)) {\n+\t\treturn new NodeMismatch(this, node2);\n+\t}\n     }\n \n     NodeMismatch res = null;\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2218/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:28:36.451892151 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1446, 
          "faulty": "return new NodeMismatch(this,node2);", 
          "type": "Replace", 
          "seed": "if (!isEquivalentTo(node2,false,false,false)) {\n  return new NodeMismatch(this,node2);\n}"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2229/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:28:42.183976327 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_695/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:13:08.862281652 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3044/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:36:32.503060540 -0500\n@@ -727,9 +727,6 @@\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2371/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:30:09.157322661 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2371/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:30:09.161322723 -0500\n@@ -883,7 +883,8 @@\n \n     void removeBlockInliningReferences() {\n       Iterator<Entry<Node, Reference>> i;\n-      for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n+      this.module = null;\n+\tfor (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n         if (entry.getValue().mode == InliningMode.BLOCK) {\n           i.remove();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 886, 
          "faulty": "for (i=getReferencesInternal().entrySet().iterator(); i.hasNext(); ) {\n  Entry<Node,Reference> entry=i.next();\n  if (entry.getValue().mode == InliningMode.BLOCK) {\n    i.remove();\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "this.module=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 731, 
          "faulty": "return CanInlineResult.NO;", 
          "type": "Replace", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_677/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:12:59.038145663 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3046/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:36:34.247086528 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:57:38.329845888 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3046/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:36:34.251086589 -0500\n@@ -1456,7 +1456,8 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        parent = null;\n+\t\treturn res;\n       }\n     }\n     return res;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1459, 
          "faulty": "return res;", 
          "type": "InsertBefore", 
          "seed": "parent=null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_910/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:15:01.451846878 -0500\n@@ -185,7 +185,7 @@\n \n         case Token.BREAK:\n         case Token.CONTINUE:\n-          visitBreakOrContinue(node);\n+          ;\n           break;\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_910/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:15:01.455846934 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 188, 
          "faulty": "visitBreakOrContinue(node);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2135/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:27:38.879044101 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1004/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:15:56.528643981 -0500\n@@ -205,11 +205,6 @@\n           String newName = getNameForId(li.id);\n           // Mark the label as referenced so it isn't removed.\n           li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n         }\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1004/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:15:56.528643981 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 208, 
          "faulty": "if (!name.equals(newName)) {\n  nameNode.setString(newName);\n  compiler.reportCodeChange();\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2745/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:33:38.548477492 -0500\n@@ -201,16 +201,6 @@\n         String name = nameNode.getString();\n         Preconditions.checkState(name.length() != 0);\n         LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n       }\n     }\n \n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2745/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:33:38.552477552 -0500\n@@ -728,7 +728,7 @@\n       if (fnParam != null) {\n         if (cArg != null) {\n           if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n+            return null;\n           }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 731, 
          "faulty": "return CanInlineResult.NO;", 
          "type": "Replace", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 204, 
          "faulty": "if (li != null) {\n  String newName=getNameForId(li.id);\n  li.referenced=true;\n  if (!name.equals(newName)) {\n    nameNode.setString(newName);\n    compiler.reportCodeChange();\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1896/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:25:21.156990309 -0500\n@@ -206,8 +206,6 @@\n           // Mark the label as referenced so it isn't removed.\n           li.referenced = true;\n           if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n             compiler.reportCodeChange();\n           }\n         }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1896/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:25:21.156990309 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 210, 
          "faulty": "nameNode.setString(newName);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_293/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:08:44.662679509 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1922/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:25:33.621178023 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 08:57:38.089845892 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1922/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 09:25:33.621178023 -0500\n@@ -106,7 +106,6 @@\n \n   void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n-      return;\n     }\n \n     int type = n.getType();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CodeGenerator.java", 
          "line": 109, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_452/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:10:29.592093646 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_452/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:10:29.596093700 -0500\n@@ -883,7 +883,8 @@\n \n     void removeBlockInliningReferences() {\n       Iterator<Entry<Node, Reference>> i;\n-      for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n+      this.module = null;\n+\tfor (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n         if (entry.getValue().mode == InliningMode.BLOCK) {\n           i.remove();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 886, 
          "faulty": "for (i=getReferencesInternal().entrySet().iterator(); i.hasNext(); ) {\n  Entry<Node,Reference> entry=i.next();\n  if (entry.getValue().mode == InliningMode.BLOCK) {\n    i.remove();\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "this.module=null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1673/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:22:52.106704139 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3096/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:37:06.611568015 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_164/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:07:11.049446844 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_164/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:07:11.049446844 -0500\n@@ -688,7 +688,6 @@\n     if (!inliningLowersCost(fs)) {\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n-        fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n@@ -885,9 +884,7 @@\n       Iterator<Entry<Node, Reference>> i;\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n-        if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n-        }\n+        this.module = null;\n       }\n     }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 888, 
          "faulty": "if (entry.getValue().mode == InliningMode.BLOCK) {\n  i.remove();\n}", 
          "type": "Replace", 
          "seed": "this.module=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 691, 
          "faulty": "fs.setRemove(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2849/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:34:39.633382309 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_780/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:13:53.574901871 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3172/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:37:51.728236947 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2862/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:34:46.365481736 -0500\n@@ -205,11 +205,6 @@\n           String newName = getNameForId(li.id);\n           // Mark the label as referenced so it isn't removed.\n           li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n         }\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2862/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:34:46.369481795 -0500\n@@ -727,9 +727,6 @@\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 208, 
          "faulty": "if (!name.equals(newName)) {\n  nameNode.setString(newName);\n  compiler.reportCodeChange();\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2300/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:29:19.640558373 -0500\n@@ -201,16 +201,6 @@\n         String name = nameNode.getString();\n         Preconditions.checkState(name.length() != 0);\n         LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n       }\n     }\n \n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2300/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:29:19.644558435 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 204, 
          "faulty": "if (li != null) {\n  String newName=getNameForId(li.id);\n  li.referenced=true;\n  if (!name.equals(newName)) {\n    nameNode.setString(newName);\n    compiler.reportCodeChange();\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1156/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:17:21.885885373 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1156/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:17:21.885885373 -0500\n@@ -886,7 +886,6 @@\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n         if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n         }\n       }\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 889, 
          "faulty": "i.remove();", 
          "type": "Delete", 
          "seed": "this.module=null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_347/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:09:17.263115777 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_347/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:09:17.263115777 -0500\n@@ -885,9 +885,6 @@\n       Iterator<Entry<Node, Reference>> i;\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n-        if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n-        }\n       }\n     }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 888, 
          "faulty": "if (entry.getValue().mode == InliningMode.BLOCK) {\n  i.remove();\n}", 
          "type": "Delete", 
          "seed": "this.module=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2216/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:28:35.459877579 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1094/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:16:49.137410262 -0500\n@@ -205,11 +205,6 @@\n           String newName = getNameForId(li.id);\n           // Mark the label as referenced so it isn't removed.\n           li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n         }\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1094/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:16:49.141410321 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1094/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:16:49.141410321 -0500\n@@ -688,7 +688,6 @@\n     if (!inliningLowersCost(fs)) {\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n-        fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n@@ -885,9 +884,7 @@\n       Iterator<Entry<Node, Reference>> i;\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n-        if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n-        }\n+        this.module = null;\n       }\n     }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 888, 
          "faulty": "if (entry.getValue().mode == InliningMode.BLOCK) {\n  i.remove();\n}", 
          "type": "Replace", 
          "seed": "this.module=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 208, 
          "faulty": "if (!name.equals(newName)) {\n  nameNode.setString(newName);\n  compiler.reportCodeChange();\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 691, 
          "faulty": "fs.setRemove(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2056/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:26:47.058276085 -0500\n@@ -196,22 +196,6 @@\n      */\n     private void visitBreakOrContinue(Node node) {\n       Node nameNode = node.getFirstChild();\n-      if (nameNode != null) {\n-        // This is a named break or continue;\n-        String name = nameNode.getString();\n-        Preconditions.checkState(name.length() != 0);\n-        LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n-      }\n     }\n \n     /**\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2056/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:26:47.062276145 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 199, 
          "faulty": "if (nameNode != null) {\n  String name=nameNode.getString();\n  Preconditions.checkState(name.length() != 0);\n  LabelInfo li=getLabelInfo(name);\n  if (li != null) {\n    String newName=getNameForId(li.id);\n    li.referenced=true;\n    if (!name.equals(newName)) {\n      nameNode.setString(newName);\n      compiler.reportCodeChange();\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2012/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:26:24.029933099 -0500\n@@ -208,7 +208,6 @@\n           if (!name.equals(newName)) {\n             // Give it the short name.\n             nameNode.setString(newName);\n-            compiler.reportCodeChange();\n           }\n         }\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2012/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:26:24.029933099 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2012/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:26:24.029933099 -0500\n@@ -498,9 +498,6 @@\n           t, fs, callNode, module, mode);\n       if (!referenceAdded &&\n           mode == InliningMode.DIRECT && blockFunctionInliningEnabled) {\n-        // This reference can not be directly inlined, see if\n-        // block replacement inlining is possible.\n-        mode = InliningMode.BLOCK;\n         referenceAdded = maybeAddReferenceUsingMode(\n             t, fs, callNode, module, mode);\n       }\n@@ -883,7 +880,8 @@\n \n     void removeBlockInliningReferences() {\n       Iterator<Entry<Node, Reference>> i;\n-      for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n+      this.module = null;\n+\tfor (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n         if (entry.getValue().mode == InliningMode.BLOCK) {\n           i.remove();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 503, 
          "faulty": "mode=InliningMode.BLOCK;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 211, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 886, 
          "faulty": "for (i=getReferencesInternal().entrySet().iterator(); i.hasNext(); ) {\n  Entry<Node,Reference> entry=i.next();\n  if (entry.getValue().mode == InliningMode.BLOCK) {\n    i.remove();\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "this.module=null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_472/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:10:45.444309526 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1797/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:24:12.835952892 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_918/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:15:05.555904131 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_918/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:15:05.555904131 -0500\n@@ -884,7 +884,8 @@\n     void removeBlockInliningReferences() {\n       Iterator<Entry<Node, Reference>> i;\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n-        Entry<Node, Reference> entry = i.next();\n+        this.module = null;\n+\t\tEntry<Node, Reference> entry = i.next();\n         if (entry.getValue().mode == InliningMode.BLOCK) {\n           i.remove();\n         }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 887, 
          "faulty": "Entry<Node,Reference> entry=i.next();", 
          "type": "InsertBefore", 
          "seed": "this.module=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 731, 
          "faulty": "return CanInlineResult.NO;", 
          "type": "Replace", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_943/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:15:24.288172217 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:57:38.329845888 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_943/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:15:24.288172217 -0500\n@@ -1456,7 +1456,7 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        parent = null;\n       }\n     }\n     return res;\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_943/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:15:24.288172217 -0500\n@@ -498,9 +498,6 @@\n           t, fs, callNode, module, mode);\n       if (!referenceAdded &&\n           mode == InliningMode.DIRECT && blockFunctionInliningEnabled) {\n-        // This reference can not be directly inlined, see if\n-        // block replacement inlining is possible.\n-        mode = InliningMode.BLOCK;\n         referenceAdded = maybeAddReferenceUsingMode(\n             t, fs, callNode, module, mode);\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 503, 
          "faulty": "mode=InliningMode.BLOCK;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1459, 
          "faulty": "return res;", 
          "type": "Replace", 
          "seed": "parent=null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_861/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:14:35.983491861 -0500\n@@ -203,8 +203,6 @@\n         LabelInfo li = getLabelInfo(name);\n         if (li != null) {\n           String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n           if (!name.equals(newName)) {\n             // Give it the short name.\n             nameNode.setString(newName);\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_861/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:14:35.987491918 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_861/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:14:35.987491918 -0500\n@@ -498,9 +498,6 @@\n           t, fs, callNode, module, mode);\n       if (!referenceAdded &&\n           mode == InliningMode.DIRECT && blockFunctionInliningEnabled) {\n-        // This reference can not be directly inlined, see if\n-        // block replacement inlining is possible.\n-        mode = InliningMode.BLOCK;\n         referenceAdded = maybeAddReferenceUsingMode(\n             t, fs, callNode, module, mode);\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 503, 
          "faulty": "mode=InliningMode.BLOCK;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 207, 
          "faulty": "li.referenced=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1185/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:17:42.318181163 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1185/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:17:42.318181163 -0500\n@@ -689,7 +689,6 @@\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n         fs.setRemove(false);\n-        fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n         }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 692, 
          "faulty": "fs.removeBlockInliningReferences();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2782/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:33:57.352756570 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionToBlockMutator.java\t2018-12-01 08:57:38.101845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2782/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionToBlockMutator.java\t2018-12-01 09:33:57.352756570 -0500\n@@ -198,7 +198,7 @@\n \n     @Override\n     public String get() {\n-        return \"JSCompiler_inline_label_\" + idSupplier.get();\n+        return null;\n     }\n   }\n \n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2782/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:33:57.356756630 -0500\n@@ -756,8 +756,6 @@\n           // For functions that can no longer be removed, check if they should\n           // still be inlined.\n           if (!mimimizeCost(fsCalled)) {\n-            // It can't be inlined remove it from the list.\n-            fsCalled.setInline(false);\n           }\n         }\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionToBlockMutator.java", 
          "line": 201, 
          "faulty": "return \"JSCompiler_inline_label_\" + idSupplier.get();", 
          "type": "Replace", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 760, 
          "faulty": "fsCalled.setInline(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2990/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:35:59.550568601 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2639/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:32:39.583598729 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_87/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:05:59.268509430 -0500\n@@ -205,11 +205,6 @@\n           String newName = getNameForId(li.id);\n           // Mark the label as referenced so it isn't removed.\n           li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n         }\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_87/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:05:59.268509430 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:57:38.329845888 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_87/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:05:59.272509486 -0500\n@@ -1456,7 +1456,8 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        parent = null;\n+\t\treturn res;\n       }\n     }\n     return res;\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_87/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:05:59.272509486 -0500\n@@ -688,7 +688,6 @@\n     if (!inliningLowersCost(fs)) {\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n-        fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 208, 
          "faulty": "if (!name.equals(newName)) {\n  nameNode.setString(newName);\n  compiler.reportCodeChange();\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 691, 
          "faulty": "fs.setRemove(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1459, 
          "faulty": "return res;", 
          "type": "InsertBefore", 
          "seed": "parent=null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1515/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:21:12.965209896 -0500\n@@ -206,8 +206,6 @@\n           // Mark the label as referenced so it isn't removed.\n           li.referenced = true;\n           if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n             compiler.reportCodeChange();\n           }\n         }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1515/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:21:12.965209896 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1515/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:21:12.965209896 -0500\n@@ -688,7 +688,6 @@\n     if (!inliningLowersCost(fs)) {\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n-        fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 210, 
          "faulty": "nameNode.setString(newName);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 691, 
          "faulty": "fs.setRemove(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2984/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:35:56.682525701 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3012/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:36:11.026740126 -0500\n@@ -727,9 +727,6 @@\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3012/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:36:11.026740126 -0500\n@@ -501,8 +501,6 @@\n         // This reference can not be directly inlined, see if\n         // block replacement inlining is possible.\n         mode = InliningMode.BLOCK;\n-        referenceAdded = maybeAddReferenceUsingMode(\n-            t, fs, callNode, module, mode);\n       }\n \n       if (!referenceAdded) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 504, 
          "faulty": "referenceAdded=maybeAddReferenceUsingMode(t,fs,callNode,module,mode);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3005/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:36:07.218683235 -0500\n@@ -727,9 +727,6 @@\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1862/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:24:52.572558109 -0500\n@@ -199,7 +199,6 @@\n       if (nameNode != null) {\n         // This is a named break or continue;\n         String name = nameNode.getString();\n-        Preconditions.checkState(name.length() != 0);\n         LabelInfo li = getLabelInfo(name);\n         if (li != null) {\n           String newName = getNameForId(li.id);\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1862/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:24:52.572558109 -0500\n@@ -727,9 +727,6 @@\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 202, 
          "faulty": "Preconditions.checkState(name.length() != 0);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1358/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:19:17.695556518 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 08:57:38.089845892 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1358/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 09:19:17.695556518 -0500\n@@ -106,7 +106,6 @@\n \n   void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n-      return;\n     }\n \n     int type = n.getType();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CodeGenerator.java", 
          "line": 109, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_516/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:11:19.308772307 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_516/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:11:19.308772307 -0500\n@@ -886,7 +886,6 @@\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n         if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n         }\n       }\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 889, 
          "faulty": "i.remove();", 
          "type": "Delete", 
          "seed": "this.module=null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2747/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:33:39.512491812 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2747/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:33:39.516491871 -0500\n@@ -690,9 +690,7 @@\n       if (fs.hasBlockInliningReferences()) {\n         fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n-        if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n-          return false;\n-        }\n+        return false;\n       } else {\n         return false;\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 694, 
          "faulty": "return false;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 693, 
          "faulty": "if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_727/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:13:24.494498256 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 08:57:38.089845892 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_727/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 09:13:24.494498256 -0500\n@@ -106,7 +106,6 @@\n \n   void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n-      return;\n     }\n \n     int type = n.getType();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CodeGenerator.java", 
          "line": 109, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 731, 
          "faulty": "return CanInlineResult.NO;", 
          "type": "Replace", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1133/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:17:09.417704642 -0500\n@@ -206,8 +206,6 @@\n           // Mark the label as referenced so it isn't removed.\n           li.referenced = true;\n           if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n             compiler.reportCodeChange();\n           }\n         }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1133/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:17:09.417704642 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 210, 
          "faulty": "nameNode.setString(newName);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3250/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:38:39.072936497 -0500\n@@ -185,7 +185,7 @@\n \n         case Token.BREAK:\n         case Token.CONTINUE:\n-          visitBreakOrContinue(node);\n+          ;\n           break;\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3250/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:38:39.072936497 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 188, 
          "faulty": "visitBreakOrContinue(node);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:04:27.407255559 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:04:27.455256209 -0500\n@@ -688,7 +688,6 @@\n     if (!inliningLowersCost(fs)) {\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n-        fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 691, 
          "faulty": "fs.setRemove(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1621/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:22:24.394268283 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_709/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:13:15.642375567 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:57:38.329845888 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_709/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:13:15.646375622 -0500\n@@ -1456,7 +1456,8 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        parent = null;\n+\t\treturn res;\n       }\n     }\n     return res;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1459, 
          "faulty": "return res;", 
          "type": "InsertBefore", 
          "seed": "parent=null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1707/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:23:15.439068045 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1462/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:20:23.528501747 -0500\n@@ -206,8 +206,6 @@\n           // Mark the label as referenced so it isn't removed.\n           li.referenced = true;\n           if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n             compiler.reportCodeChange();\n           }\n         }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1462/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:20:23.532501804 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 210, 
          "faulty": "nameNode.setString(newName);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_66/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:05:36.588198144 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_66/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:05:36.588198144 -0500\n@@ -688,7 +688,6 @@\n     if (!inliningLowersCost(fs)) {\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n-        fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 691, 
          "faulty": "fs.setRemove(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2018/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:26:26.945976594 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1900/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:25:23.073019193 -0500\n@@ -727,9 +727,6 @@\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:57:38.329845888 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1900/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:25:23.073019193 -0500\n@@ -1427,11 +1427,7 @@\n   public String checkTreeEquals(Node node2) {\n       NodeMismatch diff = checkTreeEqualsImpl(node2);\n       if (diff != null) {\n-        return \"Node tree inequality:\" +\n-            \"\\nTree1:\\n\" + toStringTree() +\n-            \"\\n\\nTree2:\\n\" + node2.toStringTree() +\n-            \"\\n\\nSubtree1: \" + diff.nodeA.toStringTree() +\n-            \"\\n\\nSubtree2: \" + diff.nodeB.toStringTree();\n+        return \"SCRIPT\";\n       }\n       return null;\n   }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1430, 
          "faulty": "return \"Node tree inequality:\" + \"\\nTree1:\\n\" + toStringTree() + \"\\n\\nTree2:\\n\"+ node2.toStringTree()+ \"\\n\\nSubtree1: \"+ diff.nodeA.toStringTree()+ \"\\n\\nSubtree2: \"+ diff.nodeB.toStringTree();", 
          "type": "Replace", 
          "seed": "return \"SCRIPT\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2383/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:30:14.937411296 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1454/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:20:19.720447145 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1454/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:20:19.724447203 -0500\n@@ -689,7 +689,6 @@\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n         fs.setRemove(false);\n-        fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n         }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 692, 
          "faulty": "fs.removeBlockInliningReferences();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1378/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:19:28.211707704 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1378/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:19:28.211707704 -0500\n@@ -688,7 +688,6 @@\n     if (!inliningLowersCost(fs)) {\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n-        fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n@@ -885,9 +884,6 @@\n       Iterator<Entry<Node, Reference>> i;\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n-        if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n-        }\n       }\n     }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 888, 
          "faulty": "if (entry.getValue().mode == InliningMode.BLOCK) {\n  i.remove();\n}", 
          "type": "Delete", 
          "seed": "this.module=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 691, 
          "faulty": "fs.setRemove(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 731, 
          "faulty": "return CanInlineResult.NO;", 
          "type": "Replace", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2920/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:35:17.125935393 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2242/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:28:49.084081765 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2242/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:28:49.084081765 -0500\n@@ -498,9 +498,6 @@\n           t, fs, callNode, module, mode);\n       if (!referenceAdded &&\n           mode == InliningMode.DIRECT && blockFunctionInliningEnabled) {\n-        // This reference can not be directly inlined, see if\n-        // block replacement inlining is possible.\n-        mode = InliningMode.BLOCK;\n         referenceAdded = maybeAddReferenceUsingMode(\n             t, fs, callNode, module, mode);\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 503, 
          "faulty": "mode=InliningMode.BLOCK;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1345/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:19:11.027460613 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 08:57:38.089845892 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1345/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 09:19:11.027460613 -0500\n@@ -106,7 +106,6 @@\n \n   void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n-      return;\n     }\n \n     int type = n.getType();\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1345/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:19:11.031460671 -0500\n@@ -883,11 +883,10 @@\n \n     void removeBlockInliningReferences() {\n       Iterator<Entry<Node, Reference>> i;\n-      for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n+      this.module = null;\n+\tfor (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n-        if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n-        }\n+        this.module = null;\n       }\n     }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 888, 
          "faulty": "if (entry.getValue().mode == InliningMode.BLOCK) {\n  i.remove();\n}", 
          "type": "Replace", 
          "seed": "this.module=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CodeGenerator.java", 
          "line": 109, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 886, 
          "faulty": "for (i=getReferencesInternal().entrySet().iterator(); i.hasNext(); ) {\n  Entry<Node,Reference> entry=i.next();\n  if (entry.getValue().mode == InliningMode.BLOCK) {\n    i.remove();\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "this.module=null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1113/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:16:58.729549562 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1113/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:16:58.733549620 -0500\n@@ -501,8 +501,6 @@\n         // This reference can not be directly inlined, see if\n         // block replacement inlining is possible.\n         mode = InliningMode.BLOCK;\n-        referenceAdded = maybeAddReferenceUsingMode(\n-            t, fs, callNode, module, mode);\n       }\n \n       if (!referenceAdded) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 504, 
          "faulty": "referenceAdded=maybeAddReferenceUsingMode(t,fs,callNode,module,mode);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1031/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:16:11.008855303 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_444/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:10:25.692040612 -0500\n@@ -727,9 +727,6 @@\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_960/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:15:33.300304270 -0500\n@@ -201,16 +201,6 @@\n         String name = nameNode.getString();\n         Preconditions.checkState(name.length() != 0);\n         LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n       }\n     }\n \n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_960/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:15:33.300304270 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_960/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:15:33.300304270 -0500\n@@ -501,8 +501,6 @@\n         // This reference can not be directly inlined, see if\n         // block replacement inlining is possible.\n         mode = InliningMode.BLOCK;\n-        referenceAdded = maybeAddReferenceUsingMode(\n-            t, fs, callNode, module, mode);\n       }\n \n       if (!referenceAdded) {\n@@ -690,9 +688,6 @@\n       if (fs.hasBlockInliningReferences()) {\n         fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n-        if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n-          return false;\n-        }\n       } else {\n         return false;\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 504, 
          "faulty": "referenceAdded=maybeAddReferenceUsingMode(t,fs,callNode,module,mode);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 693, 
          "faulty": "if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 204, 
          "faulty": "if (li != null) {\n  String newName=getNameForId(li.id);\n  li.referenced=true;\n  if (!name.equals(newName)) {\n    nameNode.setString(newName);\n    compiler.reportCodeChange();\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1885/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:25:15.420903774 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2381/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:30:13.981396644 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:57:38.329845888 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2381/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:30:13.985396705 -0500\n@@ -1456,7 +1456,9 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        Preconditions.checkState(this.propListHead == null,\n+\t\t\t\t\"Node has existing properties.\");\n+\t\treturn res;\n       }\n     }\n     return res;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1459, 
          "faulty": "return res;", 
          "type": "InsertBefore", 
          "seed": "Preconditions.checkState(this.propListHead == null,\"Node has existing properties.\");"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2466/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:31:05.174177207 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 08:57:38.089845892 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2466/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 09:31:05.178177267 -0500\n@@ -106,7 +106,6 @@\n \n   void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n-      return;\n     }\n \n     int type = n.getType();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CodeGenerator.java", 
          "line": 109, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_512/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:11:17.336745302 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2356/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:29:50.281032391 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\t2018-12-01 08:57:38.101845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2356/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\t2018-12-01 09:29:50.285032452 -0500\n@@ -63,10 +63,6 @@\n     if (node.isName()) {\n       Node replacementTemplate = replacements.get(node.getString());\n       if (replacementTemplate != null) {\n-        // This should not be replacing declared names.\n-        Preconditions.checkState(!parent.isFunction()\n-            || !parent.isVar()\n-            || !parent.isCatch());\n         // The name may need to be replaced more than once,\n         // so we need to clone the node.\n         Node replacement = replacementTemplate.cloneTree();\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2356/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:29:50.285032452 -0500\n@@ -756,8 +756,6 @@\n           // For functions that can no longer be removed, check if they should\n           // still be inlined.\n           if (!mimimizeCost(fsCalled)) {\n-            // It can't be inlined remove it from the list.\n-            fsCalled.setInline(false);\n           }\n         }\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 760, 
          "faulty": "fsCalled.setInline(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionArgumentInjector.java", 
          "line": 67, 
          "faulty": "Preconditions.checkState(!parent.isFunction() || !parent.isVar() || !parent.isCatch());", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1562/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:21:48.049711748 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1742/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:23:38.827430276 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3252/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:38:40.028950600 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3252/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:38:40.028950600 -0500\n@@ -886,7 +886,8 @@\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n         if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n+          this.module = null;\n+\t\ti.remove();\n         }\n       }\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 889, 
          "faulty": "i.remove();", 
          "type": "InsertBefore", 
          "seed": "this.module=null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_951/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:15:28.136228620 -0500\n@@ -727,9 +727,6 @@\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_697/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:13:09.814294836 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_594/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:12:07.681436688 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_360/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:09:24.079207374 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_360/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:09:24.079207374 -0500\n@@ -756,8 +756,6 @@\n           // For functions that can no longer be removed, check if they should\n           // still be inlined.\n           if (!mimimizeCost(fsCalled)) {\n-            // It can't be inlined remove it from the list.\n-            fsCalled.setInline(false);\n           }\n         }\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 760, 
          "faulty": "fsCalled.setInline(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1318/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:18:55.735240542 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1920/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:25:32.657163520 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2799/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:34:06.060885640 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2799/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:34:06.060885640 -0500\n@@ -742,7 +742,6 @@\n   private void resolveInlineConflictsForFunction(FunctionState fs) {\n     // Functions that aren't referenced don't cause conflicts.\n     if (!fs.hasReferences() || !fs.canInline()) {\n-      return;\n     }\n \n     Node fnNode = fs.getFn().getFunctionNode();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 745, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1974/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:26:02.797615817 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3221/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:38:18.392631208 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3221/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:38:18.400631326 -0500\n@@ -498,9 +498,6 @@\n           t, fs, callNode, module, mode);\n       if (!referenceAdded &&\n           mode == InliningMode.DIRECT && blockFunctionInliningEnabled) {\n-        // This reference can not be directly inlined, see if\n-        // block replacement inlining is possible.\n-        mode = InliningMode.BLOCK;\n         referenceAdded = maybeAddReferenceUsingMode(\n             t, fs, callNode, module, mode);\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 503, 
          "faulty": "mode=InliningMode.BLOCK;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_869/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:14:39.827545414 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_489/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:10:59.460500813 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2841/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:34:35.789325512 -0500\n@@ -199,7 +199,6 @@\n       if (nameNode != null) {\n         // This is a named break or continue;\n         String name = nameNode.getString();\n-        Preconditions.checkState(name.length() != 0);\n         LabelInfo li = getLabelInfo(name);\n         if (li != null) {\n           String newName = getNameForId(li.id);\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2841/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:34:35.789325512 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 202, 
          "faulty": "Preconditions.checkState(name.length() != 0);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1510/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:21:10.089168732 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2711/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:33:21.472223599 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2039/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:26:37.502133891 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2192/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:28:12.767543873 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2192/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:28:12.767543873 -0500\n@@ -894,7 +894,8 @@\n     public boolean hasBlockInliningReferences() {\n       for (Reference r : getReferencesInternal().values()) {\n         if (r.mode == InliningMode.BLOCK) {\n-          return true;\n+          this.module = null;\n+\t\treturn true;\n         }\n       }\n       return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 897, 
          "faulty": "return true;", 
          "type": "InsertBefore", 
          "seed": "this.module=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_264/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:08:23.082392517 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\t2018-12-01 08:57:38.101845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_264/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\t2018-12-01 09:08:23.086392570 -0500\n@@ -63,10 +63,6 @@\n     if (node.isName()) {\n       Node replacementTemplate = replacements.get(node.getString());\n       if (replacementTemplate != null) {\n-        // This should not be replacing declared names.\n-        Preconditions.checkState(!parent.isFunction()\n-            || !parent.isVar()\n-            || !parent.isCatch());\n         // The name may need to be replaced more than once,\n         // so we need to clone the node.\n         Node replacement = replacementTemplate.cloneTree();\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_264/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:08:23.086392570 -0500\n@@ -688,7 +688,6 @@\n     if (!inliningLowersCost(fs)) {\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n-        fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 691, 
          "faulty": "fs.setRemove(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionArgumentInjector.java", 
          "line": 67, 
          "faulty": "Preconditions.checkState(!parent.isFunction() || !parent.isVar() || !parent.isCatch());", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1774/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:24:01.319776433 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1774/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:24:01.319776433 -0500\n@@ -498,9 +498,6 @@\n           t, fs, callNode, module, mode);\n       if (!referenceAdded &&\n           mode == InliningMode.DIRECT && blockFunctionInliningEnabled) {\n-        // This reference can not be directly inlined, see if\n-        // block replacement inlining is possible.\n-        mode = InliningMode.BLOCK;\n         referenceAdded = maybeAddReferenceUsingMode(\n             t, fs, callNode, module, mode);\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 503, 
          "faulty": "mode=InliningMode.BLOCK;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_649/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:12:43.397929399 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2323/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:29:31.160737026 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2323/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:29:31.160737026 -0500\n@@ -688,7 +688,6 @@\n     if (!inliningLowersCost(fs)) {\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n-        fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 691, 
          "faulty": "fs.setRemove(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_159/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:07:07.273397863 -0500\n@@ -185,7 +185,7 @@\n \n         case Token.BREAK:\n         case Token.CONTINUE:\n-          visitBreakOrContinue(node);\n+          ;\n           break;\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_159/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:07:07.273397863 -0500\n@@ -728,7 +728,6 @@\n       if (fnParam != null) {\n         if (cArg != null) {\n           if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n           }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_159/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:07:07.273397863 -0500\n@@ -501,8 +501,6 @@\n         // This reference can not be directly inlined, see if\n         // block replacement inlining is possible.\n         mode = InliningMode.BLOCK;\n-        referenceAdded = maybeAddReferenceUsingMode(\n-            t, fs, callNode, module, mode);\n       }\n \n       if (!referenceAdded) {\n@@ -884,7 +882,8 @@\n     void removeBlockInliningReferences() {\n       Iterator<Entry<Node, Reference>> i;\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n-        Entry<Node, Reference> entry = i.next();\n+        this.module = null;\n+\t\tEntry<Node, Reference> entry = i.next();\n         if (entry.getValue().mode == InliningMode.BLOCK) {\n           i.remove();\n         }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 188, 
          "faulty": "visitBreakOrContinue(node);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 504, 
          "faulty": "referenceAdded=maybeAddReferenceUsingMode(t,fs,callNode,module,mode);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 887, 
          "faulty": "Entry<Node,Reference> entry=i.next();", 
          "type": "InsertBefore", 
          "seed": "this.module=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 731, 
          "faulty": "return CanInlineResult.NO;", 
          "type": "Delete", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1128/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:17:06.569663331 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2227/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:28:41.235962408 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_560/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:11:44.821122258 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\t2018-12-01 08:57:38.101845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_560/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\t2018-12-01 09:11:44.821122258 -0500\n@@ -63,10 +63,6 @@\n     if (node.isName()) {\n       Node replacementTemplate = replacements.get(node.getString());\n       if (replacementTemplate != null) {\n-        // This should not be replacing declared names.\n-        Preconditions.checkState(!parent.isFunction()\n-            || !parent.isVar()\n-            || !parent.isCatch());\n         // The name may need to be replaced more than once,\n         // so we need to clone the node.\n         Node replacement = replacementTemplate.cloneTree();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionArgumentInjector.java", 
          "line": 67, 
          "faulty": "Preconditions.checkState(!parent.isFunction() || !parent.isVar() || !parent.isCatch());", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2129/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:27:29.898911357 -0500\n@@ -203,13 +203,6 @@\n         LabelInfo li = getLabelInfo(name);\n         if (li != null) {\n           String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n         }\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2129/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:27:29.902911416 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 207, 
          "faulty": "li.referenced=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 208, 
          "faulty": "if (!name.equals(newName)) {\n  nameNode.setString(newName);\n  compiler.reportCodeChange();\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1972/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:26:01.845601565 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1972/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:26:01.845601565 -0500\n@@ -501,8 +501,6 @@\n         // This reference can not be directly inlined, see if\n         // block replacement inlining is possible.\n         mode = InliningMode.BLOCK;\n-        referenceAdded = maybeAddReferenceUsingMode(\n-            t, fs, callNode, module, mode);\n       }\n \n       if (!referenceAdded) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 504, 
          "faulty": "referenceAdded=maybeAddReferenceUsingMode(t,fs,callNode,module,mode);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2986/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:35:57.630539884 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2617/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:32:29.079441531 -0500\n@@ -201,16 +201,6 @@\n         String name = nameNode.getString();\n         Preconditions.checkState(name.length() != 0);\n         LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n       }\n     }\n \n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2617/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:32:29.079441531 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2617/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:32:29.079441531 -0500\n@@ -756,8 +756,6 @@\n           // For functions that can no longer be removed, check if they should\n           // still be inlined.\n           if (!mimimizeCost(fsCalled)) {\n-            // It can't be inlined remove it from the list.\n-            fsCalled.setInline(false);\n           }\n         }\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 760, 
          "faulty": "fsCalled.setInline(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 204, 
          "faulty": "if (li != null) {\n  String newName=getNameForId(li.id);\n  li.referenced=true;\n  if (!name.equals(newName)) {\n    nameNode.setString(newName);\n    compiler.reportCodeChange();\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_529/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:11:27.200880449 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2173/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:28:03.147402179 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1250/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:18:15.046654041 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2805/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:34:09.976943649 -0500\n@@ -199,12 +199,9 @@\n       if (nameNode != null) {\n         // This is a named break or continue;\n         String name = nameNode.getString();\n-        Preconditions.checkState(name.length() != 0);\n         LabelInfo li = getLabelInfo(name);\n         if (li != null) {\n           String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n           if (!name.equals(newName)) {\n             // Give it the short name.\n             nameNode.setString(newName);\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2805/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:34:09.980943707 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 207, 
          "faulty": "li.referenced=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 202, 
          "faulty": "Preconditions.checkState(name.length() != 0);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3201/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:38:07.672472788 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:57:38.329845888 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3201/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:38:07.688473025 -0500\n@@ -1456,7 +1456,9 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        Preconditions.checkState(this.propListHead == null,\n+\t\t\t\t\"Node has existing properties.\");\n+\t\treturn res;\n       }\n     }\n     return res;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1459, 
          "faulty": "return res;", 
          "type": "InsertBefore", 
          "seed": "Preconditions.checkState(this.propListHead == null,\"Node has existing properties.\");"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1342/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:19:09.087432704 -0500\n@@ -185,7 +185,7 @@\n \n         case Token.BREAK:\n         case Token.CONTINUE:\n-          visitBreakOrContinue(node);\n+          ;\n           break;\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1342/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:19:09.087432704 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 188, 
          "faulty": "visitBreakOrContinue(node);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_334/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:09:10.275022001 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1820/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:24:24.448130323 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1801/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:24:14.731981896 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1814/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:24:21.584086606 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1814/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:24:21.584086606 -0500\n@@ -688,7 +688,6 @@\n     if (!inliningLowersCost(fs)) {\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n-        fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 691, 
          "faulty": "fs.setRemove(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_949/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:15:27.192214786 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2760/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:33:46.240591715 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_284/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:08:33.730533935 -0500\n@@ -196,22 +196,6 @@\n      */\n     private void visitBreakOrContinue(Node node) {\n       Node nameNode = node.getFirstChild();\n-      if (nameNode != null) {\n-        // This is a named break or continue;\n-        String name = nameNode.getString();\n-        Preconditions.checkState(name.length() != 0);\n-        LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n-      }\n     }\n \n     /**\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_284/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:08:33.734533988 -0500\n@@ -727,9 +727,6 @@\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 199, 
          "faulty": "if (nameNode != null) {\n  String name=nameNode.getString();\n  Preconditions.checkState(name.length() != 0);\n  LabelInfo li=getLabelInfo(name);\n  if (li != null) {\n    String newName=getNameForId(li.id);\n    li.referenced=true;\n    if (!name.equals(newName)) {\n      nameNode.setString(newName);\n      compiler.reportCodeChange();\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1535/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:21:23.473360263 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1535/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:21:23.473360263 -0500\n@@ -756,8 +756,6 @@\n           // For functions that can no longer be removed, check if they should\n           // still be inlined.\n           if (!mimimizeCost(fsCalled)) {\n-            // It can't be inlined remove it from the list.\n-            fsCalled.setInline(false);\n           }\n         }\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 760, 
          "faulty": "fsCalled.setInline(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2700/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:33:09.564046269 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1419/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:19:55.328097188 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1419/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:19:55.328097188 -0500\n@@ -894,7 +894,8 @@\n     public boolean hasBlockInliningReferences() {\n       for (Reference r : getReferencesInternal().values()) {\n         if (r.mode == InliningMode.BLOCK) {\n-          return true;\n+          this.module = null;\n+\t\treturn true;\n         }\n       }\n       return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 897, 
          "faulty": "return true;", 
          "type": "InsertBefore", 
          "seed": "this.module=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1859/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:24:50.648528927 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1859/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:24:50.648528927 -0500\n@@ -886,7 +886,6 @@\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n         if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n         }\n       }\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 889, 
          "faulty": "i.remove();", 
          "type": "Delete", 
          "seed": "this.module=null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2650/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:32:45.351684960 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_740/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:13:31.246591896 -0500\n@@ -196,22 +196,6 @@\n      */\n     private void visitBreakOrContinue(Node node) {\n       Node nameNode = node.getFirstChild();\n-      if (nameNode != null) {\n-        // This is a named break or continue;\n-        String name = nameNode.getString();\n-        Preconditions.checkState(name.length() != 0);\n-        LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n-      }\n     }\n \n     /**\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_740/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:13:31.246591896 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 199, 
          "faulty": "if (nameNode != null) {\n  String name=nameNode.getString();\n  Preconditions.checkState(name.length() != 0);\n  LabelInfo li=getLabelInfo(name);\n  if (li != null) {\n    String newName=getNameForId(li.id);\n    li.referenced=true;\n    if (!name.equals(newName)) {\n      nameNode.setString(newName);\n      compiler.reportCodeChange();\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_612/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:12:17.321569506 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1607/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:22:17.682162076 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1607/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:22:17.682162076 -0500\n@@ -886,7 +886,6 @@\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n         if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n         }\n       }\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 889, 
          "faulty": "i.remove();", 
          "type": "Delete", 
          "seed": "this.module=null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2298/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:29:18.692543647 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_343/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:09:15.251088763 -0500\n@@ -206,8 +206,6 @@\n           // Mark the label as referenced so it isn't removed.\n           li.referenced = true;\n           if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n             compiler.reportCodeChange();\n           }\n         }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_343/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:09:15.255088816 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:57:38.329845888 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_343/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:09:15.287089246 -0500\n@@ -1427,11 +1427,7 @@\n   public String checkTreeEquals(Node node2) {\n       NodeMismatch diff = checkTreeEqualsImpl(node2);\n       if (diff != null) {\n-        return \"Node tree inequality:\" +\n-            \"\\nTree1:\\n\" + toStringTree() +\n-            \"\\n\\nTree2:\\n\" + node2.toStringTree() +\n-            \"\\n\\nSubtree1: \" + diff.nodeA.toStringTree() +\n-            \"\\n\\nSubtree2: \" + diff.nodeB.toStringTree();\n+        return \"SCRIPT\";\n       }\n       return null;\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_343/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:09:15.287089246 -0500\n@@ -688,7 +688,6 @@\n     if (!inliningLowersCost(fs)) {\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n-        fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 210, 
          "faulty": "nameNode.setString(newName);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 691, 
          "faulty": "fs.setRemove(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1430, 
          "faulty": "return \"Node tree inequality:\" + \"\\nTree1:\\n\" + toStringTree() + \"\\n\\nTree2:\\n\"+ node2.toStringTree()+ \"\\n\\nSubtree1: \"+ diff.nodeA.toStringTree()+ \"\\n\\nSubtree2: \"+ diff.nodeB.toStringTree();", 
          "type": "Replace", 
          "seed": "return \"SCRIPT\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1238/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:18:09.302571125 -0500\n@@ -185,7 +185,7 @@\n \n         case Token.BREAK:\n         case Token.CONTINUE:\n-          visitBreakOrContinue(node);\n+          ;\n           break;\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:57:38.329845888 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1238/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:18:09.302571125 -0500\n@@ -1443,7 +1443,8 @@\n    */\n   NodeMismatch checkTreeEqualsImpl(Node node2) {\n     if (!isEquivalentTo(node2, false, false, false)) {\n-      return new NodeMismatch(this, node2);\n+      this.sourcePosition = sourcePosition;\n+\treturn new NodeMismatch(this, node2);\n     }\n \n     NodeMismatch res = null;\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1238/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:18:09.302571125 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 188, 
          "faulty": "visitBreakOrContinue(node);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1446, 
          "faulty": "return new NodeMismatch(this,node2);", 
          "type": "InsertBefore", 
          "seed": "this.sourcePosition=sourcePosition;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2935/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:35:31.270144936 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2595/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:32:17.539268577 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_567/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:11:53.829246067 -0500\n@@ -196,22 +196,6 @@\n      */\n     private void visitBreakOrContinue(Node node) {\n       Node nameNode = node.getFirstChild();\n-      if (nameNode != null) {\n-        // This is a named break or continue;\n-        String name = nameNode.getString();\n-        Preconditions.checkState(name.length() != 0);\n-        LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n-      }\n     }\n \n     /**\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_567/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:11:53.833246121 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 199, 
          "faulty": "if (nameNode != null) {\n  String name=nameNode.getString();\n  Preconditions.checkState(name.length() != 0);\n  LabelInfo li=getLabelInfo(name);\n  if (li != null) {\n    String newName=getNameForId(li.id);\n    li.referenced=true;\n    if (!name.equals(newName)) {\n      nameNode.setString(newName);\n      compiler.reportCodeChange();\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_840/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:14:24.443331163 -0500\n@@ -208,7 +208,6 @@\n           if (!name.equals(newName)) {\n             // Give it the short name.\n             nameNode.setString(newName);\n-            compiler.reportCodeChange();\n           }\n         }\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_840/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:14:24.447331219 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 211, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2277/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:29:07.192364705 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2739/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:33:35.060425668 -0500\n@@ -727,9 +727,6 @@\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2891/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:35:01.797709461 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2268/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:29:02.468291034 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2770/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:33:51.380667993 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2770/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:33:51.380667993 -0500\n@@ -498,9 +498,6 @@\n           t, fs, callNode, module, mode);\n       if (!referenceAdded &&\n           mode == InliningMode.DIRECT && blockFunctionInliningEnabled) {\n-        // This reference can not be directly inlined, see if\n-        // block replacement inlining is possible.\n-        mode = InliningMode.BLOCK;\n         referenceAdded = maybeAddReferenceUsingMode(\n             t, fs, callNode, module, mode);\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 503, 
          "faulty": "mode=InliningMode.BLOCK;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2480/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:31:13.046296560 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 731, 
          "faulty": "return CanInlineResult.NO;", 
          "type": "Replace", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3018/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:36:13.914783256 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1027/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:16:09.064826952 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1560/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:21:47.101698195 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 731, 
          "faulty": "return CanInlineResult.NO;", 
          "type": "Replace", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3118/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:37:19.155754253 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3118/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:37:19.155754253 -0500\n@@ -498,9 +498,6 @@\n           t, fs, callNode, module, mode);\n       if (!referenceAdded &&\n           mode == InliningMode.DIRECT && blockFunctionInliningEnabled) {\n-        // This reference can not be directly inlined, see if\n-        // block replacement inlining is possible.\n-        mode = InliningMode.BLOCK;\n         referenceAdded = maybeAddReferenceUsingMode(\n             t, fs, callNode, module, mode);\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 503, 
          "faulty": "mode=InliningMode.BLOCK;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_321/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:09:01.514904640 -0500\n@@ -201,16 +201,6 @@\n         String name = nameNode.getString();\n         Preconditions.checkState(name.length() != 0);\n         LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n       }\n     }\n \n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_321/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:09:01.518904694 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 731, 
          "faulty": "return CanInlineResult.NO;", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 204, 
          "faulty": "if (li != null) {\n  String newName=getNameForId(li.id);\n  li.referenced=true;\n  if (!name.equals(newName)) {\n    nameNode.setString(newName);\n    compiler.reportCodeChange();\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_791/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:14:00.322995646 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:57:38.329845888 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_791/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:14:00.326995701 -0500\n@@ -1427,7 +1427,13 @@\n   public String checkTreeEquals(Node node2) {\n       NodeMismatch diff = checkTreeEqualsImpl(node2);\n       if (diff != null) {\n-        return \"Node tree inequality:\" +\n+        if (diff != null) {\n+\t\t\treturn \"Node tree inequality:\" + \"\\nTree1:\\n\" + toStringTree()\n+\t\t\t\t\t+ \"\\n\\nTree2:\\n\" + node2.toStringTree() + \"\\n\\nSubtree1: \"\n+\t\t\t\t\t+ diff.nodeA.toStringTree() + \"\\n\\nSubtree2: \"\n+\t\t\t\t\t+ diff.nodeB.toStringTree();\n+\t\t}\n+\t\treturn \"Node tree inequality:\" +\n             \"\\nTree1:\\n\" + toStringTree() +\n             \"\\n\\nTree2:\\n\" + node2.toStringTree() +\n             \"\\n\\nSubtree1: \" + diff.nodeA.toStringTree() +\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1430, 
          "faulty": "return \"Node tree inequality:\" + \"\\nTree1:\\n\" + toStringTree() + \"\\n\\nTree2:\\n\"+ node2.toStringTree()+ \"\\n\\nSubtree1: \"+ diff.nodeA.toStringTree()+ \"\\n\\nSubtree2: \"+ diff.nodeB.toStringTree();", 
          "type": "InsertBefore", 
          "seed": "if (diff != null) {\n  return \"Node tree inequality:\" + \"\\nTree1:\\n\" + toStringTree() + \"\\n\\nTree2:\\n\"+ node2.toStringTree()+ \"\\n\\nSubtree1: \"+ diff.nodeA.toStringTree()+ \"\\n\\nSubtree2: \"+ diff.nodeB.toStringTree();\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_939/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:15:22.348143771 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2637/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:32:38.631584491 -0500\n@@ -196,22 +196,6 @@\n      */\n     private void visitBreakOrContinue(Node node) {\n       Node nameNode = node.getFirstChild();\n-      if (nameNode != null) {\n-        // This is a named break or continue;\n-        String name = nameNode.getString();\n-        Preconditions.checkState(name.length() != 0);\n-        LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n-      }\n     }\n \n     /**\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2637/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:32:38.635584550 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 199, 
          "faulty": "if (nameNode != null) {\n  String name=nameNode.getString();\n  Preconditions.checkState(name.length() != 0);\n  LabelInfo li=getLabelInfo(name);\n  if (li != null) {\n    String newName=getNameForId(li.id);\n    li.referenced=true;\n    if (!name.equals(newName)) {\n      nameNode.setString(newName);\n      compiler.reportCodeChange();\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2633/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:32:36.731556069 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2633/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:32:36.731556069 -0500\n@@ -689,7 +689,6 @@\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n         fs.setRemove(false);\n-        fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n         }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 692, 
          "faulty": "fs.removeBlockInliningReferences();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_420/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:10:07.855798487 -0500\n@@ -203,12 +203,9 @@\n         LabelInfo li = getLabelInfo(name);\n         if (li != null) {\n           String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n           if (!name.equals(newName)) {\n             // Give it the short name.\n             nameNode.setString(newName);\n-            compiler.reportCodeChange();\n           }\n         }\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_420/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:10:07.855798487 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_420/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:10:07.859798541 -0500\n@@ -742,7 +742,6 @@\n   private void resolveInlineConflictsForFunction(FunctionState fs) {\n     // Functions that aren't referenced don't cause conflicts.\n     if (!fs.hasReferences() || !fs.canInline()) {\n-      return;\n     }\n \n     Node fnNode = fs.getFn().getFunctionNode();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 207, 
          "faulty": "li.referenced=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 745, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 211, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1670/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:22:50.194674198 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:57:38.329845888 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1670/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:22:50.194674198 -0500\n@@ -1456,7 +1456,8 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        sourcePosition = -1;\n+\t\treturn res;\n       }\n     }\n     return res;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1459, 
          "faulty": "return res;", 
          "type": "InsertBefore", 
          "seed": "sourcePosition=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1173/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:17:36.598098402 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2516/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:31:36.414649904 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\t2018-12-01 08:57:38.101845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2516/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\t2018-12-01 09:31:36.414649904 -0500\n@@ -63,10 +63,6 @@\n     if (node.isName()) {\n       Node replacementTemplate = replacements.get(node.getString());\n       if (replacementTemplate != null) {\n-        // This should not be replacing declared names.\n-        Preconditions.checkState(!parent.isFunction()\n-            || !parent.isVar()\n-            || !parent.isCatch());\n         // The name may need to be replaced more than once,\n         // so we need to clone the node.\n         Node replacement = replacementTemplate.cloneTree();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionArgumentInjector.java", 
          "line": 67, 
          "faulty": "Preconditions.checkState(!parent.isFunction() || !parent.isVar() || !parent.isCatch());", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1310/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:18:51.927185710 -0500\n@@ -208,7 +208,6 @@\n           if (!name.equals(newName)) {\n             // Give it the short name.\n             nameNode.setString(newName);\n-            compiler.reportCodeChange();\n           }\n         }\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1310/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:18:51.927185710 -0500\n@@ -728,7 +728,6 @@\n       if (fnParam != null) {\n         if (cArg != null) {\n           if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n           }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1310/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:18:51.927185710 -0500\n@@ -688,7 +688,6 @@\n     if (!inliningLowersCost(fs)) {\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n-        fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 211, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 691, 
          "faulty": "fs.setRemove(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 731, 
          "faulty": "return CanInlineResult.NO;", 
          "type": "Delete", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2825/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:34:21.649116428 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_889/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:14:50.467693704 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3217/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:38:16.448602488 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3217/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:38:16.448602488 -0500\n@@ -742,7 +742,6 @@\n   private void resolveInlineConflictsForFunction(FunctionState fs) {\n     // Functions that aren't referenced don't cause conflicts.\n     if (!fs.hasReferences() || !fs.canInline()) {\n-      return;\n     }\n \n     Node fnNode = fs.getFn().getFunctionNode();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 745, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2485/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:31:21.030417443 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1645/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:22:36.770463446 -0500\n@@ -199,7 +199,6 @@\n       if (nameNode != null) {\n         // This is a named break or continue;\n         String name = nameNode.getString();\n-        Preconditions.checkState(name.length() != 0);\n         LabelInfo li = getLabelInfo(name);\n         if (li != null) {\n           String newName = getNameForId(li.id);\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1645/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:22:36.770463446 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 202, 
          "faulty": "Preconditions.checkState(name.length() != 0);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_775/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:13:50.478858861 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_775/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:13:50.482858916 -0500\n@@ -742,7 +742,6 @@\n   private void resolveInlineConflictsForFunction(FunctionState fs) {\n     // Functions that aren't referenced don't cause conflicts.\n     if (!fs.hasReferences() || !fs.canInline()) {\n-      return;\n     }\n \n     Node fnNode = fs.getFn().getFunctionNode();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 745, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_922/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:15:07.455930642 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3212/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:38:13.496558869 -0500\n@@ -727,9 +727,6 @@\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3212/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:38:13.500558929 -0500\n@@ -498,9 +498,6 @@\n           t, fs, callNode, module, mode);\n       if (!referenceAdded &&\n           mode == InliningMode.DIRECT && blockFunctionInliningEnabled) {\n-        // This reference can not be directly inlined, see if\n-        // block replacement inlining is possible.\n-        mode = InliningMode.BLOCK;\n         referenceAdded = maybeAddReferenceUsingMode(\n             t, fs, callNode, module, mode);\n       }\n@@ -691,7 +688,6 @@\n         fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n-          return false;\n         }\n       } else {\n         return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 503, 
          "faulty": "mode=InliningMode.BLOCK;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 694, 
          "faulty": "return false;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1768/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:23:58.427732038 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2233/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:28:44.084004220 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3074/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:36:54.971395012 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_332/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:09:09.327009290 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_773/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:13:49.514845471 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_773/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:13:49.514845471 -0500\n@@ -688,7 +688,6 @@\n     if (!inliningLowersCost(fs)) {\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n-        fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 691, 
          "faulty": "fs.setRemove(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2006/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:26:20.181875673 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2161/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:27:57.399317450 -0500\n@@ -727,9 +727,6 @@\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1816/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:24:22.532101080 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1149/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:17:18.009829208 -0500\n@@ -196,22 +196,6 @@\n      */\n     private void visitBreakOrContinue(Node node) {\n       Node nameNode = node.getFirstChild();\n-      if (nameNode != null) {\n-        // This is a named break or continue;\n-        String name = nameNode.getString();\n-        Preconditions.checkState(name.length() != 0);\n-        LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n-      }\n     }\n \n     /**\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1149/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:17:18.009829208 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1149/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:17:18.009829208 -0500\n@@ -886,7 +886,8 @@\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n         if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n+          this.module = null;\n+\t\ti.remove();\n         }\n       }\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 199, 
          "faulty": "if (nameNode != null) {\n  String name=nameNode.getString();\n  Preconditions.checkState(name.length() != 0);\n  LabelInfo li=getLabelInfo(name);\n  if (li != null) {\n    String newName=getNameForId(li.id);\n    li.referenced=true;\n    if (!name.equals(newName)) {\n      nameNode.setString(newName);\n      compiler.reportCodeChange();\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 889, 
          "faulty": "i.remove();", 
          "type": "InsertBefore", 
          "seed": "this.module=null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_935/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:15:20.404115259 -0500\n@@ -185,7 +185,7 @@\n \n         case Token.BREAK:\n         case Token.CONTINUE:\n-          visitBreakOrContinue(node);\n+          ;\n           break;\n       }\n     }\n@@ -208,7 +208,6 @@\n           if (!name.equals(newName)) {\n             // Give it the short name.\n             nameNode.setString(newName);\n-            compiler.reportCodeChange();\n           }\n         }\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_935/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:15:20.404115259 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 188, 
          "faulty": "visitBreakOrContinue(node);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 211, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2866/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:34:48.325510673 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1524/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:21:17.737278188 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2275/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:29:06.248349992 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_442/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:10:24.744027727 -0500\n@@ -208,7 +208,6 @@\n           if (!name.equals(newName)) {\n             // Give it the short name.\n             nameNode.setString(newName);\n-            compiler.reportCodeChange();\n           }\n         }\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_442/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:10:24.744027727 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 211, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_630/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:12:33.437791831 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1439/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:20:06.948263947 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1439/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:20:06.948263947 -0500\n@@ -498,9 +498,6 @@\n           t, fs, callNode, module, mode);\n       if (!referenceAdded &&\n           mode == InliningMode.DIRECT && blockFunctionInliningEnabled) {\n-        // This reference can not be directly inlined, see if\n-        // block replacement inlining is possible.\n-        mode = InliningMode.BLOCK;\n         referenceAdded = maybeAddReferenceUsingMode(\n             t, fs, callNode, module, mode);\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 503, 
          "faulty": "mode=InliningMode.BLOCK;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_280/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:08:31.794508194 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_268/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:08:25.070418891 -0500\n@@ -196,22 +196,6 @@\n      */\n     private void visitBreakOrContinue(Node node) {\n       Node nameNode = node.getFirstChild();\n-      if (nameNode != null) {\n-        // This is a named break or continue;\n-        String name = nameNode.getString();\n-        Preconditions.checkState(name.length() != 0);\n-        LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n-      }\n     }\n \n     /**\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_268/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:08:25.070418891 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:57:38.329845888 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_268/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:08:25.074418945 -0500\n@@ -1456,7 +1456,9 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        Preconditions.checkState(this.propListHead == null,\n+\t\t\t\t\"Node has existing properties.\");\n+\t\treturn res;\n       }\n     }\n     return res;\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_268/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:08:25.074418945 -0500\n@@ -883,7 +883,8 @@\n \n     void removeBlockInliningReferences() {\n       Iterator<Entry<Node, Reference>> i;\n-      for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n+      this.module = null;\n+\tfor (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n         if (entry.getValue().mode == InliningMode.BLOCK) {\n           i.remove();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 199, 
          "faulty": "if (nameNode != null) {\n  String name=nameNode.getString();\n  Preconditions.checkState(name.length() != 0);\n  LabelInfo li=getLabelInfo(name);\n  if (li != null) {\n    String newName=getNameForId(li.id);\n    li.referenced=true;\n    if (!name.equals(newName)) {\n      nameNode.setString(newName);\n      compiler.reportCodeChange();\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 886, 
          "faulty": "for (i=getReferencesInternal().entrySet().iterator(); i.hasNext(); ) {\n  Entry<Node,Reference> entry=i.next();\n  if (entry.getValue().mode == InliningMode.BLOCK) {\n    i.remove();\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "this.module=null;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1459, 
          "faulty": "return res;", 
          "type": "InsertBefore", 
          "seed": "Preconditions.checkState(this.propListHead == null,\"Node has existing properties.\");"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1246/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:18:13.138626502 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_586/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:12:03.829383651 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_586/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:12:03.829383651 -0500\n@@ -742,7 +742,6 @@\n   private void resolveInlineConflictsForFunction(FunctionState fs) {\n     // Functions that aren't referenced don't cause conflicts.\n     if (!fs.hasReferences() || !fs.canInline()) {\n-      return;\n     }\n \n     Node fnNode = fs.getFn().getFunctionNode();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 745, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2554/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:31:56.502952585 -0500\n@@ -203,8 +203,6 @@\n         LabelInfo li = getLabelInfo(name);\n         if (li != null) {\n           String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n           if (!name.equals(newName)) {\n             // Give it the short name.\n             nameNode.setString(newName);\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2554/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:31:56.502952585 -0500\n@@ -727,9 +727,6 @@\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 207, 
          "faulty": "li.referenced=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_531/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:11:28.184893940 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1711/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:23:17.411098682 -0500\n@@ -727,9 +727,6 @@\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1711/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:23:17.415098744 -0500\n@@ -885,9 +885,7 @@\n       Iterator<Entry<Node, Reference>> i;\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n-        if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n-        }\n+        this.module = null;\n       }\n     }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 888, 
          "faulty": "if (entry.getValue().mode == InliningMode.BLOCK) {\n  i.remove();\n}", 
          "type": "Replace", 
          "seed": "this.module=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3083/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:36:59.919468575 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_241/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:08:08.442198714 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_546/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:11:37.041015428 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1179/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:17:39.442139555 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1179/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:17:39.446139613 -0500\n@@ -883,7 +883,8 @@\n \n     void removeBlockInliningReferences() {\n       Iterator<Entry<Node, Reference>> i;\n-      for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n+      this.module = null;\n+\tfor (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n         if (entry.getValue().mode == InliningMode.BLOCK) {\n           i.remove();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 886, 
          "faulty": "for (i=getReferencesInternal().entrySet().iterator(); i.hasNext(); ) {\n  Entry<Node,Reference> entry=i.next();\n  if (entry.getValue().mode == InliningMode.BLOCK) {\n    i.remove();\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "this.module=null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3174/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:37:53.132257726 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1145/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:17:16.097801496 -0500\n@@ -727,9 +727,6 @@\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2085/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:27:01.666493096 -0500\n@@ -728,7 +728,7 @@\n       if (fnParam != null) {\n         if (cArg != null) {\n           if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n+            return null;\n           }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2085/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:27:01.666493096 -0500\n@@ -691,7 +691,6 @@\n         fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n-          return false;\n         }\n       } else {\n         return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 694, 
          "faulty": "return false;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 731, 
          "faulty": "return CanInlineResult.NO;", 
          "type": "Replace", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2102/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:27:15.466697726 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3262/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:38:44.797020927 -0500\n@@ -206,8 +206,6 @@\n           // Mark the label as referenced so it isn't removed.\n           li.referenced = true;\n           if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n             compiler.reportCodeChange();\n           }\n         }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3262/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:38:44.797020927 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3262/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:38:44.797020927 -0500\n@@ -498,9 +498,6 @@\n           t, fs, callNode, module, mode);\n       if (!referenceAdded &&\n           mode == InliningMode.DIRECT && blockFunctionInliningEnabled) {\n-        // This reference can not be directly inlined, see if\n-        // block replacement inlining is possible.\n-        mode = InliningMode.BLOCK;\n         referenceAdded = maybeAddReferenceUsingMode(\n             t, fs, callNode, module, mode);\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 210, 
          "faulty": "nameNode.setString(newName);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 503, 
          "faulty": "mode=InliningMode.BLOCK;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2270/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:29:03.412305764 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3088/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:37:02.787511200 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1287/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:18:40.279017918 -0500\n@@ -201,16 +201,6 @@\n         String name = nameNode.getString();\n         Preconditions.checkState(name.length() != 0);\n         LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n       }\n     }\n \n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1287/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:18:40.279017918 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 204, 
          "faulty": "if (li != null) {\n  String newName=getNameForId(li.id);\n  li.referenced=true;\n  if (!name.equals(newName)) {\n    nameNode.setString(newName);\n    compiler.reportCodeChange();\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1782/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:24:05.139835023 -0500\n@@ -727,9 +727,6 @@\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2705/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:33:17.564165427 -0500\n@@ -201,16 +201,6 @@\n         String name = nameNode.getString();\n         Preconditions.checkState(name.length() != 0);\n         LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n       }\n     }\n \n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2705/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:33:17.568165487 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2705/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:33:17.568165487 -0500\n@@ -689,7 +689,6 @@\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n         fs.setRemove(false);\n-        fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n         }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 204, 
          "faulty": "if (li != null) {\n  String newName=getNameForId(li.id);\n  li.referenced=true;\n  if (!name.equals(newName)) {\n    nameNode.setString(newName);\n    compiler.reportCodeChange();\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 692, 
          "faulty": "fs.removeBlockInliningReferences();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3176/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:37:54.124272405 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3176/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:37:54.128272465 -0500\n@@ -886,7 +886,6 @@\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n         if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n         }\n       }\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 889, 
          "faulty": "i.remove();", 
          "type": "Delete", 
          "seed": "this.module=null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2505/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:31:30.690563480 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2210/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:28:32.587835383 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2927/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:35:21.369997906 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3141/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:37:31.199932882 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2814/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:34:14.729014013 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_789/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:13:59.342982025 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1080/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:16:42.325311261 -0500\n@@ -206,8 +206,6 @@\n           // Mark the label as referenced so it isn't removed.\n           li.referenced = true;\n           if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n             compiler.reportCodeChange();\n           }\n         }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1080/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:16:42.329311320 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 210, 
          "faulty": "nameNode.setString(newName);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_126/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:06:34.532976003 -0500\n@@ -728,7 +728,6 @@\n       if (fnParam != null) {\n         if (cArg != null) {\n           if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n           }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 08:57:38.089845892 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_126/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 09:06:34.536976055 -0500\n@@ -106,7 +106,6 @@\n \n   void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n-      return;\n     }\n \n     int type = n.getType();\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionToBlockMutator.java\t2018-12-01 08:57:38.101845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_126/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionToBlockMutator.java\t2018-12-01 09:06:34.536976055 -0500\n@@ -198,7 +198,7 @@\n \n     @Override\n     public String get() {\n-        return \"JSCompiler_inline_label_\" + idSupplier.get();\n+        return null;\n     }\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionToBlockMutator.java", 
          "line": 201, 
          "faulty": "return \"JSCompiler_inline_label_\" + idSupplier.get();", 
          "type": "Replace", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CodeGenerator.java", 
          "line": 109, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 731, 
          "faulty": "return CanInlineResult.NO;", 
          "type": "Delete", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2586/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:32:12.767196978 -0500\n@@ -206,8 +206,6 @@\n           // Mark the label as referenced so it isn't removed.\n           li.referenced = true;\n           if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n             compiler.reportCodeChange();\n           }\n         }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2586/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:32:12.771197038 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 210, 
          "faulty": "nameNode.setString(newName);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3120/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:37:20.131768735 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_405/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:09:59.003678583 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:57:38.329845888 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_405/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:09:59.003678583 -0500\n@@ -1456,7 +1456,6 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n       }\n     }\n     return res;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1459, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "parent=null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2448/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:30:56.486045284 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1160/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:17:23.801913131 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2434/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:30:47.865914182 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2434/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:30:47.865914182 -0500\n@@ -690,9 +690,7 @@\n       if (fs.hasBlockInliningReferences()) {\n         fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n-        if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n-          return false;\n-        }\n+        return false;\n       } else {\n         return false;\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 693, 
          "faulty": "if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2081/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:26:59.610462578 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1096/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:16:50.081423977 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_891/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:14:51.423707033 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1826/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:24:27.300173827 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2911/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:35:12.325864668 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2427/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:30:44.021855648 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2427/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:30:44.025855709 -0500\n@@ -886,7 +886,8 @@\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n         if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n+          this.module = null;\n+\t\ti.remove();\n         }\n       }\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 889, 
          "faulty": "i.remove();", 
          "type": "InsertBefore", 
          "seed": "this.module=null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_797/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:14:03.239036182 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_933/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:15:19.284098829 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 08:57:38.089845892 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_933/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 09:15:19.296099005 -0500\n@@ -106,7 +106,6 @@\n \n   void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n-      return;\n     }\n \n     int type = n.getType();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CodeGenerator.java", 
          "line": 109, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3238/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:38:32.252835862 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2201/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:28:22.703690079 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2104/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:27:16.442712185 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_382/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:09:41.895447373 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2941/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:35:34.170188450 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2941/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:35:34.174188509 -0500\n@@ -894,7 +894,7 @@\n     public boolean hasBlockInliningReferences() {\n       for (Reference r : getReferencesInternal().values()) {\n         if (r.mode == InliningMode.BLOCK) {\n-          return true;\n+          return false;\n         }\n       }\n       return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 897, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 731, 
          "faulty": "return CanInlineResult.NO;", 
          "type": "Replace", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_351/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:09:19.235142265 -0500\n@@ -185,7 +185,7 @@\n \n         case Token.BREAK:\n         case Token.CONTINUE:\n-          visitBreakOrContinue(node);\n+          ;\n           break;\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_351/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:09:19.239142318 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_351/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:09:19.239142318 -0500\n@@ -690,9 +690,7 @@\n       if (fs.hasBlockInliningReferences()) {\n         fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n-        if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n-          return false;\n-        }\n+        return false;\n       } else {\n         return false;\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 188, 
          "faulty": "visitBreakOrContinue(node);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 693, 
          "faulty": "if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1717/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:23:20.267143022 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1717/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:23:20.271143084 -0500\n@@ -688,7 +688,6 @@\n     if (!inliningLowersCost(fs)) {\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n-        fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n@@ -884,7 +883,8 @@\n     void removeBlockInliningReferences() {\n       Iterator<Entry<Node, Reference>> i;\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n-        Entry<Node, Reference> entry = i.next();\n+        this.module = null;\n+\t\tEntry<Node, Reference> entry = i.next();\n         if (entry.getValue().mode == InliningMode.BLOCK) {\n           i.remove();\n         }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 887, 
          "faulty": "Entry<Node,Reference> entry=i.next();", 
          "type": "InsertBefore", 
          "seed": "this.module=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 691, 
          "faulty": "fs.setRemove(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_828/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:14:18.647250493 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2895/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:35:03.717737775 -0500\n@@ -199,7 +199,6 @@\n       if (nameNode != null) {\n         // This is a named break or continue;\n         String name = nameNode.getString();\n-        Preconditions.checkState(name.length() != 0);\n         LabelInfo li = getLabelInfo(name);\n         if (li != null) {\n           String newName = getNameForId(li.id);\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2895/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:35:03.717737775 -0500\n@@ -727,9 +727,6 @@\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 202, 
          "faulty": "Preconditions.checkState(name.length() != 0);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1690/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:23:00.690838332 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1690/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:23:00.694838394 -0500\n@@ -689,7 +689,6 @@\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n         fs.setRemove(false);\n-        fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n         }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 692, 
          "faulty": "fs.removeBlockInliningReferences();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2251/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:28:53.876156785 -0500\n@@ -199,7 +199,6 @@\n       if (nameNode != null) {\n         // This is a named break or continue;\n         String name = nameNode.getString();\n-        Preconditions.checkState(name.length() != 0);\n         LabelInfo li = getLabelInfo(name);\n         if (li != null) {\n           String newName = getNameForId(li.id);\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2251/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:28:53.876156785 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 202, 
          "faulty": "Preconditions.checkState(name.length() != 0);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_217/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:07:52.053982688 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_217/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:07:52.057982741 -0500\n@@ -688,8 +688,6 @@\n     if (!inliningLowersCost(fs)) {\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n-        fs.setRemove(false);\n-        fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n         }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 691, 
          "faulty": "fs.setRemove(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 692, 
          "faulty": "fs.removeBlockInliningReferences();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2682/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:33:00.815915844 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_578/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:11:59.813328379 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_578/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:11:59.813328379 -0500\n@@ -894,7 +894,7 @@\n     public boolean hasBlockInliningReferences() {\n       for (Reference r : getReferencesInternal().values()) {\n         if (r.mode == InliningMode.BLOCK) {\n-          return true;\n+          return false;\n         }\n       }\n       return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 897, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2063/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:26:50.922333528 -0500\n@@ -196,22 +196,6 @@\n      */\n     private void visitBreakOrContinue(Node node) {\n       Node nameNode = node.getFirstChild();\n-      if (nameNode != null) {\n-        // This is a named break or continue;\n-        String name = nameNode.getString();\n-        Preconditions.checkState(name.length() != 0);\n-        LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n-      }\n     }\n \n     /**\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2063/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:26:50.922333528 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 199, 
          "faulty": "if (nameNode != null) {\n  String name=nameNode.getString();\n  Preconditions.checkState(name.length() != 0);\n  LabelInfo li=getLabelInfo(name);\n  if (li != null) {\n    String newName=getNameForId(li.id);\n    li.referenced=true;\n    if (!name.equals(newName)) {\n      nameNode.setString(newName);\n      compiler.reportCodeChange();\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2999/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:36:04.350640371 -0500\n@@ -206,8 +206,6 @@\n           // Mark the label as referenced so it isn't removed.\n           li.referenced = true;\n           if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n             compiler.reportCodeChange();\n           }\n         }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2999/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:36:04.354640431 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 210, 
          "faulty": "nameNode.setString(newName);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1352/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:19:14.843515503 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\t2018-12-01 08:57:38.101845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1352/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\t2018-12-01 09:19:14.843515503 -0500\n@@ -63,10 +63,6 @@\n     if (node.isName()) {\n       Node replacementTemplate = replacements.get(node.getString());\n       if (replacementTemplate != null) {\n-        // This should not be replacing declared names.\n-        Preconditions.checkState(!parent.isFunction()\n-            || !parent.isVar()\n-            || !parent.isCatch());\n         // The name may need to be replaced more than once,\n         // so we need to clone the node.\n         Node replacement = replacementTemplate.cloneTree();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionArgumentInjector.java", 
          "line": 67, 
          "faulty": "Preconditions.checkState(!parent.isFunction() || !parent.isVar() || !parent.isCatch());", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2139/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:27:40.795072407 -0500\n@@ -201,16 +201,6 @@\n         String name = nameNode.getString();\n         Preconditions.checkState(name.length() != 0);\n         LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n       }\n     }\n \n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2139/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:27:40.795072407 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 204, 
          "faulty": "if (li != null) {\n  String newName=getNameForId(li.id);\n  li.referenced=true;\n  if (!name.equals(newName)) {\n    nameNode.setString(newName);\n    compiler.reportCodeChange();\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1171/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:17:35.646084624 -0500\n@@ -208,7 +208,6 @@\n           if (!name.equals(newName)) {\n             // Give it the short name.\n             nameNode.setString(newName);\n-            compiler.reportCodeChange();\n           }\n         }\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1171/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:17:35.646084624 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1171/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:17:35.646084624 -0500\n@@ -886,7 +886,8 @@\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n         if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n+          this.module = null;\n+\t\ti.remove();\n         }\n       }\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 889, 
          "faulty": "i.remove();", 
          "type": "InsertBefore", 
          "seed": "this.module=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 211, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1664/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:22:47.278628498 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_477/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:10:53.512419591 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_711/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:13:16.606388924 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2336/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:29:38.784854969 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\t2018-12-01 08:57:38.101845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2336/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\t2018-12-01 09:29:38.784854969 -0500\n@@ -63,10 +63,6 @@\n     if (node.isName()) {\n       Node replacementTemplate = replacements.get(node.getString());\n       if (replacementTemplate != null) {\n-        // This should not be replacing declared names.\n-        Preconditions.checkState(!parent.isFunction()\n-            || !parent.isVar()\n-            || !parent.isCatch());\n         // The name may need to be replaced more than once,\n         // so we need to clone the node.\n         Node replacement = replacementTemplate.cloneTree();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionArgumentInjector.java", 
          "line": 67, 
          "faulty": "Preconditions.checkState(!parent.isFunction() || !parent.isVar() || !parent.isCatch());", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1831/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:24:35.280295402 -0500\n@@ -203,8 +203,6 @@\n         LabelInfo li = getLabelInfo(name);\n         if (li != null) {\n           String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n           if (!name.equals(newName)) {\n             // Give it the short name.\n             nameNode.setString(newName);\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1831/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:24:35.280295402 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 207, 
          "faulty": "li.referenced=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1784/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:24:06.135850290 -0500\n@@ -206,8 +206,6 @@\n           // Mark the label as referenced so it isn't removed.\n           li.referenced = true;\n           if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n             compiler.reportCodeChange();\n           }\n         }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1784/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:24:06.135850290 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1784/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:24:06.139850351 -0500\n@@ -885,9 +885,7 @@\n       Iterator<Entry<Node, Reference>> i;\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n-        if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n-        }\n+        this.module = null;\n       }\n     }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 888, 
          "faulty": "if (entry.getValue().mode == InliningMode.BLOCK) {\n  i.remove();\n}", 
          "type": "Replace", 
          "seed": "this.module=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 210, 
          "faulty": "nameNode.setString(newName);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1914/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:25:29.813120719 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1914/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:25:29.813120719 -0500\n@@ -688,7 +688,6 @@\n     if (!inliningLowersCost(fs)) {\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n-        fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 691, 
          "faulty": "fs.setRemove(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_518/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:11:20.300785895 -0500\n@@ -727,9 +727,6 @@\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_518/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:11:20.300785895 -0500\n@@ -885,9 +885,6 @@\n       Iterator<Entry<Node, Reference>> i;\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n-        if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n-        }\n       }\n     }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 888, 
          "faulty": "if (entry.getValue().mode == InliningMode.BLOCK) {\n  i.remove();\n}", 
          "type": "Delete", 
          "seed": "this.module=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 731, 
          "faulty": "return CanInlineResult.NO;", 
          "type": "Replace", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3034/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:36:27.714989167 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_904/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:14:58.147800794 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\t2018-12-01 08:57:38.101845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_904/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\t2018-12-01 09:14:58.151800850 -0500\n@@ -63,10 +63,6 @@\n     if (node.isName()) {\n       Node replacementTemplate = replacements.get(node.getString());\n       if (replacementTemplate != null) {\n-        // This should not be replacing declared names.\n-        Preconditions.checkState(!parent.isFunction()\n-            || !parent.isVar()\n-            || !parent.isCatch());\n         // The name may need to be replaced more than once,\n         // so we need to clone the node.\n         Node replacement = replacementTemplate.cloneTree();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionArgumentInjector.java", 
          "line": 67, 
          "faulty": "Preconditions.checkState(!parent.isFunction() || !parent.isVar() || !parent.isCatch());", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2810/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:34:12.828985882 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2151/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:27:52.651247423 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3316/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:39:18.969524380 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2522/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:31:39.282693177 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2522/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:31:39.286693237 -0500\n@@ -894,7 +894,7 @@\n     public boolean hasBlockInliningReferences() {\n       for (Reference r : getReferencesInternal().values()) {\n         if (r.mode == InliningMode.BLOCK) {\n-          return true;\n+          return false;\n         }\n       }\n       return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 897, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_768/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:13:46.606805083 -0500\n@@ -205,11 +205,6 @@\n           String newName = getNameForId(li.id);\n           // Mark the label as referenced so it isn't removed.\n           li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n         }\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_768/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:13:46.606805083 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 208, 
          "faulty": "if (!name.equals(newName)) {\n  nameNode.setString(newName);\n  compiler.reportCodeChange();\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 731, 
          "faulty": "return CanInlineResult.NO;", 
          "type": "Replace", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2945/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:35:36.102217429 -0500\n@@ -727,9 +727,6 @@\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionToBlockMutator.java\t2018-12-01 08:57:38.101845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2945/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionToBlockMutator.java\t2018-12-01 09:35:36.102217429 -0500\n@@ -198,7 +198,7 @@\n \n     @Override\n     public String get() {\n-        return \"JSCompiler_inline_label_\" + idSupplier.get();\n+        return null;\n     }\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionToBlockMutator.java", 
          "line": 201, 
          "faulty": "return \"JSCompiler_inline_label_\" + idSupplier.get();", 
          "type": "Replace", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2643/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:32:41.503627440 -0500\n@@ -196,22 +196,6 @@\n      */\n     private void visitBreakOrContinue(Node node) {\n       Node nameNode = node.getFirstChild();\n-      if (nameNode != null) {\n-        // This is a named break or continue;\n-        String name = nameNode.getString();\n-        Preconditions.checkState(name.length() != 0);\n-        LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n-      }\n     }\n \n     /**\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2643/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:32:41.503627440 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 199, 
          "faulty": "if (nameNode != null) {\n  String name=nameNode.getString();\n  Preconditions.checkState(name.length() != 0);\n  LabelInfo li=getLabelInfo(name);\n  if (li != null) {\n    String newName=getNameForId(li.id);\n    li.referenced=true;\n    if (!name.equals(newName)) {\n      nameNode.setString(newName);\n      compiler.reportCodeChange();\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2153/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:27:53.599261408 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1131/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:17:08.461690776 -0500\n@@ -201,16 +201,6 @@\n         String name = nameNode.getString();\n         Preconditions.checkState(name.length() != 0);\n         LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n       }\n     }\n \n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1131/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:17:08.465690833 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 204, 
          "faulty": "if (li != null) {\n  String newName=getNameForId(li.id);\n  li.referenced=true;\n  if (!name.equals(newName)) {\n    nameNode.setString(newName);\n    compiler.reportCodeChange();\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2028/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:26:31.726047852 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\t2018-12-01 08:57:38.101845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2028/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\t2018-12-01 09:26:31.730047912 -0500\n@@ -63,10 +63,6 @@\n     if (node.isName()) {\n       Node replacementTemplate = replacements.get(node.getString());\n       if (replacementTemplate != null) {\n-        // This should not be replacing declared names.\n-        Preconditions.checkState(!parent.isFunction()\n-            || !parent.isVar()\n-            || !parent.isCatch());\n         // The name may need to be replaced more than once,\n         // so we need to clone the node.\n         Node replacement = replacementTemplate.cloneTree();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionArgumentInjector.java", 
          "line": 67, 
          "faulty": "Preconditions.checkState(!parent.isFunction() || !parent.isVar() || !parent.isCatch());", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_79/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:05:52.476416104 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_79/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:05:52.476416104 -0500\n@@ -498,11 +498,6 @@\n           t, fs, callNode, module, mode);\n       if (!referenceAdded &&\n           mode == InliningMode.DIRECT && blockFunctionInliningEnabled) {\n-        // This reference can not be directly inlined, see if\n-        // block replacement inlining is possible.\n-        mode = InliningMode.BLOCK;\n-        referenceAdded = maybeAddReferenceUsingMode(\n-            t, fs, callNode, module, mode);\n       }\n \n       if (!referenceAdded) {\n@@ -688,7 +683,6 @@\n     if (!inliningLowersCost(fs)) {\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n-        fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 503, 
          "faulty": "mode=InliningMode.BLOCK;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 504, 
          "faulty": "referenceAdded=maybeAddReferenceUsingMode(t,fs,callNode,module,mode);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 691, 
          "faulty": "fs.setRemove(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2432/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:30:46.897899445 -0500\n@@ -727,9 +727,6 @@\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1719/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:23:21.211157670 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1143/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:17:15.129787464 -0500\n@@ -206,8 +206,6 @@\n           // Mark the label as referenced so it isn't removed.\n           li.referenced = true;\n           if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n             compiler.reportCodeChange();\n           }\n         }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1143/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:17:15.129787464 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 210, 
          "faulty": "nameNode.setString(newName);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3032/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:36:26.762974972 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 08:57:38.089845892 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3032/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 09:36:26.766975032 -0500\n@@ -106,7 +106,6 @@\n \n   void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n-      return;\n     }\n \n     int type = n.getType();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CodeGenerator.java", 
          "line": 109, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2556/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:31:57.446966786 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_483/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:10:56.516460603 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_483/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:10:56.520460658 -0500\n@@ -883,12 +883,7 @@\n \n     void removeBlockInliningReferences() {\n       Iterator<Entry<Node, Reference>> i;\n-      for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n-        Entry<Node, Reference> entry = i.next();\n-        if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n-        }\n-      }\n+      this.module = null;\n     }\n \n     public boolean hasBlockInliningReferences() {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 886, 
          "faulty": "for (i=getReferencesInternal().entrySet().iterator(); i.hasNext(); ) {\n  Entry<Node,Reference> entry=i.next();\n  if (entry.getValue().mode == InliningMode.BLOCK) {\n    i.remove();\n  }\n}", 
          "type": "Replace", 
          "seed": "this.module=null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1466/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:20:25.436529103 -0500\n@@ -196,22 +196,6 @@\n      */\n     private void visitBreakOrContinue(Node node) {\n       Node nameNode = node.getFirstChild();\n-      if (nameNode != null) {\n-        // This is a named break or continue;\n-        String name = nameNode.getString();\n-        Preconditions.checkState(name.length() != 0);\n-        LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n-      }\n     }\n \n     /**\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1466/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:20:25.436529103 -0500\n@@ -727,9 +727,6 @@\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\t2018-12-01 08:57:38.101845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1466/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\t2018-12-01 09:20:25.440529160 -0500\n@@ -63,10 +63,6 @@\n     if (node.isName()) {\n       Node replacementTemplate = replacements.get(node.getString());\n       if (replacementTemplate != null) {\n-        // This should not be replacing declared names.\n-        Preconditions.checkState(!parent.isFunction()\n-            || !parent.isVar()\n-            || !parent.isCatch());\n         // The name may need to be replaced more than once,\n         // so we need to clone the node.\n         Node replacement = replacementTemplate.cloneTree();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 210, 
          "faulty": "nameNode.setString(newName);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 199, 
          "faulty": "if (nameNode != null) {\n  String name=nameNode.getString();\n  Preconditions.checkState(name.length() != 0);\n  LabelInfo li=getLabelInfo(name);\n  if (li != null) {\n    String newName=getNameForId(li.id);\n    li.referenced=true;\n    if (!name.equals(newName)) {\n      nameNode.setString(newName);\n      compiler.reportCodeChange();\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionArgumentInjector.java", 
          "line": 67, 
          "faulty": "Preconditions.checkState(!parent.isFunction() || !parent.isVar() || !parent.isCatch());", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1183/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:17:41.358167275 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1789/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:24:09.015894414 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1789/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:24:09.015894414 -0500\n@@ -689,7 +689,6 @@\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n         fs.setRemove(false);\n-        fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n         }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 731, 
          "faulty": "return CanInlineResult.NO;", 
          "type": "Replace", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 692, 
          "faulty": "fs.removeBlockInliningReferences();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_991/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:15:49.772545268 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_991/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:15:49.772545268 -0500\n@@ -894,7 +894,7 @@\n     public boolean hasBlockInliningReferences() {\n       for (Reference r : getReferencesInternal().values()) {\n         if (r.mode == InliningMode.BLOCK) {\n-          return true;\n+          return false;\n         }\n       }\n       return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 897, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1662/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:22:46.330613631 -0500\n@@ -727,9 +727,6 @@\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1662/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:22:46.334613695 -0500\n@@ -756,8 +756,6 @@\n           // For functions that can no longer be removed, check if they should\n           // still be inlined.\n           if (!mimimizeCost(fsCalled)) {\n-            // It can't be inlined remove it from the list.\n-            fsCalled.setInline(false);\n           }\n         }\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 760, 
          "faulty": "fsCalled.setInline(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1067/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:16:35.581213187 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1065/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:16:34.633199396 -0500\n@@ -205,11 +205,6 @@\n           String newName = getNameForId(li.id);\n           // Mark the label as referenced so it isn't removed.\n           li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n         }\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1065/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:16:34.633199396 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1065/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:16:34.637199454 -0500\n@@ -689,7 +689,6 @@\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n         fs.setRemove(false);\n-        fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n         }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 208, 
          "faulty": "if (!name.equals(newName)) {\n  nameNode.setString(newName);\n  compiler.reportCodeChange();\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 692, 
          "faulty": "fs.removeBlockInliningReferences();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3145/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:37:33.143961699 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3145/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:37:33.143961699 -0500\n@@ -688,7 +688,6 @@\n     if (!inliningLowersCost(fs)) {\n       // Try again without Block inlining references\n       if (fs.hasBlockInliningReferences()) {\n-        fs.setRemove(false);\n         fs.removeBlockInliningReferences();\n         if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n           return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 691, 
          "faulty": "fs.setRemove(false);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2514/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:31:35.458635476 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2514/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:31:35.462635537 -0500\n@@ -886,7 +886,6 @@\n       for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n         Entry<Node, Reference> entry = i.next();\n         if (entry.getValue().mode == InliningMode.BLOCK) {\n-          i.remove();\n         }\n       }\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 889, 
          "faulty": "i.remove();", 
          "type": "Delete", 
          "seed": "this.module=null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2966/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:35:46.890379120 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2259/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:28:57.696216513 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3287/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:38:58.365220940 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3107/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:37:13.303667394 -0500\n@@ -196,22 +196,6 @@\n      */\n     private void visitBreakOrContinue(Node node) {\n       Node nameNode = node.getFirstChild();\n-      if (nameNode != null) {\n-        // This is a named break or continue;\n-        String name = nameNode.getString();\n-        Preconditions.checkState(name.length() != 0);\n-        LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n-      }\n     }\n \n     /**\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3107/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:37:13.307667454 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\t2018-12-01 08:57:38.101845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3107/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\t2018-12-01 09:37:13.307667454 -0500\n@@ -63,10 +63,6 @@\n     if (node.isName()) {\n       Node replacementTemplate = replacements.get(node.getString());\n       if (replacementTemplate != null) {\n-        // This should not be replacing declared names.\n-        Preconditions.checkState(!parent.isFunction()\n-            || !parent.isVar()\n-            || !parent.isCatch());\n         // The name may need to be replaced more than once,\n         // so we need to clone the node.\n         Node replacement = replacementTemplate.cloneTree();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 199, 
          "faulty": "if (nameNode != null) {\n  String name=nameNode.getString();\n  Preconditions.checkState(name.length() != 0);\n  LabelInfo li=getLabelInfo(name);\n  if (li != null) {\n    String newName=getNameForId(li.id);\n    li.referenced=true;\n    if (!name.equals(newName)) {\n      nameNode.setString(newName);\n      compiler.reportCodeChange();\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionArgumentInjector.java", 
          "line": 67, 
          "faulty": "Preconditions.checkState(!parent.isFunction() || !parent.isVar() || !parent.isCatch());", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2157/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:27:55.503289491 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_99/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:06:08.924642257 -0500\n@@ -205,11 +205,6 @@\n           String newName = getNameForId(li.id);\n           // Mark the label as referenced so it isn't removed.\n           li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n         }\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:57:38.329845888 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_99/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:06:08.928642312 -0500\n@@ -1443,7 +1443,9 @@\n    */\n   NodeMismatch checkTreeEqualsImpl(Node node2) {\n     if (!isEquivalentTo(node2, false, false, false)) {\n-      return new NodeMismatch(this, node2);\n+      if (!isEquivalentTo(node2, false, false, false)) {\n+\t\treturn new NodeMismatch(this, node2);\n+\t}\n     }\n \n     NodeMismatch res = null;\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_99/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:06:08.928642312 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1446, 
          "faulty": "return new NodeMismatch(this,node2);", 
          "type": "Replace", 
          "seed": "if (!isEquivalentTo(node2,false,false,false)) {\n  return new NodeMismatch(this,node2);\n}"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 208, 
          "faulty": "if (!name.equals(newName)) {\n  nameNode.setString(newName);\n  compiler.reportCodeChange();\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 731, 
          "faulty": "return CanInlineResult.NO;", 
          "type": "Delete", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_681/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:13:00.970172398 -0500\n@@ -196,22 +196,6 @@\n      */\n     private void visitBreakOrContinue(Node node) {\n       Node nameNode = node.getFirstChild();\n-      if (nameNode != null) {\n-        // This is a named break or continue;\n-        String name = nameNode.getString();\n-        Preconditions.checkState(name.length() != 0);\n-        LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n-      }\n     }\n \n     /**\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_681/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:13:00.970172398 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 199, 
          "faulty": "if (nameNode != null) {\n  String name=nameNode.getString();\n  Preconditions.checkState(name.length() != 0);\n  LabelInfo li=getLabelInfo(name);\n  if (li != null) {\n    String newName=getNameForId(li.id);\n    li.referenced=true;\n    if (!name.equals(newName)) {\n      nameNode.setString(newName);\n      compiler.reportCodeChange();\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2571/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:32:05.115082066 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:57:38.329845888 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2571/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:32:05.115082066 -0500\n@@ -1456,7 +1456,9 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        Preconditions.checkState(this.propListHead == null,\n+\t\t\t\t\"Node has existing properties.\");\n+\t\treturn res;\n       }\n     }\n     return res;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1459, 
          "faulty": "return res;", 
          "type": "InsertBefore", 
          "seed": "Preconditions.checkState(this.propListHead == null,\"Node has existing properties.\");"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1776/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:24:02.267790978 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_970/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:15:38.164375483 -0500\n@@ -196,22 +196,6 @@\n      */\n     private void visitBreakOrContinue(Node node) {\n       Node nameNode = node.getFirstChild();\n-      if (nameNode != null) {\n-        // This is a named break or continue;\n-        String name = nameNode.getString();\n-        Preconditions.checkState(name.length() != 0);\n-        LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n-      }\n     }\n \n     /**\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_970/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:15:38.168375542 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 199, 
          "faulty": "if (nameNode != null) {\n  String name=nameNode.getString();\n  Preconditions.checkState(name.length() != 0);\n  LabelInfo li=getLabelInfo(name);\n  if (li != null) {\n    String newName=getNameForId(li.id);\n    li.referenced=true;\n    if (!name.equals(newName)) {\n      nameNode.setString(newName);\n      compiler.reportCodeChange();\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2878/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:34:55.105610742 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3122/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:37:21.103783157 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:57:38.329845888 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3122/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:37:21.103783157 -0500\n@@ -1456,7 +1456,8 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        Preconditions.checkState(this.propListHead == null,\n+\t\t\t\t\"Node has existing properties.\");\n       }\n     }\n     return res;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1459, 
          "faulty": "return res;", 
          "type": "Replace", 
          "seed": "Preconditions.checkState(this.propListHead == null,\"Node has existing properties.\");"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_272/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:08:26.994444428 -0500\n@@ -196,22 +196,6 @@\n      */\n     private void visitBreakOrContinue(Node node) {\n       Node nameNode = node.getFirstChild();\n-      if (nameNode != null) {\n-        // This is a named break or continue;\n-        String name = nameNode.getString();\n-        Preconditions.checkState(name.length() != 0);\n-        LabelInfo li = getLabelInfo(name);\n-        if (li != null) {\n-          String newName = getNameForId(li.id);\n-          // Mark the label as referenced so it isn't removed.\n-          li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n-        }\n-      }\n     }\n \n     /**\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_272/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:08:26.994444428 -0500\n@@ -728,7 +728,7 @@\n       if (fnParam != null) {\n         if (cArg != null) {\n           if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n+            return null;\n           }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 199, 
          "faulty": "if (nameNode != null) {\n  String name=nameNode.getString();\n  Preconditions.checkState(name.length() != 0);\n  LabelInfo li=getLabelInfo(name);\n  if (li != null) {\n    String newName=getNameForId(li.id);\n    li.referenced=true;\n    if (!name.equals(newName)) {\n      nameNode.setString(newName);\n      compiler.reportCodeChange();\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 731, 
          "faulty": "return CanInlineResult.NO;", 
          "type": "Replace", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2702/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:33:10.508060335 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 730, 
          "faulty": "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n  return CanInlineResult.NO;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_675/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:12:58.090132546 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_848/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:14:29.247398047 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1289/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:18:41.263032097 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:57:38.329845888 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1289/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:18:41.263032097 -0500\n@@ -1427,11 +1427,7 @@\n   public String checkTreeEquals(Node node2) {\n       NodeMismatch diff = checkTreeEqualsImpl(node2);\n       if (diff != null) {\n-        return \"Node tree inequality:\" +\n-            \"\\nTree1:\\n\" + toStringTree() +\n-            \"\\n\\nTree2:\\n\" + node2.toStringTree() +\n-            \"\\n\\nSubtree1: \" + diff.nodeA.toStringTree() +\n-            \"\\n\\nSubtree2: \" + diff.nodeB.toStringTree();\n+        return \"SCRIPT\";\n       }\n       return null;\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1289/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:18:41.263032097 -0500\n@@ -742,7 +742,6 @@\n   private void resolveInlineConflictsForFunction(FunctionState fs) {\n     // Functions that aren't referenced don't cause conflicts.\n     if (!fs.hasReferences() || !fs.canInline()) {\n-      return;\n     }\n \n     Node fnNode = fs.getFn().getFunctionNode();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 745, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1430, 
          "faulty": "return \"Node tree inequality:\" + \"\\nTree1:\\n\" + toStringTree() + \"\\n\\nTree2:\\n\"+ node2.toStringTree()+ \"\\n\\nSubtree1: \"+ diff.nodeA.toStringTree()+ \"\\n\\nSubtree2: \"+ diff.nodeB.toStringTree();", 
          "type": "Replace", 
          "seed": "return \"SCRIPT\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_713/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:13:17.614402891 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\t2018-12-01 08:57:38.101845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_713/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\t2018-12-01 09:13:17.614402891 -0500\n@@ -63,10 +63,6 @@\n     if (node.isName()) {\n       Node replacementTemplate = replacements.get(node.getString());\n       if (replacementTemplate != null) {\n-        // This should not be replacing declared names.\n-        Preconditions.checkState(!parent.isFunction()\n-            || !parent.isVar()\n-            || !parent.isCatch());\n         // The name may need to be replaced more than once,\n         // so we need to clone the node.\n         Node replacement = replacementTemplate.cloneTree();\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 08:57:38.105845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_713/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/InlineFunctions.java\t2018-12-01 09:13:17.618402946 -0500\n@@ -742,7 +742,6 @@\n   private void resolveInlineConflictsForFunction(FunctionState fs) {\n     // Functions that aren't referenced don't cause conflicts.\n     if (!fs.hasReferences() || !fs.canInline()) {\n-      return;\n     }\n \n     Node fnNode = fs.getFn().getFunctionNode();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/InlineFunctions.java", 
          "line": 745, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionArgumentInjector.java", 
          "line": 67, 
          "faulty": "Preconditions.checkState(!parent.isFunction() || !parent.isVar() || !parent.isCatch());", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3164/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:37:47.732177795 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 08:57:38.089845892 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_3164/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/CodeGenerator.java\t2018-12-01 09:37:47.752178091 -0500\n@@ -106,7 +106,6 @@\n \n   void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n-      return;\n     }\n \n     int type = n.getType();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CodeGenerator.java", 
          "line": 109, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 08:57:38.117845891 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_902/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/RenameLabels.java\t2018-12-01 09:14:57.195787518 -0500\n@@ -205,11 +205,6 @@\n           String newName = getNameForId(li.id);\n           // Mark the label as referenced so it isn't removed.\n           li.referenced = true;\n-          if (!name.equals(newName)) {\n-            // Give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n-          }\n         }\n       }\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_902/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:14:57.199787573 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/RenameLabels.java", 
          "line": 208, 
          "faulty": "if (!name.equals(newName)) {\n  nameNode.setString(newName);\n  compiler.reportCodeChange();\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_2473/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:31:09.162237693 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 08:57:41.237845843 -0500\n+++ /tmp/Arja_Defects4J_Closure_115/patches_iqic/Patch_1033/patched/tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 09:16:12.092871106 -0500\n@@ -726,20 +726,6 @@\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n-\n         // Move to the next name.\n         fnParam = fnParam.getNext();\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java", 
          "line": 729, 
          "faulty": "if (cArg != null) {\n  if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n    return CanInlineResult.NO;\n  }\n  if (NodeUtil.mayEffectMutableState(cArg,compiler) && NodeUtil.getNameReferenceCount(block,fnParam.getString()) > 1) {\n    return CanInlineResult.NO;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }
  ]
}