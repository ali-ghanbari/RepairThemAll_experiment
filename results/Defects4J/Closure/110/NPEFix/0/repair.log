cd /tmp/NPEFix_Defects4J_Closure_110;
export JAVA_TOOL_OPTIONS="-Dfile.encoding=UTF8 -Duser.language=en-US -Duser.country=US -Duser.language=en";
TZ="America/New_York"; export TZ;
export PATH="/usr/lib/jvm/java-1.8.0-openjdk-amd64/bin/:$PATH";
export JAVA_HOME="/usr/lib/jvm/java-1.8.0-openjdk-amd64/bin/";
time java -Xmx4g -Xms1g -cp /home/tdurieux/RepairThemAll/script/../repair_tools/npefix.jar fr.inria.spirals.npefix.main.run.Main \
    --test com.google.javascript.jscomp.ScopedAliasesTest \
    --iteration 100 \
	--complianceLevel 6 \
	--workingdirectory . \
	--source src/ \
	--classpath build/classes/:build/test/:/tmp/NPEFix_Defects4J_Closure_110/build/classes:/tmp/NPEFix_Defects4J_Closure_110/build/test:/tmp/NPEFix_Defects4J_Closure_110/build/lib/rhino.jar:/tmp/NPEFix_Defects4J_Closure_110/lib/args4j.jar:/tmp/NPEFix_Defects4J_Closure_110/lib/guava.jar:/tmp/NPEFix_Defects4J_Closure_110/lib/ant.jar:/tmp/NPEFix_Defects4J_Closure_110/lib/ant-launcher.jar:/tmp/NPEFix_Defects4J_Closure_110/lib/caja-r4314.jar:/tmp/NPEFix_Defects4J_Closure_110/lib/jsr305.jar:/tmp/NPEFix_Defects4J_Closure_110/lib/junit.jar:/tmp/NPEFix_Defects4J_Closure_110/lib/json.jar:/tmp/NPEFix_Defects4J_Closure_110/lib/protobuf-java.jar:/tmp/NPEFix_Defects4J_Closure_110/lib/jarjar.jar;
	echo "\n\nNode: `hostname`\n";
	echo "\n\nDate: `date`\n";
Picked up JAVA_TOOL_OPTIONS: -Dfile.encoding=UTF8 -Duser.language=en-US -Duser.country=US -Duser.language=en
TernarySplitter  in 432ms
return ((mismatchA) == null) && ((mismatchB) == null)
return ((mismatchA) == null) && ((mismatchB) == null)
return (key != null) && ((key.length()) > 0)
Preconditions.checkState((references != null))
Preconditions.checkArgument(((p.node.getParent()) == null))
Preconditions.checkArgument(((n.node.getParent()) == null))
Preconditions.checkArgument(((n.getParent()) == null))
return JsMessage.Hash.hash64(value, 0, (value == null ? 0 : value.length), seed)
Preconditions.checkState((key != null))
Preconditions.checkState((id != null))
return ((((((((id.equals(m.id)) && (key.equals(m.key))) && ((isAnonymous) == (m.isAnonymous))) && (parts.equals(m.parts))) && ((meaning) == null ? (m.meaning) == null : meaning.equals(m.meaning))) && (placeholders.equals(m.placeholders))) && ((desc) == null ? (m.desc) == null : desc.equals(m.desc))) && ((sourceName) == null ? (m.sourceName) == null : sourceName.equals(m.sourceName))) && ((hidden) == (m.hidden))
return ((((((((id.equals(m.id)) && (key.equals(m.key))) && ((isAnonymous) == (m.isAnonymous))) && (parts.equals(m.parts))) && ((meaning) == null ? (m.meaning) == null : meaning.equals(m.meaning))) && (placeholders.equals(m.placeholders))) && ((desc) == null ? (m.desc) == null : desc.equals(m.desc))) && ((sourceName) == null ? (m.sourceName) == null : sourceName.equals(m.sourceName))) && ((hidden) == (m.hidden))
return ((((((((id.equals(m.id)) && (key.equals(m.key))) && ((isAnonymous) == (m.isAnonymous))) && (parts.equals(m.parts))) && ((meaning) == null ? (m.meaning) == null : meaning.equals(m.meaning))) && (placeholders.equals(m.placeholders))) && ((desc) == null ? (m.desc) == null : desc.equals(m.desc))) && ((sourceName) == null ? (m.sourceName) == null : sourceName.equals(m.sourceName))) && ((hidden) == (m.hidden))
return ((((((((id.equals(m.id)) && (key.equals(m.key))) && ((isAnonymous) == (m.isAnonymous))) && (parts.equals(m.parts))) && ((meaning) == null ? (m.meaning) == null : meaning.equals(m.meaning))) && (placeholders.equals(m.placeholders))) && ((desc) == null ? (m.desc) == null : desc.equals(m.desc))) && ((sourceName) == null ? (m.sourceName) == null : sourceName.equals(m.sourceName))) && ((hidden) == (m.hidden))
return ((((((((id.equals(m.id)) && (key.equals(m.key))) && ((isAnonymous) == (m.isAnonymous))) && (parts.equals(m.parts))) && ((meaning) == null ? (m.meaning) == null : meaning.equals(m.meaning))) && (placeholders.equals(m.placeholders))) && ((desc) == null ? (m.desc) == null : desc.equals(m.desc))) && ((sourceName) == null ? (m.sourceName) == null : sourceName.equals(m.sourceName))) && ((hidden) == (m.hidden))
return ((((((((id.equals(m.id)) && (key.equals(m.key))) && ((isAnonymous) == (m.isAnonymous))) && (parts.equals(m.parts))) && ((meaning) == null ? (m.meaning) == null : meaning.equals(m.meaning))) && (placeholders.equals(m.placeholders))) && ((desc) == null ? (m.desc) == null : desc.equals(m.desc))) && ((sourceName) == null ? (m.sourceName) == null : sourceName.equals(m.sourceName))) && ((hidden) == (m.hidden))
Preconditions.checkState((var != null), "Type tightener could not find variable with name %s", lhs.getString())
return ((parent != null) && (parent.isAssign())) && ((parent.getFirstChild()) != n)
Preconditions.checkArgument(((node == null) || (node.isExprResult())))
Preconditions.checkState(((explicitNode) == null))
return (explicitNode) != null
return ((value != null) && (value.isObjectLit())) && (!(value.hasChildren()))
boolean singleGlobalParentDecl = ((owner != null) && ((owner.getDeclaration()) != null)) && ((owner.localSets) == 0)
boolean singleGlobalParentDecl = ((owner != null) && ((owner.getDeclaration()) != null)) && ((owner.localSets) == 0)
boolean isKnownAlias = (aliaser.isCall()) && (((convention.getClassesDefinedByCall(aliaser)) != null) || ((convention.getSingletonGetterClassName(aliaser)) != null))
boolean isKnownAlias = (aliaser.isCall()) && (((convention.getClassesDefinedByCall(aliaser)) != null) || ((convention.getSingletonGetterClassName(aliaser)) != null))
return (n.getFirstChild()) != null
return ((reservedKeywords) != null) && (reservedKeywords.contains(identifier))
return (grandchild != null) && (grandchild.isFunction())
return !((functionName == null) || (!(ExportTestFunctions.TEST_FUNCTIONS_NAME_PATTERN.matcher(functionName).matches())))
boolean isTopFunction = thatIsVarArgs && (((thatParamType == null) || (thatParamType.isUnknownType())) || (thatParamType.isNoType()))
return ((returnType) == null) || (returnType.isUnknownType())
return (info != null) && (info.isConstructor())
return ((((((objType == null) || (invalidatingTypes.contains(objType))) || (!(objType.hasReferenceName()))) || (objType.isUnknownType())) || (objType.isEmptyType())) || (objType.isEnumType())) || ((objType.autoboxesTo()) != null)
return ((((((objType == null) || (invalidatingTypes.contains(objType))) || (!(objType.hasReferenceName()))) || (objType.isUnknownType())) || (objType.isEmptyType())) || (objType.isEnumType())) || ((objType.autoboxesTo()) != null)
Preconditions.checkArgument((stringValue != null))
Node marker = IR.string((interfaceType == null ? "instance_of__" + className : "implements__" + (interfaceType.getReferenceName())))
return (NodeUtil.isExprCall(next)) && ((compiler.getCodingConvention().getClassesDefinedByCall(next.getFirstChild())) != null)
Preconditions.checkArgument((paths != null))
Preconditions.checkArgument((showType != null))
handleUnresolvedType(reporter, ((value == null) || (value.isUnknownType())))
Preconditions.checkState(((aliasedFunctions) == null))
return (Keywords.get(value)) != null
Preconditions.checkState((((assign != null) && (NodeUtil.isAssignmentOp(assign))) && ((assign.getFirstChild()) == n)))
return (code) != null
boolean isNewStyleMessage = (msgNode != null) && (msgNode.isCall())
Preconditions.checkState(((jsRoot) == null))
Preconditions.checkState(((jsRoot) == null))
Preconditions.checkState((((compilerThread) == null) || ((compilerThread) == (Thread.currentThread()))), "Please do not share the Compiler across threads")
final boolean dumpTraceReport = ((options) != null) && (options.tracer.isOn())
Preconditions.checkState(((currentTracer) == null))
Preconditions.checkState(((currentTracer) != null), "Tracer should not be null at the end of a pass.")
Preconditions.checkState(((getInput(id)) == null), "Duplicate input %s", id.getIdName())
inputs = ((moduleGraph) == null ? new JSModuleGraph(modules) : moduleGraph).manageDependencies(options.dependencyOptions, inputs)
Preconditions.checkState((sourceName != null))
return (lastChild != null) && ((lastChild.isOptionalArg()) || (lastChild.isVarArgs()))
return (lastChild != null) && (lastChild.isVarArgs())
boolean isOverride = (((parent.getJSDocInfo()) != null) && (parent.isAssign())) && ((parent.getFirstChild()) == getprop)
boolean sameInput = (referenceSource != null) && (referenceSource.equals(definingSource))
return (((deprecatedDepth) > 0) || ((CheckAccessControls.getTypeDeprecationInfo(t.getScope().getTypeOfThis())) != null)) || (((scopeRootParent != null) && (scopeRootParent.isAssign())) && ((CheckAccessControls.getTypeDeprecationInfo(getClassOfMethod(scopeRoot, scopeRootParent))) != null))
return (((deprecatedDepth) > 0) || ((CheckAccessControls.getTypeDeprecationInfo(t.getScope().getTypeOfThis())) != null)) || (((scopeRootParent != null) && (scopeRootParent.isAssign())) && ((CheckAccessControls.getTypeDeprecationInfo(getClassOfMethod(scopeRoot, scopeRootParent))) != null))
return (((deprecatedDepth) > 0) || ((CheckAccessControls.getTypeDeprecationInfo(t.getScope().getTypeOfThis())) != null)) || (((scopeRootParent != null) && (scopeRootParent.isAssign())) && ((CheckAccessControls.getTypeDeprecationInfo(getClassOfMethod(scopeRoot, scopeRootParent))) != null))
return (CheckAccessControls.getTypeDeprecationInfo(type)) != null
Assert.assertTrue(((("Both types must be null, or both must be non-null " + a) + ",") + b), ((a == null) == (b == null)))
Assert.assertTrue(((("Both types must be null, or both must be non-null " + a) + ",") + b), ((a == null) == (b == null)))
compiler.report(JSError.make(NodeUtil.getSourceName(n), n, VarCheck.VAR_MULTIPLY_DECLARED_ERROR, name, ((origVar.input) != null ? origVar.input.getName() : "??")))
return (info != null) && (info.getSuppressions().contains("duplicate"))
return otherAliasVar != null
Preconditions.checkState((externsAndJs != null))
Preconditions.checkState(((externsRoot == null) || (externsAndJs.hasChild(externsRoot))))
Preconditions.checkState(((scopeCreator) == null))
Preconditions.checkState(((topScope) == null))
Preconditions.checkState(((jsRoot.getParent()) != null))
boolean superClassHasProperty = (superClass != null) && (superClass.getInstanceType().hasProperty(propertyName))
boolean superClassHasDeclaredProperty = (superClass != null) && (superClass.getInstanceType().isPropertyTypeDeclared(propertyName))
boolean declaredOverride = (info != null) && (info.isOverride())
return ((parent == null) || (!(parent.isScript()))) || (!(t.getInput().isExtern()))
boolean notProvidedByConstructors = ((constructors) == null) || (!(constructors.contains(className)))
boolean notProvidedByRequires = ((requires) == null) || ((!(requires.contains(className))) && (!(requires.contains(outermostClassName))))
return (((name != null) && ((name.length()) > 1)) && (Character.isUpperCase(name.charAt(0)))) && (!(name.equals(name.toUpperCase())))
return ((info != null) && (valueNode != null)) && ((((info.isConstructor()) && (valueNode.isFunction())) || ((info.isInterface()) && (valueNode.isFunction()))) || ((info.hasEnumParameterType()) && (valueNode.isObjectLit())))
return ((info != null) && (valueNode != null)) && ((((info.isConstructor()) && (valueNode.isFunction())) || ((info.isInterface()) && (valueNode.isFunction()))) || ((info.hasEnumParameterType()) && (valueNode.isObjectLit())))
return ((!(inExterns)) && (!(isGetOrSetDefinition()))) && ((declaredType) || (((((parent) == null) || (parent.canCollapseUnannotatedChildNames())) && (((globalSets) > 0) || ((localSets) > 0))) && ((deleteProps) == 0)))
return ((parent) == null) || (parent.canCollapseUnannotatedChildNames())
return (parent) == null
return (externsRoot) != null
return (v != null) && (!(v.isLocal()))
return (s.getParent()) == null
Preconditions.checkState((((body.getNext()) == null) && (body.isBlock())))
assignedToUnknownValue = (value != null) && (!(NodeUtil.isLiteralValue(value, true)))
return (getNode(n)) != null
return (((n != null) && ((n.isCall()) || (n.isNew()))) && (n.hasChildren())) && ((qualifiedNameBeginsWithStripType(n.getFirstChild())) || (nameIncludesFieldNameToStrip(n.getFirstChild())))
return (((name != null) && (name.isName())) && (var.getName().equals(name.getString()))) && (NodeUtil.isAssignmentOp(n))
return (((name != null) && (name.isName())) && (var.getName().equals(name.getString()))) && (!(NodeUtil.isVarOrSimpleAssignLhs(name, name.getParent())))
Preconditions.checkState(((compiler) != null))
return (currentInfo.getDescription()) != null
return ((((((((currentInfo.isConstructor()) || (currentInfo.isInterface())) || ((currentInfo.getParameterCount()) > 0)) || (currentInfo.hasReturnType())) || (currentInfo.hasBaseType())) || ((currentInfo.getExtendedInterfacesCount()) > 0)) || ((currentInfo.getLendsName()) != null)) || (currentInfo.hasThisType())) || (hasAnySingletonTypeTags())
Preconditions.checkState((externsAndJs != null))
Preconditions.checkState(((externsRoot == null) || (externsAndJs.hasChild(externsRoot))))
return (info != null) && (info.containsDeclaration())
allowDupe = (info != null) && (info.getSuppressions().contains("duplicate"))
return ((isEmptyType()) || (isUnknownType())) || ((getSlot(propertyName)) != null)
return (getOwnSlot(propertyName)) != null
return (getOwnerFunction()) != null
return (n == null) || ((!(NodeUtil.canBeSideEffected(n))) && (!(mayHaveSideEffects(n))))
return (input != null) && (input.isReturn())
return !(((ancestors.size()) == 1) && ((ancestors.peek().getNext()) == null))
this.valueHasSideEffects = (valueNode != null) && (NodeUtil.mayHaveSideEffects(valueNode))
return (lookAhead) != null
Preconditions.checkState(((jsonml) != null))
return (input.getSourceFileName()) != null
return (getParameterType(parameter)) != null
return (thisType) != null
return ((info) != null) && (info.jaggerInject)
return ((info) != null) && (info.jaggerProvide)
return ((info) != null) && (info.jaggerModule)
return (info.disposedParameters) != null
return (getBaseType()) != null
return ((info) != null) && ((info.modifies) != null)
return ((info) != null) && ((info.modifies) != null)
return String.format("%s at %s line %s %s", description, (Strings.isNullOrEmpty(sourceName) ? "(unknown source)" : sourceName), (lineNumber < 0 ? String.valueOf(lineNumber) : "(unknown line)"), (lineSource != null ? ":\n\n" + lineSource : "."))
Preconditions.checkState((parent != null), "Cannot find continue target.")
return (ControlFlowAnalysis.isBreakStructure(target, (label != null))) && (ControlFlowAnalysis.matchLabel(target.getParent(), label))
return (variableParent != null) && (variableParent.isParamList())
Preconditions.checkState(((this.newName) == null))
boolean local = ((var != null) && (var.isLocal())) && ((!(var.scope.getParent().isGlobal())) || (!(var.isBleedingFunction())))
boolean isBleedingIntoScope = ((s.getParent()) != null) && (localBleedingFunctions.contains(v))
assert sourceFile != null
return (current) != null
return (cur) != null
Preconditions.checkArgument(((child.parent) == null), "new child has existing parent")
Preconditions.checkArgument(((child.next) == null), "new child has existing sibling")
Preconditions.checkArgument(((left.parent) == null), "first new child has existing parent")
Preconditions.checkArgument(((left.next) == null), "first new child has existing sibling")
Preconditions.checkArgument(((right.parent) == null), "second new child has existing parent")
Preconditions.checkArgument(((right.next) == null), "second new child has existing sibling")
Preconditions.checkArgument(((left.parent) == null))
Preconditions.checkArgument(((left.next) == null))
Preconditions.checkArgument(((mid.parent) == null))
Preconditions.checkArgument(((mid.next) == null))
Preconditions.checkArgument(((right.parent) == null))
Preconditions.checkArgument(((right.next) == null))
Preconditions.checkArgument(((left.parent) == null))
Preconditions.checkArgument(((left.next) == null))
Preconditions.checkArgument(((mid.parent) == null))
Preconditions.checkArgument(((mid.next) == null))
Preconditions.checkArgument(((mid2.parent) == null))
Preconditions.checkArgument(((mid2.next) == null))
Preconditions.checkArgument(((right.parent) == null))
Preconditions.checkArgument(((right.next) == null))
Preconditions.checkArgument(((children[(i - 1)].parent) == null))
Preconditions.checkArgument(((children[((children.length) - 1)].parent) == null))
return (first) != null
Preconditions.checkArgument(((child.parent) == null))
Preconditions.checkArgument(((child.next) == null))
Preconditions.checkArgument(((child.parent) == null))
Preconditions.checkArgument(((child.next) == null))
Preconditions.checkArgument(((child.parent) == null))
Preconditions.checkArgument(((node != null) && ((node.parent) == (this))), "The existing child node of the parent should not be null.")
Preconditions.checkArgument(((newChild.next) == null), "The new child node has siblings.")
Preconditions.checkArgument(((newChild.parent) == null), "The new child node already has a parent.")
Preconditions.checkArgument(((newChild.next) == null), "The new child node has siblings.")
Preconditions.checkArgument(((node == null) || ((node.parent) == (this))))
Preconditions.checkArgument(((child.parent) == null))
Preconditions.checkArgument(((newChild.next) == null), "The new child node has siblings.")
Preconditions.checkArgument(((newChild.parent) == null), "The new child node already has a parent.")
Preconditions.checkArgument(((newChild.next) == null), "The new child node has siblings.")
Preconditions.checkArgument(((newChild.parent) == null), "The new child node already has a parent.")
Preconditions.checkState(((this.propListHead) == null), "Node has existing properties.")
return ((first) != null) && ((first) == (last))
return ((first) != null) && ((first) != (last))
Preconditions.checkState(((parent) != null))
Preconditions.checkArgument(((prev.next) != null), "no next sibling.")
check(((tree.operand.asNewExpression().arguments) != null), tree.operand, "new arguments expected")
check(((tree.operand.asNewExpression().arguments) != null), tree.operand, "new arguments expected")
check(((tree.operand.asNewExpression().arguments) != null), tree.operand, "new arguments expected")
boolean initialized = (name.getDeclaration()) != null
Preconditions.checkState(((lang) == null))
Preconditions.checkState((((lang) != null) && (!(lang.isEmpty()))))
Preconditions.checkState(((msgBuilder) == null))
Preconditions.checkState(((id != null) && (!(id.isEmpty()))))
Preconditions.checkState(((msgBuilder) != null))
Preconditions.checkState(((msgBuilder) != null))
Preconditions.checkState(((blacklist != null) && (!(blacklist.isEmpty()))), "Not checking use of goog.getCssName because of empty blacklist.")
return new PassConfig.State(((cssNames) == null ? null : Maps.newHashMap(cssNames)), ((exportedNames) == null ? null : Collections.unmodifiableSet(exportedNames)), crossModuleIdGenerator, variableMap, propertyMap, anonymousFunctionNameMap, stringMap, functionNames, idGeneratorMap)
return new PassConfig.State(((cssNames) == null ? null : Maps.newHashMap(cssNames)), ((exportedNames) == null ? null : Collections.unmodifiableSet(exportedNames)), crossModuleIdGenerator, variableMap, propertyMap, anonymousFunctionNameMap, stringMap, functionNames, idGeneratorMap)
return ObjectType.cast((type == null ? null : type.dereference()))
return (((v != null) && (v.isLocal())) && (v.isMarkedEscaped())) && ((v.getScope()) == (syntacticScope))
boolean descend = (((parent == null) || (!(parent.isFunction()))) || (n == (parent.getFirstChild()))) || (parent == (scope.getRootNode()))
boolean inferred = keyType == null
Preconditions.checkState(((sourceName) != null))
boolean isFnLiteral = (rValue != null) && (rValue.isFunction())
defineSlot(name, parent, type, (type == null))
Preconditions.checkArgument((inferred || (type != null)))
boolean isValidValue = (initialValue != null) && ((initialValue.isObjectLit()) || (initialValue.isQualifiedName()))
scopeToDeclareIn.declare(prototypeName, n, prototypeSlot.getType(), input, ((superClassCtor == null) || (superClassCtor.getInstanceType().isEquivalentTo(getNativeType(JSTypeNative.OBJECT_TYPE)))))
return (scope != null) && (scope.isGlobal())
Preconditions.checkArgument(((qName != null) && (ownerName != null)))
Preconditions.checkArgument(((qName != null) && (ownerName != null)))
stubDeclarations.add(new TypedScopeCreator.StubDeclaration(n, (((t.getInput()) != null) && (t.getInput().isExtern())), ownerName))
boolean isExtern = ((t.getInput()) != null) && (t.getInput().isExtern())
inferred = !((((info.hasType()) || (info.hasEnumParameterType())) || (((isConstantSymbol(info, n)) && (valueType != null)) && (!(valueType.isUnknownType())))) || (FunctionTypeBuilder.isFunctionTypeDeclaration(info)))
return ObjectType.cast((ownerVarType == null ? null : ownerVarType.restrictByNotNullOrUndefined()))
boolean inferred = (paramType == null) || (paramType == (unknownType))
Preconditions.checkArgument((((module == null) || ((this.module) == null)) || ((this.module) == module)))
Preconditions.checkArgument((((module == null) || ((this.module) == null)) || ((this.module) == module)))
Preconditions.checkState((fnRecursionName != null))
Preconditions.checkState(((parent.getFirstChild()) == null))
boolean checkModules = isRemovable && (fnModule != null)
boolean isStatic = (eatOpt(TokenType.STATIC)) != null
boolean isStatic = allowStatic && ((eatOpt(TokenType.STATIC)) != null)
boolean isStatic = (eatOpt(TokenType.STATIC)) != null
boolean isStatic = (eatOpt(TokenType.STATIC)) != null
Preconditions.checkState(((scope.getParent()) == null))
return (waiting) == null
return ((isDeclaration()) && (!(getParent().isVar()))) || ((nameNode.getFirstChild()) != null)
return (((((parentType == (Token.VAR)) && ((nameNode.getFirstChild()) != null)) || (parentType == (Token.INC))) || (parentType == (Token.DEC))) || ((NodeUtil.isAssignmentOp(parent)) && ((parent.getFirstChild()) == (nameNode)))) || (ReferenceCollectingCallback.Reference.isLhsOfForInExpression(nameNode))
return (getParent()) == null
return (gramps == null) || (!(gramps.isScript()))
Preconditions.checkArgument(((source == null) || ((Token.FUNCTION) == (source.getType()))))
Preconditions.checkArgument(((source == null) || ((Token.FUNCTION) == (source.getType()))))
Preconditions.checkArgument((name != null))
boolean replacedPrototype = oldPrototype != null
this.prototypeSlot = new Property("prototype", prototype, true, (propertyNode == null ? source : propertyNode))
boolean treatThisTypesAsCovariant = (((((other.typeOfThis.toObjectType()) != null) && ((other.typeOfThis.toObjectType().getConstructor()) != null)) && (other.typeOfThis.toObjectType().getConstructor().isInterface())) || (other.typeOfThis.isSubtype(this.typeOfThis))) || (this.typeOfThis.isSubtype(other.typeOfThis))
boolean treatThisTypesAsCovariant = (((((other.typeOfThis.toObjectType()) != null) && ((other.typeOfThis.toObjectType().getConstructor()) != null)) && (other.typeOfThis.toObjectType().getConstructor().isInterface())) || (other.typeOfThis.isSubtype(this.typeOfThis))) || (this.typeOfThis.isSubtype(other.typeOfThis))
return ((prototypeSlot) != null) || (super.hasCachedValues())
boolean preferLineBreaks = (type == (Token.SCRIPT)) || ((((type == (Token.BLOCK)) && (!preserveBlock)) && ((n.getParent()) != null)) && (n.getParent().isScript()))
boolean constructorHasArgs = (constructorNameNode.getNext()) != null
Preconditions.checkState(((value.getParent()) == null))
this(sourceName, node, (node != null ? node.getLineno() : -1), (node != null ? node.getCharno() : -1), type, null, arguments)
this(sourceName, node, (node != null ? node.getLineno() : -1), (node != null ? node.getCharno() : -1), type, null, arguments)
return ((((((((type.key) + ". ") + (description)) + " at ") + (((sourceName) != null) && ((sourceName.length()) > 0) ? sourceName : "(unknown source)")) + " line ") + ((lineNumber) != (-1) ? String.valueOf(lineNumber) : "(unknown line)")) + " : ") + ((charno) != (-1) ? String.valueOf(charno) : "(unknown column)")
return classes != null
return (constructor != null) && (constructor.isInterface())
boolean aliasable = (!(unaliasableGlobals.contains(dest.getString()))) && ((docInfo == null) || (!(docInfo.isNoAlias())))
Preconditions.checkState(((this.newName) == null))
boolean local = ((var != null) && (var.isLocal())) && ((!(var.scope.getParent().isGlobal())) || (!(var.isBleedingFunction())))
boolean isBleedingIntoScope = ((s.getParent()) != null) && (localBleedingFunctions.contains(v))
return (name != null) && (name.endsWith(CheckMissingGetCssName.GET_UNIQUE_ID_FUNCTION))
return (qname != null) && (isIdName(qname))
return ((((((objType == null) || (invalidatingTypes.contains(objType))) || (!(objType.hasReferenceName()))) || (objType.isUnknownType())) || (objType.isEmptyType())) || (objType.isEnumType())) || ((objType.autoboxesTo()) != null)
return ((((((objType == null) || (invalidatingTypes.contains(objType))) || (!(objType.hasReferenceName()))) || (objType.isUnknownType())) || (objType.isEmptyType())) || (objType.isEnumType())) || ((objType.autoboxesTo()) != null)
Preconditions.checkState((meaning != null))
String projectScopedMeaning = ((projectId) != null ? (projectId) + ": " : "") + meaning
return (fn) != null
Preconditions.checkState(((this.fn) == null))
return ((references) != null) && (!(references.isEmpty()))
Preconditions.checkArgument((compiler != null))
Preconditions.checkArgument((safeNameIdSupplier != null))
Preconditions.checkArgument((changed != null))
Preconditions.checkState((fn != null))
return (containingFunction(node)) == null
Preconditions.checkArgument(((typeofNode.getFirstChild()) != null))
return (parent != null) && (NodeUtil.isGet(parent))
Preconditions.checkArgument(((inputsSupplier == null) ^ (modulesSupplier == null)))
Preconditions.checkArgument(((inputsSupplier == null) ^ (modulesSupplier == null)))
Preconditions.checkState((specs != null))
Preconditions.checkState((jsFiles != null))
Preconditions.checkState((specs != null))
return ((options.sourceMapOutputPath) != null) && (options.sourceMapOutputPath.contains("%outname%"))
return ((!(config.module.isEmpty())) && (output != null)) && (output.contains("%outname%"))
Preconditions.checkArgument(((declaration.getJSType()) != null))
return ((input) == null) || (input.isExtern())
return ((nameNode) != null) && (NodeUtil.isConstantName(nameNode))
return (info != null) && (info.isDefine())
return (info != null) && (info.isNoShadow())
return ((((var.getParentNode()) != null) && ((var.getType()) == null)) && (var.getParentNode().isVar())) && (!(var.isExtern()))
return ((((var.getParentNode()) != null) && ((var.getType()) == null)) && (var.getParentNode().isVar())) && (!(var.isExtern()))
Preconditions.checkState(((name != null) && ((name.length()) > 0)))
Preconditions.checkState(((vars.get(name)) == null))
return (parent) == null
return (parent) != null
return (asNewExpression().arguments) != null
Preconditions.checkState((expressionRoot != null))
boolean allowWith = (info != null) && (info.getSuppressions().contains("with"))
Preconditions.checkArgument(((lastLink.nextLink) == null))
Preconditions.checkArgument((unsafe != null))
return ((!(skipRenaming)) && ((types) != null)) && ((types.allEquivalenceClasses().size()) > 1)
compiler.report(JSError.make(t.getSourceName(), n, propertiesToErrorFor.get(name), DisambiguateProperties.Warnings.INVALIDATION, name, (type == null ? "null" : type.toString()), n.toString(), suggestion))
compiler.report(JSError.make(t.getSourceName(), child, propertiesToErrorFor.get(name), DisambiguateProperties.Warnings.INVALIDATION, name, (type == null ? "null" : type.toString()), n.toString(), ""))
return (objType != null) && (!(objType.hasReferenceName()))
return (type.isEnumType()) || ((type.autoboxesTo()) != null)
return (((type == null) || (type.isAll())) || (type.isFunction())) || ((type.isInstance()) && (invalidatingTypes.contains(type.toInstance().instanceType)))
return (((var != null) && ((var.getScope()) == s)) && (!(isNamedParameter(var)))) && (!(blacklistedVars.contains(var)))
return (displayName != null) && (!(displayName.isEmpty()))
return (toMaybeUnionType()) != null
return (info != null) && (info.makesStructs())
return (info != null) && (info.makesDicts())
return (toMaybeFunctionType()) != null
return (toMaybeEnumElementType()) != null
return (toMaybeEnumType()) != null
return (toMaybeRecordType()) != null
return (toMaybeTemplatizedType()) != null
return (toMaybeTemplateType()) != null
return ((objType == null) || ("Array".equals(objType.getReferenceName()))) || ("Object".equals(objType.getReferenceName()))
assert record != null
return ((info != null) && (info.hasParameterType(paramName))) && (info.getParameterType(paramName).isOptionalArg())
return ((info != null) && (info.hasParameterType(paramName))) && (info.getParameterType(paramName).isVarArgs())
return ((className) != null) || ((ownerFunction) != null)
return ((className) != null) || ((ownerFunction) != null)
return (thatObj != null) && (isImplicitPrototype(thatObj))
Preconditions.checkState((((ownerFunction) == null) || (type == null)))
Preconditions.checkState((((ownerFunction) == null) || (type == null)))
boolean aIsNull = (slotA == null) || ((slotA.getType()) == null)
boolean aIsNull = (slotA == null) || ((slotA.getType()) == null)
boolean bIsNull = (slotB == null) || ((slotB.getType()) == null)
boolean bIsNull = (slotB == null) || ((slotB.getType()) == null)
return (info != null) && (info.isExpose())
boolean shouldBeConstant = ((info != null) && (info.isConstant())) || (NodeUtil.isConstantByConvention(compiler.getCodingConvention(), n, parent))
Preconditions.checkState((externsAndJs != null))
return (var != null) && (var.isConst())
boolean isFirstMessageTranslated = (bundle.getMessage(message1.getId())) != null
boolean isSecondMessageTranslated = (bundle.getMessage(message2.getId())) != null
Preconditions.checkState((result != null))
return (registerFunction) != null
return (registerCall) != null
Preconditions.checkState((nameNode != null))
Preconditions.checkState((value != null))
Preconditions.checkState((value != null))
Preconditions.checkArgument((paths != null))
return (properties.get(propertyName)) != null
return (getSlot(propertyName)) != null
return (properties.remove(name)) != null
CheckNotNull  in 4798ms
Exception in thread "main" spoon.SpoonException: Cannot create MethodTypingContext for method declared in different ClassTypingContext
	at spoon.support.visitor.MethodTypingContext.setMethod(MethodTypingContext.java:71)
	at spoon.support.visitor.ClassTypingContext.isSameSignature(ClassTypingContext.java:616)
	at spoon.support.visitor.ClassTypingContext.isSameSignature(ClassTypingContext.java:312)
	at spoon.support.reflect.declaration.CtTypeImpl$2.accept(CtTypeImpl.java:959)
	at spoon.support.reflect.declaration.CtTypeImpl$2.accept(CtTypeImpl.java:955)
	at spoon.reflect.visitor.chain.CtQueryImpl$OutputFunctionWrapper._accept(CtQueryImpl.java:444)
	at spoon.reflect.visitor.chain.CtQueryImpl$AbstractStep.accept(CtQueryImpl.java:308)
	at spoon.reflect.visitor.filter.AllTypeMembersFunction$1.accept(AllTypeMembersFunction.java:78)
	at spoon.reflect.visitor.filter.AllTypeMembersFunction$1.accept(AllTypeMembersFunction.java:73)
	at spoon.reflect.visitor.chain.CtQueryImpl$OutputFunctionWrapper._accept(CtQueryImpl.java:444)
	at spoon.reflect.visitor.chain.CtQueryImpl$AbstractStep.accept(CtQueryImpl.java:308)
	at spoon.reflect.visitor.filter.SuperInheritanceHierarchyFunction.sendResult(SuperInheritanceHierarchyFunction.java:360)
	at spoon.reflect.visitor.filter.SuperInheritanceHierarchyFunction.visitSuperInterfaces(SuperInheritanceHierarchyFunction.java:308)
	at spoon.reflect.visitor.filter.SuperInheritanceHierarchyFunction.visitSuperClasses(SuperInheritanceHierarchyFunction.java:266)
	at spoon.reflect.visitor.filter.SuperInheritanceHierarchyFunction.visitSuperClasses(SuperInheritanceHierarchyFunction.java:283)
	at spoon.reflect.visitor.filter.SuperInheritanceHierarchyFunction.apply(SuperInheritanceHierarchyFunction.java:248)
	at spoon.reflect.visitor.filter.SuperInheritanceHierarchyFunction.apply(SuperInheritanceHierarchyFunction.java:51)
	at spoon.reflect.visitor.chain.CtQueryImpl$LazyFunctionWrapper._accept(CtQueryImpl.java:478)
	at spoon.reflect.visitor.chain.CtQueryImpl$AbstractStep.accept(CtQueryImpl.java:308)
	at spoon.reflect.visitor.chain.CtQueryImpl.forEach(CtQueryImpl.java:94)
	at spoon.reflect.visitor.filter.AllTypeMembersFunction.apply(AllTypeMembersFunction.java:73)
	at spoon.reflect.visitor.filter.AllTypeMembersFunction.apply(AllTypeMembersFunction.java:36)
	at spoon.reflect.visitor.chain.CtQueryImpl$LazyFunctionWrapper._accept(CtQueryImpl.java:478)
	at spoon.reflect.visitor.chain.CtQueryImpl$AbstractStep.accept(CtQueryImpl.java:308)
	at spoon.reflect.visitor.chain.CtQueryImpl.forEach(CtQueryImpl.java:94)
	at spoon.support.reflect.declaration.CtTypeImpl.getAllMethods(CtTypeImpl.java:955)
	at spoon.reflect.visitor.ImportScannerImpl.isInCollisionWithLocalMethod(ImportScannerImpl.java:408)
	at spoon.reflect.visitor.ImportScannerImpl.addMethodImport(ImportScannerImpl.java:431)
	at spoon.reflect.visitor.ImportScannerImpl.visitCtExecutableReference(ImportScannerImpl.java:106)
	at spoon.support.reflect.reference.CtExecutableReferenceImpl.accept(CtExecutableReferenceImpl.java:84)
	at spoon.reflect.visitor.ImportScannerImpl.scan(ImportScannerImpl.java:135)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:157)
	at spoon.reflect.visitor.CtScanner.visitCtInvocation(CtScanner.java:495)
	at spoon.support.reflect.code.CtInvocationImpl.accept(CtInvocationImpl.java:56)
	at spoon.reflect.visitor.ImportScannerImpl.scan(ImportScannerImpl.java:135)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:157)
	at spoon.reflect.visitor.CtScanner.visitCtInvocation(CtScanner.java:494)
	at spoon.support.reflect.code.CtInvocationImpl.accept(CtInvocationImpl.java:56)
	at spoon.reflect.visitor.ImportScannerImpl.scan(ImportScannerImpl.java:135)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:157)
	at spoon.reflect.visitor.CtScanner.visitCtInvocation(CtScanner.java:494)
	at spoon.support.reflect.code.CtInvocationImpl.accept(CtInvocationImpl.java:56)
	at spoon.reflect.visitor.ImportScannerImpl.scan(ImportScannerImpl.java:135)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:157)
	at spoon.reflect.visitor.CtScanner.visitCtInvocation(CtScanner.java:494)
	at spoon.support.reflect.code.CtInvocationImpl.accept(CtInvocationImpl.java:56)
	at spoon.reflect.visitor.ImportScannerImpl.scan(ImportScannerImpl.java:135)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:157)
	at spoon.reflect.visitor.CtScanner.visitCtInvocation(CtScanner.java:494)
	at spoon.support.reflect.code.CtInvocationImpl.accept(CtInvocationImpl.java:56)
	at spoon.reflect.visitor.ImportScannerImpl.scan(ImportScannerImpl.java:135)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:157)
	at spoon.reflect.visitor.CtScanner.visitCtInvocation(CtScanner.java:494)
	at spoon.support.reflect.code.CtInvocationImpl.accept(CtInvocationImpl.java:56)
	at spoon.reflect.visitor.ImportScannerImpl.scan(ImportScannerImpl.java:135)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:157)
	at spoon.reflect.visitor.CtScanner.visitCtInvocation(CtScanner.java:494)
	at spoon.support.reflect.code.CtInvocationImpl.accept(CtInvocationImpl.java:56)
	at spoon.reflect.visitor.ImportScannerImpl.scan(ImportScannerImpl.java:135)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:157)
	at spoon.reflect.visitor.CtScanner.visitCtInvocation(CtScanner.java:494)
	at spoon.support.reflect.code.CtInvocationImpl.accept(CtInvocationImpl.java:56)
	at spoon.reflect.visitor.ImportScannerImpl.scan(ImportScannerImpl.java:135)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:157)
	at spoon.reflect.visitor.CtScanner.visitCtInvocation(CtScanner.java:494)
	at spoon.support.reflect.code.CtInvocationImpl.accept(CtInvocationImpl.java:56)
	at spoon.reflect.visitor.ImportScannerImpl.scan(ImportScannerImpl.java:135)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:157)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:141)
	at spoon.reflect.visitor.CtScanner.visitCtInvocation(CtScanner.java:496)
	at spoon.support.reflect.code.CtInvocationImpl.accept(CtInvocationImpl.java:56)
	at spoon.reflect.visitor.ImportScannerImpl.scan(ImportScannerImpl.java:135)
	at spoon.reflect.visitor.ImportScannerImpl.computeImports(ImportScannerImpl.java:204)
	at spoon.reflect.visitor.DefaultJavaPrettyPrinter.computeImports(DefaultJavaPrettyPrinter.java:293)
	at spoon.support.reflect.declaration.CtElementImpl.toString(CtElementImpl.java:252)
	at java.lang.String.valueOf(String.java:2994)
	at java.io.PrintStream.println(PrintStream.java:821)
	at fr.inria.spirals.npefix.transformer.processors.CheckNotNull.process(CheckNotNull.java:118)
	at fr.inria.spirals.npefix.transformer.processors.CheckNotNull.process(CheckNotNull.java:29)
	at spoon.support.visitor.ProcessingVisitor.scan(ProcessingVisitor.java:81)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:157)
	at spoon.reflect.visitor.CtScanner.visitCtConditional(CtScanner.java:345)
	at spoon.support.reflect.code.CtConditionalImpl.accept(CtConditionalImpl.java:43)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:165)
	at spoon.support.visitor.ProcessingVisitor.scan(ProcessingVisitor.java:77)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:157)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:141)
	at spoon.reflect.visitor.CtScanner.visitCtInvocation(CtScanner.java:496)
	at spoon.support.reflect.code.CtInvocationImpl.accept(CtInvocationImpl.java:56)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:165)
	at spoon.support.visitor.ProcessingVisitor.scan(ProcessingVisitor.java:77)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:157)
	at spoon.reflect.visitor.CtScanner.visitCtInvocation(CtScanner.java:494)
	at spoon.support.reflect.code.CtInvocationImpl.accept(CtInvocationImpl.java:56)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:165)
	at spoon.support.visitor.ProcessingVisitor.scan(ProcessingVisitor.java:77)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:157)
	at spoon.reflect.visitor.CtScanner.visitCtInvocation(CtScanner.java:494)
	at spoon.support.reflect.code.CtInvocationImpl.accept(CtInvocationImpl.java:56)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:165)
	at spoon.support.visitor.ProcessingVisitor.scan(ProcessingVisitor.java:77)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:157)
	at spoon.reflect.visitor.CtScanner.visitCtInvocation(CtScanner.java:494)
	at spoon.support.reflect.code.CtInvocationImpl.accept(CtInvocationImpl.java:56)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:165)
	at spoon.support.visitor.ProcessingVisitor.scan(ProcessingVisitor.java:77)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:157)
	at spoon.reflect.visitor.CtScanner.visitCtInvocation(CtScanner.java:494)
	at spoon.support.reflect.code.CtInvocationImpl.accept(CtInvocationImpl.java:56)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:165)
	at spoon.support.visitor.ProcessingVisitor.scan(ProcessingVisitor.java:77)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:157)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:141)
	at spoon.reflect.visitor.CtScanner.visitCtInvocation(CtScanner.java:496)
	at spoon.support.reflect.code.CtInvocationImpl.accept(CtInvocationImpl.java:56)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:165)
	at spoon.support.visitor.ProcessingVisitor.scan(ProcessingVisitor.java:77)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:157)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:141)
	at spoon.reflect.visitor.CtScanner.visitCtBlock(CtScanner.java:291)
	at spoon.support.reflect.code.CtBlockImpl.accept(CtBlockImpl.java:48)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:165)
	at spoon.support.visitor.ProcessingVisitor.scan(ProcessingVisitor.java:77)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:157)
	at spoon.reflect.visitor.CtScanner.visitCtMethod(CtScanner.java:549)
	at spoon.support.reflect.declaration.CtMethodImpl.accept(CtMethodImpl.java:70)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:165)
	at spoon.support.visitor.ProcessingVisitor.scan(ProcessingVisitor.java:77)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:157)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:141)
	at spoon.reflect.visitor.CtScanner.visitCtClass(CtScanner.java:327)
	at spoon.support.reflect.declaration.CtClassImpl.accept(CtClassImpl.java:68)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:165)
	at spoon.support.visitor.ProcessingVisitor.scan(ProcessingVisitor.java:77)
	at spoon.support.QueueProcessingManager.process(QueueProcessingManager.java:119)
	at fr.inria.spirals.npefix.main.all.Launcher.instrument(Launcher.java:105)
	at fr.inria.spirals.npefix.main.run.Main.run(Main.java:61)
	at fr.inria.spirals.npefix.main.run.Main.main(Main.java:48)
Command exited with non-zero status 1
61.98user 1.63system 0:19.95elapsed 318%CPU (0avgtext+0avgdata 1699416maxresident)k
31544inputs+152outputs (15major+445097minor)pagefaults 0swaps


Node: suno-30.sophia.grid5000.fr



Date: Sat May  4 20:35:19 EDT 2019

