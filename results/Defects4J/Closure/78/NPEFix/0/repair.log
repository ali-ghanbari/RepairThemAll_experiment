cd /tmp/NPEFix_Defects4J_Closure_78;
export JAVA_TOOL_OPTIONS="-Dfile.encoding=UTF8 -Duser.language=en-US -Duser.country=US -Duser.language=en";
TZ="America/New_York"; export TZ;
export PATH="/usr/lib/jvm/java-1.8.0-openjdk-amd64/bin/:$PATH";
export JAVA_HOME="/usr/lib/jvm/java-1.8.0-openjdk-amd64/bin/";
time java -Xmx4g -Xms1g -cp /home/tdurieux/RepairThemAll/script/../repair_tools/npefix.jar fr.inria.spirals.npefix.main.run.Main \
    --test com.google.javascript.jscomp.PeepholeFoldConstantsTest \
    --iteration 100 \
	--complianceLevel 6 \
	--workingdirectory . \
	--source src/ \
	--classpath build/classes/:build/test/:/tmp/NPEFix_Defects4J_Closure_78/build/classes:/tmp/NPEFix_Defects4J_Closure_78/build/test:/tmp/NPEFix_Defects4J_Closure_78/lib/guava.jar:/tmp/NPEFix_Defects4J_Closure_78/lib/ant-launcher.jar:/tmp/NPEFix_Defects4J_Closure_78/lib/libtrunk_rhino_parser_jarjared.jar:/tmp/NPEFix_Defects4J_Closure_78/lib/ant.jar:/tmp/NPEFix_Defects4J_Closure_78/lib/json.jar:/tmp/NPEFix_Defects4J_Closure_78/lib/args4j.jar:/tmp/NPEFix_Defects4J_Closure_78/lib/jsr305.jar:/tmp/NPEFix_Defects4J_Closure_78/lib/protobuf-java.jar:/tmp/NPEFix_Defects4J_Closure_78/lib/junit.jar:/tmp/NPEFix_Defects4J_Closure_78/lib/caja-r4314.jar;
	echo "\n\nNode: `hostname`\n";
	echo "\n\nDate: `date`\n";
Picked up JAVA_TOOL_OPTIONS: -Dfile.encoding=UTF8 -Duser.language=en-US -Duser.country=US -Duser.language=en
TernarySplitter  in 698ms
assert sourceFile != null
return (current) != null
return (cur) != null
Preconditions.checkArgument(((child.parent) == null), "new child has existing parent")
Preconditions.checkArgument(((child.next) == null), "new child has existing sibling")
Preconditions.checkArgument(((left.parent) == null), "first new child has existing parent")
Preconditions.checkArgument(((left.next) == null), "first new child has existing sibling")
Preconditions.checkArgument(((right.parent) == null), "second new child has existing parent")
Preconditions.checkArgument(((right.next) == null), "second new child has existing sibling")
Preconditions.checkArgument(((left.parent) == null))
Preconditions.checkArgument(((left.next) == null))
Preconditions.checkArgument(((mid.parent) == null))
Preconditions.checkArgument(((mid.next) == null))
Preconditions.checkArgument(((right.parent) == null))
Preconditions.checkArgument(((right.next) == null))
Preconditions.checkArgument(((left.parent) == null))
Preconditions.checkArgument(((left.next) == null))
Preconditions.checkArgument(((mid.parent) == null))
Preconditions.checkArgument(((mid.next) == null))
Preconditions.checkArgument(((mid2.parent) == null))
Preconditions.checkArgument(((mid2.next) == null))
Preconditions.checkArgument(((right.parent) == null))
Preconditions.checkArgument(((right.next) == null))
Preconditions.checkArgument(((children[(i - 1)].parent) == null))
Preconditions.checkArgument(((children[((children.length) - 1)].parent) == null))
return (first) != null
Preconditions.checkArgument(((child.parent) == null))
Preconditions.checkArgument(((child.next) == null))
Preconditions.checkArgument(((child.parent) == null))
Preconditions.checkArgument(((child.next) == null))
Preconditions.checkArgument(((child.parent) == null))
Preconditions.checkArgument(((child.parent) == null))
Preconditions.checkArgument((node != null), "The existing child node of the parent should not be null.")
Preconditions.checkArgument(((newChild.next) == null), "The new child node has siblings.")
Preconditions.checkArgument(((newChild.parent) == null), "The new child node already has a parent.")
Preconditions.checkArgument(((newChild.next) == null), "The new child node has siblings.")
Preconditions.checkArgument(((newChild.parent) == null), "The new child node already has a parent.")
Preconditions.checkArgument(((newChild.next) == null), "The new child node has siblings.")
Preconditions.checkArgument(((newChild.parent) == null), "The new child node already has a parent.")
Preconditions.checkArgument(((newChild.next) == null), "The new child node has siblings.")
Preconditions.checkArgument(((newChild.parent) == null), "The new child node already has a parent.")
Preconditions.checkState(((this.propListHead) == null), "Node has existing properties.")
return ((first) != null) && ((first) == (last))
return ((first) != null) && ((first) != (last))
Preconditions.checkState(((parent) != null))
Preconditions.checkArgument(((prev.next) != null), "no next sibling.")
return ((mismatchA) == null) && ((mismatchB) == null)
return ((mismatchA) == null) && ((mismatchB) == null)
boolean initialized = (name.declaration) != null
Preconditions.checkState(((blacklist != null) && (!(blacklist.isEmpty()))), "Not checking use of goog.getCssName because of empty blacklist.")
return new PassConfig.State(((cssNames) == null ? null : Maps.newHashMap(cssNames)), ((exportedNames) == null ? null : Collections.unmodifiableSet(exportedNames)), crossModuleIdGenerator, variableMap, propertyMap, anonymousFunctionNameMap, stringMap, functionNames, idGeneratorMap)
return new PassConfig.State(((cssNames) == null ? null : Maps.newHashMap(cssNames)), ((exportedNames) == null ? null : Collections.unmodifiableSet(exportedNames)), crossModuleIdGenerator, variableMap, propertyMap, anonymousFunctionNameMap, stringMap, functionNames, idGeneratorMap)
return ObjectType.cast((type == null ? null : type.dereference()))
Preconditions.checkState((references != null))
boolean nonLocalInferredSlot = (isInferred && ((syntacticScope.getParent()) != null)) && (var == (syntacticScope.getParent().getSlot(varName)))
boolean hasLendsName = ((n.getJSDocInfo()) != null) && ((n.getJSDocInfo().getLendsName()) != null)
boolean hasLendsName = ((n.getJSDocInfo()) != null) && ((n.getJSDocInfo().getLendsName()) != null)
boolean descend = (((parent == null) || ((parent.getType()) != (Token.FUNCTION))) || (n == (parent.getFirstChild()))) || (parent == (scope.getRootNode()))
boolean isExtern = ((t.getInput()) != null) && (t.getInput().isExtern())
Preconditions.checkState(((sourceName) != null))
boolean isFnLiteral = (rValue != null) && ((rValue.getType()) == (Token.FUNCTION))
defineSlot(name, parent, type, (type == null))
Preconditions.checkArgument((inferred || (type != null)))
boolean isValidValue = (initialValue != null) && (((initialValue.getType()) == (Token.OBJECTLIT)) || (initialValue.isQualifiedName()))
scopeToDeclareIn.declare((variableName + ".prototype"), n, fnType.getPrototype(), input, ((superClassCtor == null) || (superClassCtor.getInstanceType().equals(getNativeType(JSTypeNative.OBJECT_TYPE)))))
Preconditions.checkArgument(((qName != null) && (ownerName != null)))
Preconditions.checkArgument(((qName != null) && (ownerName != null)))
stubDeclarations.add(new TypedScopeCreator.StubDeclaration(n, (((t.getInput()) != null) && (t.getInput().isExtern())), ownerName))
inferred = !((((info.hasType()) || (info.hasEnumParameterType())) || (((info.isConstant()) && (valueType != null)) && (!(valueType.isUnknownType())))) || (FunctionTypeBuilder.isFunctionTypeDeclaration(info)))
inferred = !(((rhsValue != null) && ((rhsValue.getType()) == (Token.FUNCTION))) && (!(scope.isDeclared(qName, false))))
boolean isExtern = ((t.getInput()) != null) && (t.getInput().isExtern())
return ObjectType.cast((ownerVarType == null ? null : ownerVarType.restrictByNotNullOrUndefined()))
Preconditions.checkArgument((((module == null) || ((this.module) == null)) || ((this.module) == module)))
Preconditions.checkArgument((((module == null) || ((this.module) == null)) || ((this.module) == module)))
Preconditions.checkState((fnRecursionName != null))
Preconditions.checkState(((parent.getFirstChild()) == null))
boolean checkModules = isRemovable && (fnModule != null)
return JsMessage.Hash.hash64(value, 0, (value == null ? 0 : value.length), seed)
Preconditions.checkState((key != null))
Preconditions.checkState((id != null))
return ((((((((id.equals(m.id)) && (key.equals(m.key))) && ((isAnonymous) == (m.isAnonymous))) && (parts.equals(m.parts))) && ((meaning) == null ? (m.meaning) == null : meaning.equals(m.meaning))) && (placeholders.equals(m.placeholders))) && ((desc) == null ? (m.desc) == null : desc.equals(m.desc))) && ((sourceName) == null ? (m.sourceName) == null : sourceName.equals(m.sourceName))) && ((hidden) == (m.hidden))
return ((((((((id.equals(m.id)) && (key.equals(m.key))) && ((isAnonymous) == (m.isAnonymous))) && (parts.equals(m.parts))) && ((meaning) == null ? (m.meaning) == null : meaning.equals(m.meaning))) && (placeholders.equals(m.placeholders))) && ((desc) == null ? (m.desc) == null : desc.equals(m.desc))) && ((sourceName) == null ? (m.sourceName) == null : sourceName.equals(m.sourceName))) && ((hidden) == (m.hidden))
return ((((((((id.equals(m.id)) && (key.equals(m.key))) && ((isAnonymous) == (m.isAnonymous))) && (parts.equals(m.parts))) && ((meaning) == null ? (m.meaning) == null : meaning.equals(m.meaning))) && (placeholders.equals(m.placeholders))) && ((desc) == null ? (m.desc) == null : desc.equals(m.desc))) && ((sourceName) == null ? (m.sourceName) == null : sourceName.equals(m.sourceName))) && ((hidden) == (m.hidden))
return ((((((((id.equals(m.id)) && (key.equals(m.key))) && ((isAnonymous) == (m.isAnonymous))) && (parts.equals(m.parts))) && ((meaning) == null ? (m.meaning) == null : meaning.equals(m.meaning))) && (placeholders.equals(m.placeholders))) && ((desc) == null ? (m.desc) == null : desc.equals(m.desc))) && ((sourceName) == null ? (m.sourceName) == null : sourceName.equals(m.sourceName))) && ((hidden) == (m.hidden))
return ((((((((id.equals(m.id)) && (key.equals(m.key))) && ((isAnonymous) == (m.isAnonymous))) && (parts.equals(m.parts))) && ((meaning) == null ? (m.meaning) == null : meaning.equals(m.meaning))) && (placeholders.equals(m.placeholders))) && ((desc) == null ? (m.desc) == null : desc.equals(m.desc))) && ((sourceName) == null ? (m.sourceName) == null : sourceName.equals(m.sourceName))) && ((hidden) == (m.hidden))
return ((((((((id.equals(m.id)) && (key.equals(m.key))) && ((isAnonymous) == (m.isAnonymous))) && (parts.equals(m.parts))) && ((meaning) == null ? (m.meaning) == null : meaning.equals(m.meaning))) && (placeholders.equals(m.placeholders))) && ((desc) == null ? (m.desc) == null : desc.equals(m.desc))) && ((sourceName) == null ? (m.sourceName) == null : sourceName.equals(m.sourceName))) && ((hidden) == (m.hidden))
Preconditions.checkState((var != null), "Type tightener could not find variable with name %s", lhs.getString())
allowDupe = (info != null) && (info.getSuppressions().contains("duplicate"))
compiler.report(JSError.make(sourceName, n, SyntacticScopeCreator.VAR_MULTIPLY_DECLARED_ERROR, name, ((origVar.input) != null ? origVar.input.getName() : "??")))
Preconditions.checkState(((scope.getParent()) == null))
Preconditions.checkArgument(((node == null) || (NodeUtil.isExpressionNode(node))))
Preconditions.checkState(((explicitNode) == null))
return (explicitNode) != null
return ((value != null) && ((value.getType()) == (Token.OBJECTLIT))) && (!(value.hasChildren()))
return (((name.parent) != null) && ((name.parent.aliasingGets) == 0)) && ((name.parent.type) == (OBJECTLIT))
return (waiting) == null
return (isDeclaration()) && (((parent.getType()) != (Token.VAR)) || ((nameNode.getFirstChild()) != null))
return (((((parentType == (Token.VAR)) && ((nameNode.getFirstChild()) != null)) || (parentType == (Token.INC))) || (parentType == (Token.DEC))) || ((NodeUtil.isAssignmentOp(parent)) && ((parent.getFirstChild()) == (nameNode)))) || (ReferenceCollectingCallback.Reference.isLhsOfForInExpression(nameNode))
boolean hasObjectValues = (values) != null
return (n.getFirstChild()) != null
return (gramps == null) || ((gramps.getType()) != (Token.SCRIPT))
return ((reservedKeywords) != null) && (reservedKeywords.contains(identifier))
Preconditions.checkArgument(((source == null) || ((Token.FUNCTION) == (source.getType()))))
Preconditions.checkArgument(((source == null) || ((Token.FUNCTION) == (source.getType()))))
Preconditions.checkArgument((name != null))
boolean replacedPrototype = prototype != null
boolean treatThisTypesAsCovariant = ((((this.isConstructor()) || (other.isConstructor())) || (((other.typeOfThis.getConstructor()) != null) && (other.typeOfThis.getConstructor().isInterface()))) || (other.typeOfThis.isSubtype(this.typeOfThis))) || (this.typeOfThis.isSubtype(other.typeOfThis))
return ((prototype) != null) || (super.hasCachedValues())
Preconditions.checkState((childCount == (((n.getParent()) != null) && ((n.getParent().getType()) == (Token.OBJECTLIT)) ? 1 : 0)))
boolean preferLineBreaks = (type == (Token.SCRIPT)) || ((((type == (Token.BLOCK)) && (!preserveBlock)) && ((n.getParent()) != null)) && ((n.getParent().getType()) == (Token.SCRIPT)))
return (n == null) || ((!(NodeUtil.canBeSideEffected(n))) && (!(NodeUtil.mayHaveSideEffects(n))))
boolean constructorHasArgs = (constructorNameNode.getNext()) != null
this(sourceName, node, (node != null ? node.getLineno() : -1), (node != null ? node.getCharno() : -1), type, null, arguments)
this(sourceName, node, (node != null ? node.getLineno() : -1), (node != null ? node.getCharno() : -1), type, null, arguments)
return ((((((((type.key) + ". ") + (description)) + " at ") + (((sourceName) != null) && ((sourceName.length()) > 0) ? sourceName : "(unknown source)")) + " line ") + ((lineNumber) != (-1) ? String.valueOf(lineNumber) : "(unknown line)")) + " : ") + ((charno) != (-1) ? String.valueOf(charno) : "(unknown column)")
return classes != null
return ((activationNames) != null) && (activationNames.containsKey(name))
boolean aliasable = (!(unaliasableGlobals.contains(dest.getString()))) && ((docInfo == null) || (!(docInfo.isNoAlias())))
return (grandchild != null) && ((grandchild.getType()) == (Token.FUNCTION))
return !((functionName == null) || (!(ExportTestFunctions.TEST_FUNCTIONS_NAME_PATTERN.matcher(functionName).matches())))
return ((returnType) == null) || (returnType.isUnknownType())
Preconditions.checkState(((this.newName) == null))
boolean local = ((var != null) && (var.isLocal())) && ((!(var.scope.getParent().isGlobal())) || (!(var.isBleedingFunction())))
boolean isBleedingIntoScope = ((s.getParent()) != null) && (localBleedingFunctions.contains(v))
return (name != null) && (name.endsWith(CheckMissingGetCssName.GET_UNIQUE_ID_FUNCTION))
return (qname != null) && (isIdName(qname))
return (((((objType == null) || (invalidatingTypes.contains(objType))) || (!(objType.hasReferenceName()))) || (objType.isUnknownType())) || (objType.isEnumType())) || ((objType.autoboxesTo()) != null)
return (((((objType == null) || (invalidatingTypes.contains(objType))) || (!(objType.hasReferenceName()))) || (objType.isUnknownType())) || (objType.isEnumType())) || ((objType.autoboxesTo()) != null)
Node marker = Node.newString((interfaceType == null ? "instance_of__" + className : "implements__" + (interfaceType.getReferenceName())))
return (NodeUtil.isExprCall(next)) && ((compiler.getCodingConvention().getClassesDefinedByCall(next.getFirstChild())) != null)
boilerplateCode = boilerplateCode.replace("%%LOG%%", (logFunction == null ? "function(warning, expr) {}" : logFunction))
return (fn) != null
Preconditions.checkState(((this.fn) == null))
return ((references) != null) && (!(references.isEmpty()))
Preconditions.checkArgument((compiler != null))
Preconditions.checkArgument((safeNameIdSupplier != null))
Preconditions.checkArgument((changed != null))
Preconditions.checkState((fn != null))
Preconditions.checkArgument((paths != null))
Preconditions.checkArgument((showType != null))
return (containingFunction(node)) == null
Preconditions.checkArgument(((typeofNode.getFirstChild()) != null))
handleUnresolvedType(t, ((value == null) || (value.isUnknownType())))
Preconditions.checkState(((aliasedFunctions) == null))
return (parent != null) && (NodeUtil.isGet(parent))
return (code) != null
boolean isNewStyleMessage = (msgNode != null) && ((msgNode.getType()) == (Token.CALL))
Preconditions.checkState(((jsRoot) == null))
Preconditions.checkState(((jsRoot) == null))
Preconditions.checkState(((currentTracer) == null))
Preconditions.checkState(((currentTracer) != null), "Tracer should not be null at the end of a pass.")
Preconditions.checkState(((getInput(sourceName)) == null), ("Duplicate input of name " + sourceName))
inputs = ((moduleGraph) == null ? new JSModuleGraph(modules) : moduleGraph).manageDependencies(options.manageClosureDependenciesEntryPoints, inputs)
Preconditions.checkState((sourceName != null))
Preconditions.checkArgument(((inputsSupplier == null) ^ (modulesSupplier == null)))
Preconditions.checkArgument(((inputsSupplier == null) ^ (modulesSupplier == null)))
Preconditions.checkState((specs != null))
Preconditions.checkState((jsFiles != null))
Preconditions.checkState((specs != null))
return ((options.sourceMapOutputPath) != null) && (options.sourceMapOutputPath.contains("%outname%"))
return ((!(config.module.isEmpty())) && ((config.outputManifest) != null)) && (config.outputManifest.contains("%outname%"))
return (lastChild != null) && ((lastChild.isOptionalArg()) || (lastChild.isVarArgs()))
return (lastChild != null) && (lastChild.isVarArgs())
return (((deprecatedDepth) > 0) || ((CheckAccessControls.getTypeDeprecationInfo(t.getScope().getTypeOfThis())) != null)) || (((scopeRootParent != null) && ((scopeRootParent.getType()) == (Token.ASSIGN))) && ((CheckAccessControls.getTypeDeprecationInfo(getClassOfMethod(scopeRoot, scopeRootParent))) != null))
return (((deprecatedDepth) > 0) || ((CheckAccessControls.getTypeDeprecationInfo(t.getScope().getTypeOfThis())) != null)) || (((scopeRootParent != null) && ((scopeRootParent.getType()) == (Token.ASSIGN))) && ((CheckAccessControls.getTypeDeprecationInfo(getClassOfMethod(scopeRoot, scopeRootParent))) != null))
return (((deprecatedDepth) > 0) || ((CheckAccessControls.getTypeDeprecationInfo(t.getScope().getTypeOfThis())) != null)) || (((scopeRootParent != null) && ((scopeRootParent.getType()) == (Token.ASSIGN))) && ((CheckAccessControls.getTypeDeprecationInfo(getClassOfMethod(scopeRoot, scopeRootParent))) != null))
return (CheckAccessControls.getTypeDeprecationInfo(type)) != null
Preconditions.checkArgument(((declaration.getJSType()) != null))
return ((input) == null) || (input.isExtern())
Preconditions.checkState(((name != null) && ((name.length()) > 0)))
Preconditions.checkState(((vars.get(name)) == null))
Scope.Var var = new Scope.Var(inferred, name, nameNode, type, this, vars.size(), input, ((info != null) && (info.isDefine())), info)
return (parent) == null
Preconditions.checkState((expressionRoot != null))
Preconditions.checkArgument(((lastLink.nextLink) == null))
boolean allowWith = (info != null) && (info.getSuppressions().contains("with"))
return ((warningsGuard) != null) && (warningsGuard.enables(type))
return ((warningsGuard) != null) && (warningsGuard.disables(type))
Preconditions.checkArgument((unsafe != null))
return ((!(skipRenaming)) && ((types) != null)) && ((types.allEquivalenceClasses().size()) > 1)
compiler.report(JSError.make(t.getSourceName(), n, DisambiguateProperties.Warnings.INVALIDATION, name, (type == null ? "null" : type.toString()), n.toString()))
compiler.report(JSError.make(t.getSourceName(), child, DisambiguateProperties.Warnings.INVALIDATION, name, (type == null ? "null" : type.toString()), n.toString()))
return (objType != null) && (!(objType.hasReferenceName()))
return (type.isEnumType()) || ((type.autoboxesTo()) != null)
return (((type == null) || (type.isAll())) || (type.isFunction())) || ((type.isInstance()) && (invalidatingTypes.contains(type.toInstance().instanceType)))
Preconditions.checkState((externsAndJs != null))
Preconditions.checkState(((externsRoot == null) || (externsAndJs.hasChild(externsRoot))))
Preconditions.checkState(((scopeCreator) == null))
Preconditions.checkState(((topScope) == null))
Preconditions.checkState(((jsRoot.getParent()) != null))
boolean superClassHasProperty = (superClass != null) && (superClass.getPrototype().hasProperty(propertyName))
boolean declaredOverride = (info != null) && (info.isOverride())
return ((parent == null) || ((parent.getType()) != (Token.SCRIPT))) || (!(t.getInput().isExtern()))
Preconditions.checkState(((gramps != null) && ((gramps.getType()) == (Token.VAR))))
return (displayName != null) && (!(displayName.isEmpty()))
return ObjectType.cast((autobox == null ? restricted : autobox))
return (info != null) && (((info.isConstructor()) && (valueNodeType == (Token.FUNCTION))) || ((info.hasEnumParameterType()) && (valueNodeType == (Token.OBJECTLIT))))
return ((!(inExterns)) && (!(isGetOrSetDefinition()))) && ((isClassOrEnum) || ((((parent) == null) || (parent.canCollapseUnannotatedChildNames())) && (((globalSets) > 0) || ((localSets) > 0))))
return ((parent) == null) || (parent.canCollapseUnannotatedChildNames())
return (parent) == null
return (v != null) && (!(v.isLocal()))
return (s.getParent()) == null
Preconditions.checkState((((body.getNext()) == null) && ((body.getType()) == (Token.BLOCK))))
Preconditions.checkNotNull((var == null))
assignedToUnknownValue = (value != null) && (!(NodeUtil.isLiteralValue(value, true)))
return (getNode(n)) != null
return (((n != null) && (((n.getType()) == (Token.CALL)) || ((n.getType()) == (Token.NEW)))) && (n.hasChildren())) && ((qualifiedNameBeginsWithStripType(n.getFirstChild())) || (nameEndsWithFieldNameToStrip(n.getFirstChild())))
return ((propNode != null) && ((propNode.getType()) == (Token.STRING))) && (isStripName(propNode.getString()))
return (((name != null) && (NodeUtil.isName(name))) && (var.getName().equals(name.getString()))) && (NodeUtil.isAssignmentOp(n))
return (((name != null) && (NodeUtil.isName(name))) && (var.getName().equals(name.getString()))) && (!(NodeUtil.isLhs(name, name.getParent())))
return ((n.getJSDocInfo()) != null) && (n.getJSDocInfo().isConstructor())
Preconditions.checkState(((compiler) != null))
return (currentInfo.getDescription()) != null
return (((((((currentInfo.isConstructor()) || (currentInfo.isInterface())) || ((currentInfo.getParameterCount()) > 0)) || (currentInfo.hasReturnType())) || (currentInfo.hasBaseType())) || ((currentInfo.getLendsName()) != null)) || (currentInfo.hasThisType())) || (hasAnySingletonTypeTags())
assert record != null
Preconditions.checkState((externsAndJs != null))
Preconditions.checkState(((externsRoot == null) || (externsAndJs.hasChild(externsRoot))))
return (info != null) && (info.containsDeclaration())
allowDupe = (info != null) && (info.getSuppressions().contains("duplicate"))
return ((info != null) && (info.hasParameterType(paramName))) && (info.getParameterType(paramName).isOptionalArg())
return ((info != null) && (info.hasParameterType(paramName))) && (info.getParameterType(paramName).isVarArgs())
return (properties.get(propertyName)) != null
return (className) != null
return (input != null) && ((input.getType()) == (Token.RETURN))
boolean aIsNull = (slotA == null) || ((slotA.getType()) == null)
boolean aIsNull = (slotA == null) || ((slotA.getType()) == null)
boolean bIsNull = (slotB == null) || ((slotB.getType()) == null)
boolean bIsNull = (slotB == null) || ((slotB.getType()) == null)
boolean shouldBeConstant = ((info != null) && (info.isConstant())) || (NodeUtil.isConstantByConvention(compiler.getCodingConvention(), n, parent))
Preconditions.checkState((externsAndJs != null))
return (var != null) && (var.isConst())
return (string == null) || (string.isEmpty())
Preconditions.checkState((result != null))
return (registerFunction) != null
return (registerCall) != null
Preconditions.checkState((nameNode != null))
Preconditions.checkState((value != null))
Preconditions.checkState((value != null))
return (NodeUtil.isFunctionDeclaration(initialization.getParent())) || ((initialization.getNameNode().getFirstChild()) != null)
return !(((ancestors.size()) == 1) && ((ancestors.peek().getNext()) == null))
this.valueHasSideEffects = (valueNode != null) && (NodeUtil.mayHaveSideEffects(valueNode))
return (lookAhead) != null
CheckNotNull  in 4212ms
Exception in thread "main" spoon.SpoonException: Cannot create MethodTypingContext for method declared in different ClassTypingContext
	at spoon.support.visitor.MethodTypingContext.setMethod(MethodTypingContext.java:71)
	at spoon.support.visitor.ClassTypingContext.isSameSignature(ClassTypingContext.java:616)
	at spoon.support.visitor.ClassTypingContext.isSameSignature(ClassTypingContext.java:312)
	at spoon.support.reflect.declaration.CtTypeImpl$2.accept(CtTypeImpl.java:959)
	at spoon.support.reflect.declaration.CtTypeImpl$2.accept(CtTypeImpl.java:955)
	at spoon.reflect.visitor.chain.CtQueryImpl$OutputFunctionWrapper._accept(CtQueryImpl.java:444)
	at spoon.reflect.visitor.chain.CtQueryImpl$AbstractStep.accept(CtQueryImpl.java:308)
	at spoon.reflect.visitor.filter.AllTypeMembersFunction$1.accept(AllTypeMembersFunction.java:78)
	at spoon.reflect.visitor.filter.AllTypeMembersFunction$1.accept(AllTypeMembersFunction.java:73)
	at spoon.reflect.visitor.chain.CtQueryImpl$OutputFunctionWrapper._accept(CtQueryImpl.java:444)
	at spoon.reflect.visitor.chain.CtQueryImpl$AbstractStep.accept(CtQueryImpl.java:308)
	at spoon.reflect.visitor.filter.SuperInheritanceHierarchyFunction.sendResult(SuperInheritanceHierarchyFunction.java:360)
	at spoon.reflect.visitor.filter.SuperInheritanceHierarchyFunction.visitSuperInterfaces(SuperInheritanceHierarchyFunction.java:308)
	at spoon.reflect.visitor.filter.SuperInheritanceHierarchyFunction.visitSuperClasses(SuperInheritanceHierarchyFunction.java:266)
	at spoon.reflect.visitor.filter.SuperInheritanceHierarchyFunction.visitSuperClasses(SuperInheritanceHierarchyFunction.java:283)
	at spoon.reflect.visitor.filter.SuperInheritanceHierarchyFunction.apply(SuperInheritanceHierarchyFunction.java:248)
	at spoon.reflect.visitor.filter.SuperInheritanceHierarchyFunction.apply(SuperInheritanceHierarchyFunction.java:51)
	at spoon.reflect.visitor.chain.CtQueryImpl$LazyFunctionWrapper._accept(CtQueryImpl.java:478)
	at spoon.reflect.visitor.chain.CtQueryImpl$AbstractStep.accept(CtQueryImpl.java:308)
	at spoon.reflect.visitor.chain.CtQueryImpl.forEach(CtQueryImpl.java:94)
	at spoon.reflect.visitor.filter.AllTypeMembersFunction.apply(AllTypeMembersFunction.java:73)
	at spoon.reflect.visitor.filter.AllTypeMembersFunction.apply(AllTypeMembersFunction.java:36)
	at spoon.reflect.visitor.chain.CtQueryImpl$LazyFunctionWrapper._accept(CtQueryImpl.java:478)
	at spoon.reflect.visitor.chain.CtQueryImpl$AbstractStep.accept(CtQueryImpl.java:308)
	at spoon.reflect.visitor.chain.CtQueryImpl.forEach(CtQueryImpl.java:94)
	at spoon.support.reflect.declaration.CtTypeImpl.getAllMethods(CtTypeImpl.java:955)
	at spoon.reflect.visitor.ImportScannerImpl.isInCollisionWithLocalMethod(ImportScannerImpl.java:408)
	at spoon.reflect.visitor.ImportScannerImpl.addMethodImport(ImportScannerImpl.java:431)
	at spoon.reflect.visitor.ImportScannerImpl.visitCtExecutableReference(ImportScannerImpl.java:106)
	at spoon.support.reflect.reference.CtExecutableReferenceImpl.accept(CtExecutableReferenceImpl.java:84)
	at spoon.reflect.visitor.ImportScannerImpl.scan(ImportScannerImpl.java:135)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:157)
	at spoon.reflect.visitor.CtScanner.visitCtInvocation(CtScanner.java:495)
	at spoon.support.reflect.code.CtInvocationImpl.accept(CtInvocationImpl.java:56)
	at spoon.reflect.visitor.ImportScannerImpl.scan(ImportScannerImpl.java:135)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:157)
	at spoon.reflect.visitor.CtScanner.visitCtInvocation(CtScanner.java:494)
	at spoon.support.reflect.code.CtInvocationImpl.accept(CtInvocationImpl.java:56)
	at spoon.reflect.visitor.ImportScannerImpl.scan(ImportScannerImpl.java:135)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:157)
	at spoon.reflect.visitor.CtScanner.visitCtInvocation(CtScanner.java:494)
	at spoon.support.reflect.code.CtInvocationImpl.accept(CtInvocationImpl.java:56)
	at spoon.reflect.visitor.ImportScannerImpl.scan(ImportScannerImpl.java:135)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:157)
	at spoon.reflect.visitor.CtScanner.visitCtInvocation(CtScanner.java:494)
	at spoon.support.reflect.code.CtInvocationImpl.accept(CtInvocationImpl.java:56)
	at spoon.reflect.visitor.ImportScannerImpl.scan(ImportScannerImpl.java:135)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:157)
	at spoon.reflect.visitor.CtScanner.visitCtInvocation(CtScanner.java:494)
	at spoon.support.reflect.code.CtInvocationImpl.accept(CtInvocationImpl.java:56)
	at spoon.reflect.visitor.ImportScannerImpl.scan(ImportScannerImpl.java:135)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:157)
	at spoon.reflect.visitor.CtScanner.visitCtInvocation(CtScanner.java:494)
	at spoon.support.reflect.code.CtInvocationImpl.accept(CtInvocationImpl.java:56)
	at spoon.reflect.visitor.ImportScannerImpl.scan(ImportScannerImpl.java:135)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:157)
	at spoon.reflect.visitor.CtScanner.visitCtInvocation(CtScanner.java:494)
	at spoon.support.reflect.code.CtInvocationImpl.accept(CtInvocationImpl.java:56)
	at spoon.reflect.visitor.ImportScannerImpl.scan(ImportScannerImpl.java:135)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:157)
	at spoon.reflect.visitor.CtScanner.visitCtInvocation(CtScanner.java:494)
	at spoon.support.reflect.code.CtInvocationImpl.accept(CtInvocationImpl.java:56)
	at spoon.reflect.visitor.ImportScannerImpl.scan(ImportScannerImpl.java:135)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:157)
	at spoon.reflect.visitor.CtScanner.visitCtInvocation(CtScanner.java:494)
	at spoon.support.reflect.code.CtInvocationImpl.accept(CtInvocationImpl.java:56)
	at spoon.reflect.visitor.ImportScannerImpl.scan(ImportScannerImpl.java:135)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:157)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:141)
	at spoon.reflect.visitor.CtScanner.visitCtInvocation(CtScanner.java:496)
	at spoon.support.reflect.code.CtInvocationImpl.accept(CtInvocationImpl.java:56)
	at spoon.reflect.visitor.ImportScannerImpl.scan(ImportScannerImpl.java:135)
	at spoon.reflect.visitor.ImportScannerImpl.computeImports(ImportScannerImpl.java:204)
	at spoon.reflect.visitor.DefaultJavaPrettyPrinter.computeImports(DefaultJavaPrettyPrinter.java:293)
	at spoon.support.reflect.declaration.CtElementImpl.toString(CtElementImpl.java:252)
	at java.lang.String.valueOf(String.java:2994)
	at java.io.PrintStream.println(PrintStream.java:821)
	at fr.inria.spirals.npefix.transformer.processors.CheckNotNull.process(CheckNotNull.java:118)
	at fr.inria.spirals.npefix.transformer.processors.CheckNotNull.process(CheckNotNull.java:29)
	at spoon.support.visitor.ProcessingVisitor.scan(ProcessingVisitor.java:81)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:157)
	at spoon.reflect.visitor.CtScanner.visitCtConditional(CtScanner.java:345)
	at spoon.support.reflect.code.CtConditionalImpl.accept(CtConditionalImpl.java:43)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:165)
	at spoon.support.visitor.ProcessingVisitor.scan(ProcessingVisitor.java:77)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:157)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:141)
	at spoon.reflect.visitor.CtScanner.visitCtInvocation(CtScanner.java:496)
	at spoon.support.reflect.code.CtInvocationImpl.accept(CtInvocationImpl.java:56)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:165)
	at spoon.support.visitor.ProcessingVisitor.scan(ProcessingVisitor.java:77)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:157)
	at spoon.reflect.visitor.CtScanner.visitCtInvocation(CtScanner.java:494)
	at spoon.support.reflect.code.CtInvocationImpl.accept(CtInvocationImpl.java:56)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:165)
	at spoon.support.visitor.ProcessingVisitor.scan(ProcessingVisitor.java:77)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:157)
	at spoon.reflect.visitor.CtScanner.visitCtInvocation(CtScanner.java:494)
	at spoon.support.reflect.code.CtInvocationImpl.accept(CtInvocationImpl.java:56)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:165)
	at spoon.support.visitor.ProcessingVisitor.scan(ProcessingVisitor.java:77)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:157)
	at spoon.reflect.visitor.CtScanner.visitCtInvocation(CtScanner.java:494)
	at spoon.support.reflect.code.CtInvocationImpl.accept(CtInvocationImpl.java:56)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:165)
	at spoon.support.visitor.ProcessingVisitor.scan(ProcessingVisitor.java:77)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:157)
	at spoon.reflect.visitor.CtScanner.visitCtInvocation(CtScanner.java:494)
	at spoon.support.reflect.code.CtInvocationImpl.accept(CtInvocationImpl.java:56)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:165)
	at spoon.support.visitor.ProcessingVisitor.scan(ProcessingVisitor.java:77)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:157)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:141)
	at spoon.reflect.visitor.CtScanner.visitCtInvocation(CtScanner.java:496)
	at spoon.support.reflect.code.CtInvocationImpl.accept(CtInvocationImpl.java:56)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:165)
	at spoon.support.visitor.ProcessingVisitor.scan(ProcessingVisitor.java:77)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:157)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:141)
	at spoon.reflect.visitor.CtScanner.visitCtBlock(CtScanner.java:291)
	at spoon.support.reflect.code.CtBlockImpl.accept(CtBlockImpl.java:48)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:165)
	at spoon.support.visitor.ProcessingVisitor.scan(ProcessingVisitor.java:77)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:157)
	at spoon.reflect.visitor.CtScanner.visitCtMethod(CtScanner.java:549)
	at spoon.support.reflect.declaration.CtMethodImpl.accept(CtMethodImpl.java:70)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:165)
	at spoon.support.visitor.ProcessingVisitor.scan(ProcessingVisitor.java:77)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:157)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:141)
	at spoon.reflect.visitor.CtScanner.visitCtClass(CtScanner.java:327)
	at spoon.support.reflect.declaration.CtClassImpl.accept(CtClassImpl.java:68)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:165)
	at spoon.support.visitor.ProcessingVisitor.scan(ProcessingVisitor.java:77)
	at spoon.support.QueueProcessingManager.process(QueueProcessingManager.java:119)
	at fr.inria.spirals.npefix.main.all.Launcher.instrument(Launcher.java:105)
	at fr.inria.spirals.npefix.main.run.Main.run(Main.java:61)
	at fr.inria.spirals.npefix.main.run.Main.main(Main.java:48)
Command exited with non-zero status 1
56.44user 1.33system 0:19.09elapsed 302%CPU (0avgtext+0avgdata 1567064maxresident)k
33000inputs+136outputs (16major+418802minor)pagefaults 0swaps


Node: suno-15.sophia.grid5000.fr



Date: Sat May  4 20:50:41 EDT 2019

