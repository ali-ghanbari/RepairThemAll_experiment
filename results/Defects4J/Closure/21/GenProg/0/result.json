{
  "repair_end": "2018-12-02 14:11:29.508506", 
  "repair_begin": "2018-12-02 13:45:04.200826", 
  "patches": [
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_140/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:52:04.521456900 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_944/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:00:18.211472697 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -173,7 +165,6 @@\n     Node var = IR.var(name);\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n-    builder.recordNoAlias();\n     var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 176, 
          "faulty": "builder.recordNoAlias();", 
          "type": "Delete", 
          "seed": "break;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1625/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:07:06.457542405 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -157,7 +149,8 @@\n       addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n+        int start = 0;\n+\t\tname.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1625/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:07:06.457542405 -0500\n@@ -3121,22 +3121,23 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tint start = 0;\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 160, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1160/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:02:28.536037201 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1160/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:02:28.536037201 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1160/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:02:28.540037218 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1060/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:01:24.663762521 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,7 +155,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1060/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:01:24.667762537 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_504/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:55:57.590398086 -0500\n@@ -118,8 +118,8 @@\n         for (Node an : parent.getAncestors()) {\n           int ancestorType = an.getType();\n           if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n+          int start = 0;\n+\t\tint type = n.getType();\n         }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n@@ -163,7 +163,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_333/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:54:10.397964968 -0500\n@@ -114,13 +114,8 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+      StringBuilder builder = new StringBuilder();\n+\tif (n == parent.getLastChild()) {\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -156,7 +151,8 @@\n     if (!problemNodes.isEmpty()) {\n       addExtern();\n       for (Node n : problemNodes) {\n-        Node name = IR.name(PROTECTOR_FN).srcref(n);\n+        int type = n.getType();\n+\t\tNode name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "JSType type=n.getJSType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 159, 
          "faulty": "Node name=IR.name(PROTECTOR_FN).srcref(n);", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_60/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:51:10.121136649 -0500\n@@ -117,9 +117,9 @@\n       if (n == parent.getLastChild()) {\n         for (Node an : parent.getAncestors()) {\n           int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n+          int start = 0;\n+\t\tif (ancestorType == Token.COMMA) continue;\n+          final String PARAM_NAME = \"jscomp_throw_param\";\n         }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_2008/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:10:41.194835343 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -157,7 +151,8 @@\n       addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n+        int start = 0;\n+\t\tname.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n@@ -174,7 +169,6 @@\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_2008/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:10:41.198835365 -0500\n@@ -3121,22 +3121,23 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 177, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Delete", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 160, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Delete", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "int index=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_173/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:52:24.837538848 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1320/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:04:17.516499402 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1320/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:04:17.520499417 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1320/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:04:17.520499417 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1548/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:06:25.457255092 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1548/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:06:25.461255120 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1813/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:08:51.646212177 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1813/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:08:51.646212177 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"SUB\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"SUB\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Replace", 
          "seed": "return new DefaultCodingConvention();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_712/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:58:03.858908626 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1353/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:04:36.692580075 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -174,7 +166,6 @@\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1353/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:04:36.692580075 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 177, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1072/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:01:33.611801209 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -163,7 +157,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1072/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:01:33.611801209 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1072/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:01:33.615801226 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "case PARAM_LIST:"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1715/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:07:57.065875343 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -157,7 +149,8 @@\n       addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n+        int start = 0;\n+\t\tname.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1715/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:07:57.065875343 -0500\n@@ -3121,22 +3121,23 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tint start = 0;\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 160, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_2045/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:11:03.978958018 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_2045/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:11:03.982958038 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_2045/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:11:03.982958038 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"SUB\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"SUB\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "InsertBefore", 
          "seed": "JSType type=n.getJSType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1742/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:08:11.813968442 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -157,13 +149,11 @@\n       addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1742/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:08:11.817968468 -0500\n@@ -3121,22 +3121,23 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1742/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:08:11.817968468 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "case PARAM_LIST:"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "InsertBefore", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 160, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "Delete", 
          "seed": "traverseNodes(n);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_679/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:57:43.050824474 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_679/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:57:43.050824474 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1803/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:08:47.510187358 -0500\n@@ -115,12 +115,7 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+        int index = -1;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1803/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:08:47.514187383 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1522/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:06:11.265154190 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1522/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:06:11.269154217 -0500\n@@ -3135,8 +3135,11 @@\n           }\n         }\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Delete", 
          "seed": "int type=n.getType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1174/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:02:38.428079458 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1174/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:02:38.432079475 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1174/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:02:38.432079475 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1907/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:09:43.170512892 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1907/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:09:43.170512892 -0500\n@@ -3135,8 +3135,11 @@\n           }\n         }\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Delete", 
          "seed": "int type=n.getType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_965/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:00:28.619518408 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -163,7 +157,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_965/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:00:28.623518427 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_965/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:00:28.623518427 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "case PARAM_LIST:"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_596/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:56:53.174622793 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -163,7 +157,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1143/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:02:18.547994461 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -157,7 +149,6 @@\n       addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1143/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:02:18.551994480 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1143/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:02:18.551994480 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 160, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1212/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:03:04.788191741 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1587/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:06:46.993408156 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -163,7 +157,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n@@ -174,7 +167,6 @@\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1587/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:06:46.993408156 -0500\n@@ -3121,22 +3121,23 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1587/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:06:46.993408156 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 177, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "case PARAM_LIST:"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "InsertBefore", 
          "seed": "this.level=level;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1170/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:02:35.904068684 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,7 +155,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1170/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:02:35.908068701 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_740/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:58:20.022974001 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_740/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:58:20.022974001 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1647/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:07:20.217635137 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -163,7 +157,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1647/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:07:20.217635137 -0500\n@@ -3121,22 +3121,23 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1647/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:07:20.221635163 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return toString(true,true,true);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1837/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:09:06.162298443 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -174,7 +166,6 @@\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 177, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1241/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:03:25.920281437 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1241/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:03:25.920281437 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1241/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:03:25.924281454 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_589/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:56:48.354603304 -0500\n@@ -115,12 +115,7 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+        int start = 0;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -163,7 +158,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_572/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:56:37.886560982 -0500\n@@ -114,13 +114,8 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+      StringBuilder builder = new StringBuilder();\n+\tif (n == parent.getLastChild()) {\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -154,9 +149,9 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n       for (Node n : problemNodes) {\n-        Node name = IR.name(PROTECTOR_FN).srcref(n);\n+        int type = n.getType();\n+\t\tNode name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 159, 
          "faulty": "Node name=IR.name(PROTECTOR_FN).srcref(n);", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 157, 
          "faulty": "addExtern();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_2084/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:11:24.947069194 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_2084/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:11:24.947069194 -0500\n@@ -3135,8 +3135,11 @@\n           }\n         }\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_2084/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:11:24.947069194 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"SUB\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"SUB\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "formatPreamble();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_891/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:59:46.115330893 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -154,7 +146,6 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_891/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:59:46.115330893 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 157, 
          "faulty": "addExtern();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1498/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:05:59.137073013 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -157,7 +149,8 @@\n       addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n+        int start = 0;\n+\t\tname.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n@@ -174,7 +167,6 @@\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1498/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:05:59.141073041 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1498/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:05:59.141073041 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 177, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 160, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1995/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:10:34.746800249 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1995/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:10:34.750800271 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1995/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:10:34.750800271 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"SUB\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"SUB\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_85/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:51:27.121276266 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1976/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:10:23.622739296 -0500\n@@ -115,12 +115,7 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+        int index = -1;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -157,7 +152,8 @@\n       addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n+        int start = 0;\n+\t\tname.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1976/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:10:23.622739296 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 160, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1531/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:06:16.377189038 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,7 +155,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n@@ -174,7 +165,6 @@\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1531/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:06:16.381189068 -0500\n@@ -3121,22 +3121,23 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1531/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:06:16.381189068 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 177, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "case PARAM_LIST:"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1937/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:10:00.786612441 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1937/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:10:00.790612465 -0500\n@@ -3121,22 +3121,23 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_880/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:59:39.911303326 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -163,7 +157,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_880/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:59:39.915303344 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1695/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:07:45.785803003 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1695/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:07:45.785803003 -0500\n@@ -3121,22 +3121,23 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_44/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:50:58.921018122 -0500\n@@ -115,12 +115,7 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+        int start = 0;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -131,7 +126,6 @@\n         (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n-        msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n         msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n             \"' operator is not being used.\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 134, 
          "faulty": "msg=\"Is there a missing '+' on the previous line?\";", 
          "type": "Delete", 
          "seed": "int type=n.getType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_616/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:57:04.534668724 -0500\n@@ -118,8 +118,7 @@\n         for (Node an : parent.getAncestors()) {\n           int ancestorType = an.getType();\n           if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n+          final String PARAM_NAME = \"jscomp_throw_param\";\n         }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n@@ -154,9 +153,9 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n       for (Node n : problemNodes) {\n-        Node name = IR.name(PROTECTOR_FN).srcref(n);\n+        int type = n.getType();\n+\t\tNode name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 159, 
          "faulty": "Node name=IR.name(PROTECTOR_FN).srcref(n);", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 157, 
          "faulty": "addExtern();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_2072/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:11:18.091033016 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -174,7 +166,6 @@\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_2072/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:11:18.091033016 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 177, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "InsertBefore", 
          "seed": "JSType type=n.getJSType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1766/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:08:27.654066662 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,7 +155,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1766/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:08:27.654066662 -0500\n@@ -3135,8 +3135,11 @@\n           }\n         }\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1881/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:09:29.886436779 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,7 +155,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n@@ -174,7 +165,6 @@\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1881/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:09:29.890436803 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1881/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:09:29.890436803 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 177, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return toString(true,true,true);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_614/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:57:03.710665393 -0500\n@@ -114,13 +114,9 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+      StringBuilder builder = new StringBuilder();\n+\tif (n == parent.getLastChild()) {\n+        int start = 0;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -163,7 +159,8 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n+      int start = 0;\n+\tcompiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_614/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:57:03.710665393 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "Node paramList=paramList();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_2086/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:11:25.755073449 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -173,7 +165,6 @@\n     Node var = IR.var(name);\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n-    builder.recordNoAlias();\n     var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_2086/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:11:25.755073449 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 176, 
          "faulty": "builder.recordNoAlias();", 
          "type": "Delete", 
          "seed": "break;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1864/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:09:20.926384905 -0500\n@@ -112,15 +112,8 @@\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n     if (parent.getType() == Token.COMMA) {\n       if (isResultUsed) {\n-        return;\n-      }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+        int type = n.getType();\n+\t\treturn;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -157,8 +150,8 @@\n       addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n-        Node replacement = IR.call(name).srcref(n);\n+        int start = 0;\n+\t\tNode replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1864/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:09:20.930384929 -0500\n@@ -3121,22 +3121,23 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tint start = 0;\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1864/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:09:20.930384929 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"SUB\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"SUB\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 160, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 160, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "InsertBefore", 
          "seed": "break;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1112/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:01:58.715909376 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -163,7 +157,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1112/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:01:58.719909393 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1781/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:08:35.222112974 -0500\n@@ -112,15 +112,8 @@\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n     if (parent.getType() == Token.COMMA) {\n       if (isResultUsed) {\n-        return;\n-      }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+        int type = n.getType();\n+\t\treturn;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -157,8 +150,8 @@\n       addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n-        Node replacement = IR.call(name).srcref(n);\n+        int start = 0;\n+\t\tNode replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1781/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:08:35.226112998 -0500\n@@ -3121,22 +3121,23 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tint start = 0;\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 160, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 160, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "InsertBefore", 
          "seed": "break;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1554/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:06:28.029273636 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,7 +155,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1554/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:06:28.033273664 -0500\n@@ -3121,22 +3121,23 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1866/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:09:21.702389415 -0500\n@@ -115,12 +115,7 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+        StringBuilder builder = new StringBuilder();\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Replace", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_450/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:55:24.034262465 -0500\n@@ -115,11 +115,11 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n+        int start = 0;\n+\t\tfor (Node an : parent.getAncestors()) {\n           int ancestorType = an.getType();\n           if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n+          final String PARAM_NAME = \"jscomp_throw_param\";\n         }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n@@ -131,7 +131,6 @@\n         (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n-        msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n         msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n             \"' operator is not being used.\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 134, 
          "faulty": "msg=\"Is there a missing '+' on the previous line?\";", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1475/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:05:47.712995278 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -174,7 +166,6 @@\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 177, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_435/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:55:15.178226678 -0500\n@@ -114,13 +114,9 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+      StringBuilder builder = new StringBuilder();\n+\tif (n == parent.getLastChild()) {\n+        int start = 0;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_611/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:57:02.098658875 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1140/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:02:16.887987352 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_830/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:59:10.955180017 -0500\n@@ -115,12 +115,7 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+        int start = 0;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_830/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:59:10.955180017 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1312/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:04:12.412477900 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,7 +155,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n@@ -174,7 +165,6 @@\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1312/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:04:12.412477900 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1312/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:04:12.412477900 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 177, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_16/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:50:39.000722973 -0500\n@@ -118,8 +118,7 @@\n         for (Node an : parent.getAncestors()) {\n           int ancestorType = an.getType();\n           if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n+          final String PARAM_NAME = \"jscomp_throw_param\";\n         }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1265/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:03:40.920344949 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,7 +155,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1456/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:05:37.624925566 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1456/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:05:37.624925566 -0500\n@@ -3121,22 +3121,23 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1801/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:08:46.666182281 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,7 +155,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1801/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:08:46.666182281 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return toString(true,true,true);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1807/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:08:49.250197813 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1807/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:08:49.250197813 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return toString(true,true,true);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_893/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:59:46.903334390 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,7 +155,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_875/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:59:37.439292327 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,7 +155,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_929/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:00:09.231433155 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_929/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:00:09.235433171 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1490/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:05:55.201046372 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -163,7 +157,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n@@ -174,7 +167,6 @@\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 177, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1794/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:08:42.462156920 -0500\n@@ -115,12 +115,7 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+        int index = -1;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1794/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:08:42.466156944 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return toString(true,true,true);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_2053/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:11:08.066979817 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -174,7 +166,6 @@\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_2053/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:11:08.066979817 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_2053/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:11:08.070979839 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 177, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return new Node(Token.PARAM_LIST);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_2016/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:10:45.426858284 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_2016/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:10:45.426858284 -0500\n@@ -3135,8 +3135,11 @@\n           }\n         }\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "formatPreamble();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1047/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:01:16.719728110 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -163,7 +157,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1047/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:01:16.719728110 -0500\n@@ -3121,22 +3121,23 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_456/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:55:26.546272617 -0500\n@@ -118,8 +118,7 @@\n         for (Node an : parent.getAncestors()) {\n           int ancestorType = an.getType();\n           if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n+          int type = n.getType();\n         }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n@@ -133,8 +132,6 @@\n       if (n.isString()) {\n         msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n-        msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n-            \"' operator is not being used.\";\n       }\n \n       t.getCompiler().report(\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_456/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:55:26.546272617 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 136, 
          "faulty": "msg=\"The result of the '\" + Token.name(n.getType()).toLowerCase() + \"' operator is not being used.\";", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1438/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:05:28.404860936 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -174,7 +168,6 @@\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1438/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:05:28.404860936 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 177, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return toString(true,true,true);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1667/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:07:30.933706172 -0500\n@@ -115,12 +115,7 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+        int index = -1;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -170,7 +165,8 @@\n   private void addExtern() {\n     Node name = IR.name(PROTECTOR_FN);\n     name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n-    Node var = IR.var(name);\n+    int start = 0;\n+\tNode var = IR.var(name);\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1667/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:07:30.933706172 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 173, 
          "faulty": "Node var=IR.var(name);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1576/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:06:40.277360949 -0500\n@@ -115,12 +115,7 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+        int index = -1;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -163,7 +158,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1576/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:06:40.281360978 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1576/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:06:40.281360978 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return toString(true,true,true);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_2090/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:11:27.919084828 -0500\n@@ -112,15 +112,8 @@\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n     if (parent.getType() == Token.COMMA) {\n       if (isResultUsed) {\n-        return;\n-      }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+        int type = n.getType();\n+\t\treturn;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -157,8 +150,8 @@\n       addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n-        Node replacement = IR.call(name).srcref(n);\n+        int start = 0;\n+\t\tNode replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n@@ -174,7 +167,6 @@\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_2090/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:11:27.923084849 -0500\n@@ -3121,22 +3121,23 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tint start = 0;\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 177, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 160, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 160, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "InsertBefore", 
          "seed": "break;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1708/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:07:53.801854513 -0500\n@@ -115,12 +115,7 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+        int index = -1;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -170,7 +165,8 @@\n   private void addExtern() {\n     Node name = IR.name(PROTECTOR_FN);\n     name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n-    Node var = IR.var(name);\n+    int start = 0;\n+\tNode var = IR.var(name);\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 173, 
          "faulty": "Node var=IR.var(name);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_979/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:00:36.695553792 -0500\n@@ -117,9 +117,8 @@\n       if (n == parent.getLastChild()) {\n         for (Node an : parent.getAncestors()) {\n           int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n+          int start = 0;\n+\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n         }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n@@ -163,7 +162,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1032/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:01:08.455692251 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,7 +155,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1032/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:01:08.459692270 -0500\n@@ -3121,19 +3121,7 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        ;\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Replace", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1394/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:05:01.836685614 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,7 +155,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1394/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:05:01.840685632 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1394/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:05:01.840685632 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Replace", 
          "seed": "int keyParent=key(parent);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1750/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:08:18.742011621 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -157,7 +151,6 @@\n       addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1750/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:08:18.746011646 -0500\n@@ -3135,8 +3135,11 @@\n           }\n         }\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1750/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:08:18.746011646 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "case PARAM_LIST:"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "InsertBefore", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 160, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "Delete", 
          "seed": "traverseNodes(n);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1717/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:07:57.881880537 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,7 +155,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1717/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:07:57.881880537 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_2056/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:11:09.782988950 -0500\n@@ -115,12 +115,7 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+        int index = -1;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -174,7 +169,6 @@\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_2056/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:11:09.782988950 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 177, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1556/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:06:28.853279560 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1556/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:06:28.853279560 -0500\n@@ -3121,22 +3121,23 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1885/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:09:31.570446480 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,18 +155,18 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n   private void addExtern() {\n     Node name = IR.name(PROTECTOR_FN);\n-    name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n-    Node var = IR.var(name);\n+    int index = -1;\n+\tname.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n+    int start = 0;\n+\tNode var = IR.var(name);\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1885/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:09:31.570446480 -0500\n@@ -3121,22 +3121,23 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 173, 
          "faulty": "Node var=IR.var(name);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 177, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Delete", 
          "seed": "break;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 172, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "InsertBefore", 
          "seed": "int index=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1251/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:03:32.416308958 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,7 +155,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1138/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:02:16.087983925 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,7 +155,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1138/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:02:16.091983942 -0500\n@@ -3121,22 +3121,23 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1138/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:02:16.091983942 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1257/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:03:36.556326484 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1257/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:03:36.560326501 -0500\n@@ -3135,8 +3135,11 @@\n           }\n         }\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1327/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:04:20.712512858 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1327/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:04:20.716512875 -0500\n@@ -3135,8 +3135,11 @@\n           }\n         }\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_967/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:00:29.487522216 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -154,7 +148,6 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_967/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:00:29.491522232 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 157, 
          "faulty": "addExtern();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_832/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:59:11.743183203 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -156,14 +148,14 @@\n     if (!problemNodes.isEmpty()) {\n       addExtern();\n       for (Node n : problemNodes) {\n-        Node name = IR.name(PROTECTOR_FN).srcref(n);\n+        int type = n.getType();\n+\t\tNode name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_832/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:59:11.747183221 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 159, 
          "faulty": "Node name=IR.name(PROTECTOR_FN).srcref(n);", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1897/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:09:37.426480095 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -157,8 +149,8 @@\n       addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n-        Node replacement = IR.call(name).srcref(n);\n+        int start = 0;\n+\t\tNode replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n@@ -174,7 +166,6 @@\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1897/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:09:37.426480095 -0500\n@@ -3121,22 +3121,23 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tint start = 0;\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 177, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 160, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 160, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "InsertBefore", 
          "seed": "break;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1276/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:03:47.172371384 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -131,7 +123,6 @@\n         (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n-        msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n         msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n             \"' operator is not being used.\";\n@@ -163,7 +154,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1276/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:03:47.172371384 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1276/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:03:47.176371401 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 134, 
          "faulty": "msg=\"Is there a missing '+' on the previous line?\";", 
          "type": "Delete", 
          "seed": "JSType type=n.getJSType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1895/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:09:36.606475399 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -157,13 +149,12 @@\n       addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n-        Node replacement = IR.call(name).srcref(n);\n+        int start = 0;\n+\t\tNode replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n@@ -174,7 +165,6 @@\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1895/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:09:36.606475399 -0500\n@@ -3121,22 +3121,13 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        ;\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1895/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:09:36.606475399 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return toString(true,true,true);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 177, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 160, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 160, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "InsertBefore", 
          "seed": "break;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_755/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:58:29.347011713 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "InsertBefore", 
          "seed": "JSType type=n.getJSType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1595/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:06:51.597440250 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_349/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:54:20.794006959 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -156,7 +150,8 @@\n     if (!problemNodes.isEmpty()) {\n       addExtern();\n       for (Node n : problemNodes) {\n-        Node name = IR.name(PROTECTOR_FN).srcref(n);\n+        int type = n.getType();\n+\t\tNode name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 159, 
          "faulty": "Node name=IR.name(PROTECTOR_FN).srcref(n);", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_2006/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:10:40.382830933 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_2006/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:10:40.386830955 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"SUB\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"SUB\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "InsertBefore", 
          "seed": "JSType type=n.getJSType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_365/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:54:32.018052298 -0500\n@@ -114,13 +114,8 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+      StringBuilder builder = new StringBuilder();\n+\tif (n == parent.getLastChild()) {\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -156,7 +151,8 @@\n     if (!problemNodes.isEmpty()) {\n       addExtern();\n       for (Node n : problemNodes) {\n-        Node name = IR.name(PROTECTOR_FN).srcref(n);\n+        int type = n.getType();\n+\t\tNode name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 159, 
          "faulty": "Node name=IR.name(PROTECTOR_FN).srcref(n);", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1929/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:09:56.422587923 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -157,7 +149,8 @@\n       addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n+        int start = 0;\n+\t\tname.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1929/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:09:56.422587923 -0500\n@@ -3135,8 +3135,11 @@\n           }\n         }\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1929/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:09:56.426587944 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"SUB\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"SUB\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 160, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Delete", 
          "seed": "int type=n.getType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1732/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:08:05.861931066 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -157,8 +149,8 @@\n       addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n-        Node replacement = IR.call(name).srcref(n);\n+        int start = 0;\n+\t\tNode replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1732/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:08:05.861931066 -0500\n@@ -3121,22 +3121,23 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tint start = 0;\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 160, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 160, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_673/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:57:39.798811323 -0500\n@@ -118,8 +118,7 @@\n         for (Node an : parent.getAncestors()) {\n           int ancestorType = an.getType();\n           if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n+          final String PARAM_NAME = \"jscomp_throw_param\";\n         }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n@@ -154,7 +153,6 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 157, 
          "faulty": "addExtern();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_243/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:53:11.789728321 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -131,7 +125,7 @@\n         (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n-        msg = \"Is there a missing '+' on the previous line?\";\n+        StringBuilder builder = new StringBuilder();\n       } else if (isSimpleOp) {\n         msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n             \"' operator is not being used.\";\n@@ -156,7 +150,8 @@\n     if (!problemNodes.isEmpty()) {\n       addExtern();\n       for (Node n : problemNodes) {\n-        Node name = IR.name(PROTECTOR_FN).srcref(n);\n+        int type = n.getType();\n+\t\tNode name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 134, 
          "faulty": "msg=\"Is there a missing '+' on the previous line?\";", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 134, 
          "faulty": "msg=\"Is there a missing '+' on the previous line?\";", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 159, 
          "faulty": "Node name=IR.name(PROTECTOR_FN).srcref(n);", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1629/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:07:08.937559249 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,7 +155,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1629/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:07:08.937559249 -0500\n@@ -3121,22 +3121,23 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_2047/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:11:04.794962373 -0500\n@@ -115,12 +115,7 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+        int index = -1;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -173,7 +168,6 @@\n     Node var = IR.var(name);\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n-    builder.recordNoAlias();\n     var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_2047/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:11:04.798962395 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_2047/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:11:04.798962395 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"SUB\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"SUB\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 176, 
          "faulty": "builder.recordNoAlias();", 
          "type": "Delete", 
          "seed": "break;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_64/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:51:12.517158333 -0500\n@@ -115,12 +115,7 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+        int start = 0;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Delete", 
          "seed": "break;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1077/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:01:36.775814871 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1077/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:01:36.775814871 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Replace", 
          "seed": "traverseNodes(n);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1605/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:06:56.565474642 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -168,7 +160,8 @@\n   }\n \n   private void addExtern() {\n-    Node name = IR.name(PROTECTOR_FN);\n+    final String PARAM_NAME = \"jscomp_throw_param\";\n+\tNode name = IR.name(PROTECTOR_FN);\n     name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n     Node var = IR.var(name);\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1605/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:06:56.569474670 -0500\n@@ -3135,8 +3135,11 @@\n           }\n         }\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Delete", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 171, 
          "faulty": "Node name=IR.name(PROTECTOR_FN);", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_716/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:58:05.534915405 -0500\n@@ -117,9 +117,10 @@\n       if (n == parent.getLastChild()) {\n         for (Node an : parent.getAncestors()) {\n           int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n+          int start = 0;\n+\t\tif (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n+\t\t\t;\n+\t\telse break;\n         }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n@@ -156,14 +157,14 @@\n     if (!problemNodes.isEmpty()) {\n       addExtern();\n       for (Node n : problemNodes) {\n-        Node name = IR.name(PROTECTOR_FN).srcref(n);\n+        int type = n.getType();\n+\t\tNode name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_716/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:58:05.538915421 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 159, 
          "faulty": "Node name=IR.name(PROTECTOR_FN).srcref(n);", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_145/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:52:07.129467419 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -131,7 +125,7 @@\n         (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n-        msg = \"Is there a missing '+' on the previous line?\";\n+        StringBuilder builder = new StringBuilder();\n       } else if (isSimpleOp) {\n         msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n             \"' operator is not being used.\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 134, 
          "faulty": "msg=\"Is there a missing '+' on the previous line?\";", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_577/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:56:40.394571122 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_792/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:58:51.195100085 -0500\n@@ -114,13 +114,9 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+      StringBuilder builder = new StringBuilder();\n+\tif (n == parent.getLastChild()) {\n+        int start = 0;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -154,7 +150,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      StringBuilder builder = new StringBuilder();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_792/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:58:51.199100101 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 157, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_361/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:54:29.478042037 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_361/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:54:29.478042037 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1286/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:03:54.540402511 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_387/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:54:44.486102666 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int keyParent=key(parent);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1379/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:04:52.144644965 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,7 +155,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1379/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:04:52.144644965 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_645/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:57:22.006739374 -0500\n@@ -114,13 +114,9 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+      StringBuilder builder = new StringBuilder();\n+\tif (n == parent.getLastChild()) {\n+        int start = 0;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -156,14 +152,16 @@\n     if (!problemNodes.isEmpty()) {\n       addExtern();\n       for (Node n : problemNodes) {\n-        Node name = IR.name(PROTECTOR_FN).srcref(n);\n+        int start = 0;\n+\t\tNode name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n+      int start = 0;\n+\tcompiler.reportCodeChange();\n     }\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 159, 
          "faulty": "Node name=IR.name(PROTECTOR_FN).srcref(n);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_439/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:55:17.562236312 -0500\n@@ -114,13 +114,8 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+      StringBuilder builder = new StringBuilder();\n+\tif (n == parent.getLastChild()) {\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -133,8 +128,6 @@\n       if (n.isString()) {\n         msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n-        msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n-            \"' operator is not being used.\";\n       }\n \n       t.getCompiler().report(\n@@ -163,7 +156,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 136, 
          "faulty": "msg=\"The result of the '\" + Token.name(n.getType()).toLowerCase() + \"' operator is not being used.\";", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1845/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:09:10.266322604 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -131,7 +123,8 @@\n         (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n-        msg = \"Is there a missing '+' on the previous line?\";\n+        int type = n.getType();\n+\t\tmsg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n         msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n             \"' operator is not being used.\";\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1845/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:09:10.266322604 -0500\n@@ -3135,8 +3135,11 @@\n           }\n         }\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 134, 
          "faulty": "msg=\"Is there a missing '+' on the previous line?\";", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_21/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:50:42.352783133 -0500\n@@ -115,12 +115,7 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+        int start = 0;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_764/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:58:34.823033862 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -154,7 +148,6 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_764/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:58:34.823033862 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 157, 
          "faulty": "addExtern();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_264/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:53:25.577783981 -0500\n@@ -114,13 +114,8 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+      StringBuilder builder = new StringBuilder();\n+\tif (n == parent.getLastChild()) {\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -157,7 +152,6 @@\n       addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 160, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 160, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "JSType type=n.getJSType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_682/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:57:44.658830977 -0500\n@@ -114,13 +114,9 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+      StringBuilder builder = new StringBuilder();\n+\tif (n == parent.getLastChild()) {\n+        int start = 0;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -133,8 +129,6 @@\n       if (n.isString()) {\n         msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n-        msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n-            \"' operator is not being used.\";\n       }\n \n       t.getCompiler().report(\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_682/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:57:44.658830977 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 136, 
          "faulty": "msg=\"The result of the '\" + Token.name(n.getType()).toLowerCase() + \"' operator is not being used.\";", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1348/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:04:34.224569700 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,7 +155,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n@@ -174,7 +165,6 @@\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1348/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:04:34.224569700 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1348/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:04:34.228569718 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 177, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "int keyParent=key(parent);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1817/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:08:54.050226553 -0500\n@@ -115,12 +115,7 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+        int index = -1;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_200/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:52:43.393613718 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_200/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:52:43.397613734 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1672/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:07:33.425722548 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1672/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:07:33.425722548 -0500\n@@ -3135,8 +3135,11 @@\n           }\n         }\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Delete", 
          "seed": "int type=n.getType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_2000/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:10:37.202813637 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -163,7 +157,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n@@ -174,7 +167,6 @@\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_2000/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:10:37.202813637 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_2000/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:10:37.206813658 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 177, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 177, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return toString(true,true,true);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1740/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:08:10.989963285 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1740/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:08:10.989963285 -0500\n@@ -3135,8 +3135,11 @@\n           }\n         }\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Delete", 
          "seed": "int type=n.getType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_551/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:56:26.630515476 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -133,8 +127,6 @@\n       if (n.isString()) {\n         msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n-        msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n-            \"' operator is not being used.\";\n       }\n \n       t.getCompiler().report(\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_551/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:56:26.646515542 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 136, 
          "faulty": "msg=\"The result of the '\" + Token.name(n.getType()).toLowerCase() + \"' operator is not being used.\";", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Replace", 
          "seed": "return new DotFormatter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1461/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:05:40.164943216 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -174,7 +166,6 @@\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 177, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1854/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:09:15.470353099 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,7 +155,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1854/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:09:15.474353122 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1854/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:09:15.474353122 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return toString(true,true,true);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_777/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:58:42.347064296 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -154,7 +148,6 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_777/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:58:42.351064312 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 157, 
          "faulty": "addExtern();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1082/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:01:40.015828853 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,7 +155,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1082/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:01:40.019828871 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1082/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:01:40.019828871 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_703/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:57:58.222885832 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_703/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:57:58.226885848 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_730/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:58:14.234950591 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -154,9 +148,9 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n       for (Node n : problemNodes) {\n-        Node name = IR.name(PROTECTOR_FN).srcref(n);\n+        int type = n.getType();\n+\t\tNode name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_730/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:58:14.238950607 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 159, 
          "faulty": "Node name=IR.name(PROTECTOR_FN).srcref(n);", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 157, 
          "faulty": "addExtern();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1511/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:06:05.181113639 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -174,7 +166,6 @@\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1511/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:06:05.185113665 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1511/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:06:05.185113665 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 177, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return toString(true,true,true);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_981/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:00:37.515557379 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,7 +155,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_981/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:00:37.519557398 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_2026/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:10:51.178889350 -0500\n@@ -112,15 +112,8 @@\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n     if (parent.getType() == Token.COMMA) {\n       if (isResultUsed) {\n-        return;\n-      }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+        int type = n.getType();\n+\t\treturn;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -157,8 +150,8 @@\n       addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n-        Node replacement = IR.call(name).srcref(n);\n+        int start = 0;\n+\t\tNode replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_2026/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:10:51.178889350 -0500\n@@ -3121,22 +3121,23 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tint start = 0;\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_2026/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:10:51.182889370 -0500\n@@ -184,7 +184,207 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              {\n+\t\t\t\tswitch (token) {\n+\t\t\t\tcase ERROR:\n+\t\t\t\t\treturn \"ERROR\";\n+\t\t\t\tcase RETURN:\n+\t\t\t\t\treturn \"RETURN\";\n+\t\t\t\tcase BITOR:\n+\t\t\t\t\treturn \"BITOR\";\n+\t\t\t\tcase BITXOR:\n+\t\t\t\t\treturn \"BITXOR\";\n+\t\t\t\tcase BITAND:\n+\t\t\t\t\treturn \"BITAND\";\n+\t\t\t\tcase EQ:\n+\t\t\t\t\treturn \"EQ\";\n+\t\t\t\tcase NE:\n+\t\t\t\t\treturn \"NE\";\n+\t\t\t\tcase LT:\n+\t\t\t\t\treturn \"LT\";\n+\t\t\t\tcase LE:\n+\t\t\t\t\treturn \"LE\";\n+\t\t\t\tcase GT:\n+\t\t\t\t\treturn \"GT\";\n+\t\t\t\tcase GE:\n+\t\t\t\t\treturn \"GE\";\n+\t\t\t\tcase LSH:\n+\t\t\t\t\treturn \"LSH\";\n+\t\t\t\tcase RSH:\n+\t\t\t\t\treturn \"RSH\";\n+\t\t\t\tcase URSH:\n+\t\t\t\t\treturn \"URSH\";\n+\t\t\t\tcase ADD:\n+\t\t\t\t\treturn \"ADD\";\n+\t\t\t\tcase SUB:\n+\t\t\t\t\treturn \"SUB\";\n+\t\t\t\tcase MUL:\n+\t\t\t\t\treturn \"MUL\";\n+\t\t\t\tcase DIV:\n+\t\t\t\t\treturn \"DIV\";\n+\t\t\t\tcase MOD:\n+\t\t\t\t\treturn \"MOD\";\n+\t\t\t\tcase NOT:\n+\t\t\t\t\treturn \"NOT\";\n+\t\t\t\tcase BITNOT:\n+\t\t\t\t\treturn \"BITNOT\";\n+\t\t\t\tcase POS:\n+\t\t\t\t\treturn \"POS\";\n+\t\t\t\tcase NEG:\n+\t\t\t\t\treturn \"NEG\";\n+\t\t\t\tcase NEW:\n+\t\t\t\t\treturn \"NEW\";\n+\t\t\t\tcase DELPROP:\n+\t\t\t\t\treturn \"DELPROP\";\n+\t\t\t\tcase TYPEOF:\n+\t\t\t\t\treturn \"TYPEOF\";\n+\t\t\t\tcase GETPROP:\n+\t\t\t\t\treturn \"GETPROP\";\n+\t\t\t\tcase GETELEM:\n+\t\t\t\t\treturn \"GETELEM\";\n+\t\t\t\tcase CALL:\n+\t\t\t\t\treturn \"CALL\";\n+\t\t\t\tcase NAME:\n+\t\t\t\t\treturn \"NAME\";\n+\t\t\t\tcase LABEL_NAME:\n+\t\t\t\t\treturn \"LABEL_NAME\";\n+\t\t\t\tcase NUMBER:\n+\t\t\t\t\treturn \"NUMBER\";\n+\t\t\t\tcase STRING:\n+\t\t\t\t\treturn \"STRING\";\n+\t\t\t\tcase STRING_KEY:\n+\t\t\t\t\treturn \"STRING_KEY\";\n+\t\t\t\tcase NULL:\n+\t\t\t\t\treturn \"NULL\";\n+\t\t\t\tcase THIS:\n+\t\t\t\t\treturn \"THIS\";\n+\t\t\t\tcase FALSE:\n+\t\t\t\t\treturn \"FALSE\";\n+\t\t\t\tcase TRUE:\n+\t\t\t\t\treturn \"TRUE\";\n+\t\t\t\tcase SHEQ:\n+\t\t\t\t\treturn \"SHEQ\";\n+\t\t\t\tcase SHNE:\n+\t\t\t\t\treturn \"SHNE\";\n+\t\t\t\tcase REGEXP:\n+\t\t\t\t\treturn \"REGEXP\";\n+\t\t\t\tcase THROW:\n+\t\t\t\t\treturn \"THROW\";\n+\t\t\t\tcase IN:\n+\t\t\t\t\treturn \"IN\";\n+\t\t\t\tcase INSTANCEOF:\n+\t\t\t\t\treturn \"INSTANCEOF\";\n+\t\t\t\tcase ARRAYLIT:\n+\t\t\t\t\treturn \"ARRAYLIT\";\n+\t\t\t\tcase OBJECTLIT:\n+\t\t\t\t\treturn \"OBJECTLIT\";\n+\t\t\t\tcase TRY:\n+\t\t\t\t\treturn \"TRY\";\n+\t\t\t\tcase PARAM_LIST:\n+\t\t\t\t\treturn \"PARAM_LIST\";\n+\t\t\t\tcase COMMA:\n+\t\t\t\t\treturn \"COMMA\";\n+\t\t\t\tcase ASSIGN:\n+\t\t\t\t\treturn \"ASSIGN\";\n+\t\t\t\tcase ASSIGN_BITOR:\n+\t\t\t\t\treturn \"ASSIGN_BITOR\";\n+\t\t\t\tcase ASSIGN_BITXOR:\n+\t\t\t\t\treturn \"ASSIGN_BITXOR\";\n+\t\t\t\tcase ASSIGN_BITAND:\n+\t\t\t\t\treturn \"ASSIGN_BITAND\";\n+\t\t\t\tcase ASSIGN_LSH:\n+\t\t\t\t\treturn \"ASSIGN_LSH\";\n+\t\t\t\tcase ASSIGN_RSH:\n+\t\t\t\t\treturn \"ASSIGN_RSH\";\n+\t\t\t\tcase ASSIGN_URSH:\n+\t\t\t\t\treturn \"ASSIGN_URSH\";\n+\t\t\t\tcase ASSIGN_ADD:\n+\t\t\t\t\treturn \"ASSIGN_ADD\";\n+\t\t\t\tcase ASSIGN_SUB:\n+\t\t\t\t\treturn \"ASSIGN_SUB\";\n+\t\t\t\tcase ASSIGN_MUL:\n+\t\t\t\t\treturn \"ASSIGN_MUL\";\n+\t\t\t\tcase ASSIGN_DIV:\n+\t\t\t\t\treturn \"ASSIGN_DIV\";\n+\t\t\t\tcase ASSIGN_MOD:\n+\t\t\t\t\treturn \"ASSIGN_MOD\";\n+\t\t\t\tcase HOOK:\n+\t\t\t\t\treturn \"HOOK\";\n+\t\t\t\tcase COLON:\n+\t\t\t\t\treturn \"COLON\";\n+\t\t\t\tcase OR:\n+\t\t\t\t\treturn \"OR\";\n+\t\t\t\tcase AND:\n+\t\t\t\t\treturn \"AND\";\n+\t\t\t\tcase INC:\n+\t\t\t\t\treturn \"INC\";\n+\t\t\t\tcase DEC:\n+\t\t\t\t\treturn \"DEC\";\n+\t\t\t\tcase FUNCTION:\n+\t\t\t\t\treturn \"FUNCTION\";\n+\t\t\t\tcase IF:\n+\t\t\t\t\treturn \"IF\";\n+\t\t\t\tcase SWITCH:\n+\t\t\t\t\treturn \"SWITCH\";\n+\t\t\t\tcase CASE:\n+\t\t\t\t\treturn \"CASE\";\n+\t\t\t\tcase DEFAULT_CASE:\n+\t\t\t\t\treturn \"DEFAULT_CASE\";\n+\t\t\t\tcase WHILE:\n+\t\t\t\t\treturn \"WHILE\";\n+\t\t\t\tcase DO:\n+\t\t\t\t\treturn \"DO\";\n+\t\t\t\tcase FOR:\n+\t\t\t\t\treturn \"FOR\";\n+\t\t\t\tcase BREAK:\n+\t\t\t\t\treturn \"BREAK\";\n+\t\t\t\tcase CONTINUE:\n+\t\t\t\t\treturn \"CONTINUE\";\n+\t\t\t\tcase VAR:\n+\t\t\t\t\treturn \"VAR\";\n+\t\t\t\tcase WITH:\n+\t\t\t\t\treturn \"WITH\";\n+\t\t\t\tcase CATCH:\n+\t\t\t\t\treturn \"CATCH\";\n+\t\t\t\tcase EMPTY:\n+\t\t\t\t\treturn \"EMPTY\";\n+\t\t\t\tcase BLOCK:\n+\t\t\t\t\treturn \"BLOCK\";\n+\t\t\t\tcase LABEL:\n+\t\t\t\t\treturn \"LABEL\";\n+\t\t\t\tcase EXPR_RESULT:\n+\t\t\t\t\treturn \"EXPR_RESULT\";\n+\t\t\t\tcase SCRIPT:\n+\t\t\t\t\treturn \"SCRIPT\";\n+\t\t\t\tcase GETTER_DEF:\n+\t\t\t\t\treturn \"GETTER_DEF\";\n+\t\t\t\tcase SETTER_DEF:\n+\t\t\t\t\treturn \"SETTER_DEF\";\n+\t\t\t\tcase CONST:\n+\t\t\t\t\treturn \"CONST\";\n+\t\t\t\tcase DEBUGGER:\n+\t\t\t\t\treturn \"DEBUGGER\";\n+\t\t\t\tcase ANNOTATION:\n+\t\t\t\t\treturn \"ANNOTATION\";\n+\t\t\t\tcase PIPE:\n+\t\t\t\t\treturn \"PIPE\";\n+\t\t\t\tcase STAR:\n+\t\t\t\t\treturn \"STAR\";\n+\t\t\t\tcase EOC:\n+\t\t\t\t\treturn \"EOC\";\n+\t\t\t\tcase QMARK:\n+\t\t\t\t\treturn \"QMARK\";\n+\t\t\t\tcase ELLIPSIS:\n+\t\t\t\t\treturn \"ELLIPSIS\";\n+\t\t\t\tcase BANG:\n+\t\t\t\t\treturn \"BANG\";\n+\t\t\t\tcase VOID:\n+\t\t\t\t\treturn \"VOID\";\n+\t\t\t\tcase EQUALS:\n+\t\t\t\t\treturn \"EQUALS\";\n+\t\t\t\t}\n+\t\t\t\treturn \"EQ\";\n+\t\t\t}\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 160, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 160, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "InsertBefore", 
          "seed": "break;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "InsertBefore", 
          "seed": "switch (token) {\ncase ERROR:\n  return \"ERROR\";\ncase RETURN:\nreturn \"RETURN\";\ncase BITOR:\nreturn \"BITOR\";\ncase BITXOR:\nreturn \"BITXOR\";\ncase BITAND:\nreturn \"BITAND\";\ncase EQ:\nreturn \"EQ\";\ncase NE:\nreturn \"NE\";\ncase LT:\nreturn \"LT\";\ncase LE:\nreturn \"LE\";\ncase GT:\nreturn \"GT\";\ncase GE:\nreturn \"GE\";\ncase LSH:\nreturn \"LSH\";\ncase RSH:\nreturn \"RSH\";\ncase URSH:\nreturn \"URSH\";\ncase ADD:\nreturn \"ADD\";\ncase SUB:\nreturn \"SUB\";\ncase MUL:\nreturn \"MUL\";\ncase DIV:\nreturn \"DIV\";\ncase MOD:\nreturn \"MOD\";\ncase NOT:\nreturn \"NOT\";\ncase BITNOT:\nreturn \"BITNOT\";\ncase POS:\nreturn \"POS\";\ncase NEG:\nreturn \"NEG\";\ncase NEW:\nreturn \"NEW\";\ncase DELPROP:\nreturn \"DELPROP\";\ncase TYPEOF:\nreturn \"TYPEOF\";\ncase GETPROP:\nreturn \"GETPROP\";\ncase GETELEM:\nreturn \"GETELEM\";\ncase CALL:\nreturn \"CALL\";\ncase NAME:\nreturn \"NAME\";\ncase LABEL_NAME:\nreturn \"LABEL_NAME\";\ncase NUMBER:\nreturn \"NUMBER\";\ncase STRING:\nreturn \"STRING\";\ncase STRING_KEY:\nreturn \"STRING_KEY\";\ncase NULL:\nreturn \"NULL\";\ncase THIS:\nreturn \"THIS\";\ncase FALSE:\nreturn \"FALSE\";\ncase TRUE:\nreturn \"TRUE\";\ncase SHEQ:\nreturn \"SHEQ\";\ncase SHNE:\nreturn \"SHNE\";\ncase REGEXP:\nreturn \"REGEXP\";\ncase THROW:\nreturn \"THROW\";\ncase IN:\nreturn \"IN\";\ncase INSTANCEOF:\nreturn \"INSTANCEOF\";\ncase ARRAYLIT:\nreturn \"ARRAYLIT\";\ncase OBJECTLIT:\nreturn \"OBJECTLIT\";\ncase TRY:\nreturn \"TRY\";\ncase PARAM_LIST:\nreturn \"PARAM_LIST\";\ncase COMMA:\nreturn \"COMMA\";\ncase ASSIGN:\nreturn \"ASSIGN\";\ncase ASSIGN_BITOR:\nreturn \"ASSIGN_BITOR\";\ncase ASSIGN_BITXOR:\nreturn \"ASSIGN_BITXOR\";\ncase ASSIGN_BITAND:\nreturn \"ASSIGN_BITAND\";\ncase ASSIGN_LSH:\nreturn \"ASSIGN_LSH\";\ncase ASSIGN_RSH:\nreturn \"ASSIGN_RSH\";\ncase ASSIGN_URSH:\nreturn \"ASSIGN_URSH\";\ncase ASSIGN_ADD:\nreturn \"ASSIGN_ADD\";\ncase ASSIGN_SUB:\nreturn \"ASSIGN_SUB\";\ncase ASSIGN_MUL:\nreturn \"ASSIGN_MUL\";\ncase ASSIGN_DIV:\nreturn \"ASSIGN_DIV\";\ncase ASSIGN_MOD:\nreturn \"ASSIGN_MOD\";\ncase HOOK:\nreturn \"HOOK\";\ncase COLON:\nreturn \"COLON\";\ncase OR:\nreturn \"OR\";\ncase AND:\nreturn \"AND\";\ncase INC:\nreturn \"INC\";\ncase DEC:\nreturn \"DEC\";\ncase FUNCTION:\nreturn \"FUNCTION\";\ncase IF:\nreturn \"IF\";\ncase SWITCH:\nreturn \"SWITCH\";\ncase CASE:\nreturn \"CASE\";\ncase DEFAULT_CASE:\nreturn \"DEFAULT_CASE\";\ncase WHILE:\nreturn \"WHILE\";\ncase DO:\nreturn \"DO\";\ncase FOR:\nreturn \"FOR\";\ncase BREAK:\nreturn \"BREAK\";\ncase CONTINUE:\nreturn \"CONTINUE\";\ncase VAR:\nreturn \"VAR\";\ncase WITH:\nreturn \"WITH\";\ncase CATCH:\nreturn \"CATCH\";\ncase EMPTY:\nreturn \"EMPTY\";\ncase BLOCK:\nreturn \"BLOCK\";\ncase LABEL:\nreturn \"LABEL\";\ncase EXPR_RESULT:\nreturn \"EXPR_RESULT\";\ncase SCRIPT:\nreturn \"SCRIPT\";\ncase GETTER_DEF:\nreturn \"GETTER_DEF\";\ncase SETTER_DEF:\nreturn \"SETTER_DEF\";\ncase CONST:\nreturn \"CONST\";\ncase DEBUGGER:\nreturn \"DEBUGGER\";\ncase ANNOTATION:\nreturn \"ANNOTATION\";\ncase PIPE:\nreturn \"PIPE\";\ncase STAR:\nreturn \"STAR\";\ncase EOC:\nreturn \"EOC\";\ncase QMARK:\nreturn \"QMARK\";\ncase ELLIPSIS:\nreturn \"ELLIPSIS\";\ncase BANG:\nreturn \"BANG\";\ncase VOID:\nreturn \"VOID\";\ncase EQUALS:\nreturn \"EQUALS\";\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_618/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:57:05.462672477 -0500\n@@ -115,12 +115,7 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+        int start = 0;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1997/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:10:35.566804722 -0500\n@@ -115,12 +115,7 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+        int index = -1;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -174,7 +169,6 @@\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1997/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:10:35.566804722 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1997/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:10:35.566804722 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 177, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return new Node(Token.PARAM_LIST);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_823/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:59:07.671166732 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,7 +155,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_823/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:59:07.671166732 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_46/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:50:59.709027533 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_2077/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:11:20.635046459 -0500\n@@ -115,12 +115,7 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+        int index = -1;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_2077/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:11:20.635046459 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_985/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:00:39.255564991 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,7 +155,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_985/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:00:39.259565010 -0500\n@@ -3135,8 +3135,11 @@\n           }\n         }\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_575/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:56:39.622568001 -0500\n@@ -114,13 +114,9 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+      StringBuilder builder = new StringBuilder();\n+\tif (n == parent.getLastChild()) {\n+        int start = 0;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -131,7 +127,6 @@\n         (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n-        msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n         msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n             \"' operator is not being used.\";\n@@ -156,7 +151,8 @@\n     if (!problemNodes.isEmpty()) {\n       addExtern();\n       for (Node n : problemNodes) {\n-        Node name = IR.name(PROTECTOR_FN).srcref(n);\n+        int type = n.getType();\n+\t\tNode name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 159, 
          "faulty": "Node name=IR.name(PROTECTOR_FN).srcref(n);", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 134, 
          "faulty": "msg=\"Is there a missing '+' on the previous line?\";", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1685/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:07:40.825770869 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -163,7 +157,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Delete", 
          "seed": "int type=n.getType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1611/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:06:59.037491665 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -157,7 +149,8 @@\n       addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n+        int start = 0;\n+\t\tname.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1611/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:06:59.037491665 -0500\n@@ -3121,22 +3121,23 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tint start = 0;\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 160, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_237/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:53:07.577711319 -0500\n@@ -118,8 +118,7 @@\n         for (Node an : parent.getAncestors()) {\n           int ancestorType = an.getType();\n           if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n+          final String PARAM_NAME = \"jscomp_throw_param\";\n         }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n@@ -131,7 +130,6 @@\n         (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n-        msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n         msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n             \"' operator is not being used.\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 134, 
          "faulty": "msg=\"Is there a missing '+' on the previous line?\";", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1872/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:09:24.954408280 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -131,7 +123,8 @@\n         (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n-        msg = \"Is there a missing '+' on the previous line?\";\n+        int type = n.getType();\n+\t\tmsg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n         msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n             \"' operator is not being used.\";\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1872/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:09:24.958408304 -0500\n@@ -3135,8 +3135,11 @@\n           }\n         }\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 134, 
          "faulty": "msg=\"Is there a missing '+' on the previous line?\";", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1005/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:00:50.579614451 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -163,7 +157,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_790/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:58:50.363096720 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_790/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:58:50.367096736 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_677/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:57:42.258821271 -0500\n@@ -118,8 +118,10 @@\n         for (Node an : parent.getAncestors()) {\n           int ancestorType = an.getType();\n           if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n+          int start = 0;\n+\t\tif (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n+\t\t\t;\n+\t\telse break;\n         }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n@@ -156,14 +158,14 @@\n     if (!problemNodes.isEmpty()) {\n       addExtern();\n       for (Node n : problemNodes) {\n-        Node name = IR.name(PROTECTOR_FN).srcref(n);\n+        int type = n.getType();\n+\t\tNode name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_677/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:57:42.258821271 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 159, 
          "faulty": "Node name=IR.name(PROTECTOR_FN).srcref(n);", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1458/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:05:38.464931410 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -169,7 +161,6 @@\n \n   private void addExtern() {\n     Node name = IR.name(PROTECTOR_FN);\n-    name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n     Node var = IR.var(name);\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 172, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1089/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:01:44.067846326 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,7 +155,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1089/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:01:44.067846326 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1089/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:01:44.071846343 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1949/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:10:08.502655573 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -157,8 +149,8 @@\n       addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n-        Node replacement = IR.call(name).srcref(n);\n+        int start = 0;\n+\t\tNode replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n@@ -174,7 +166,6 @@\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1949/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:10:08.506655595 -0500\n@@ -3121,22 +3121,23 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tint start = 0;\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 177, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 160, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 160, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "InsertBefore", 
          "seed": "break;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_207/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:52:48.265633377 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -131,7 +125,7 @@\n         (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n-        msg = \"Is there a missing '+' on the previous line?\";\n+        StringBuilder builder = new StringBuilder();\n       } else if (isSimpleOp) {\n         msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n             \"' operator is not being used.\";\n@@ -156,7 +150,8 @@\n     if (!problemNodes.isEmpty()) {\n       addExtern();\n       for (Node n : problemNodes) {\n-        Node name = IR.name(PROTECTOR_FN).srcref(n);\n+        int type = n.getType();\n+\t\tNode name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 134, 
          "faulty": "msg=\"Is there a missing '+' on the previous line?\";", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 159, 
          "faulty": "Node name=IR.name(PROTECTOR_FN).srcref(n);", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_852/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:59:23.015228803 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -163,7 +157,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_469/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:55:34.662305416 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_469/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:55:34.662305416 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_108/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:51:42.465367960 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1933/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:09:58.870601687 -0500\n@@ -115,12 +115,7 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+        int index = -1;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -163,7 +158,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1933/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:09:58.874601710 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1933/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:09:58.874601710 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return toString(true,true,true);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1466/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:05:42.688960689 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -133,8 +127,7 @@\n       if (n.isString()) {\n         msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n-        msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n-            \"' operator is not being used.\";\n+        int start = 0;\n       }\n \n       t.getCompiler().report(\n@@ -163,7 +156,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1466/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:05:42.688960689 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1466/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:05:42.692960716 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 136, 
          "faulty": "msg=\"The result of the '\" + Token.name(n.getType()).toLowerCase() + \"' operator is not being used.\";", 
          "type": "Replace", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_814/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:59:02.699146619 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -163,7 +157,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_814/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:59:02.703146636 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_814/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:59:02.703146636 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1412/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:05:11.872742768 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,7 +155,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1412/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:05:11.872742768 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1412/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:05:11.876742796 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "case PARAM_LIST:"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_2030/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:10:53.802903478 -0500\n@@ -112,15 +112,8 @@\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n     if (parent.getType() == Token.COMMA) {\n       if (isResultUsed) {\n-        return;\n-      }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+        int type = n.getType();\n+\t\treturn;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -157,13 +150,12 @@\n       addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n-        Node replacement = IR.call(name).srcref(n);\n+        int start = 0;\n+\t\tNode replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n@@ -174,7 +166,6 @@\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_2030/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:10:53.802903478 -0500\n@@ -3121,22 +3121,23 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tint start = 0;\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 177, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 160, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 160, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "InsertBefore", 
          "seed": "break;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_159/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:52:16.061503446 -0500\n@@ -114,13 +114,8 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+      StringBuilder builder = new StringBuilder();\n+\tif (n == parent.getLastChild()) {\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -157,7 +152,6 @@\n       addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 160, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1470/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:05:45.288978620 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1470/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:05:45.288978620 -0500\n@@ -3121,22 +3121,23 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1470/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:05:45.288978620 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1602/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:06:54.937463400 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -163,7 +157,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n@@ -174,7 +167,6 @@\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1602/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:06:54.937463400 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 177, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Delete", 
          "seed": "int type=n.getType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1609/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:06:58.217486025 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1609/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:06:58.217486025 -0500\n@@ -3121,22 +3121,13 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        ;\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_2013/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:10:43.678848817 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -157,7 +149,8 @@\n       addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n+        int start = 0;\n+\t\tname.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n@@ -174,7 +167,6 @@\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_2013/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:10:43.682848839 -0500\n@@ -3121,22 +3121,23 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 177, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 160, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Delete", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1430/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:05:23.440825768 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,7 +155,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1430/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:05:23.440825768 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1430/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:05:23.444825796 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_502/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:55:56.706394513 -0500\n@@ -115,11 +115,10 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n+        int start = 0;\n+\t\tfor (Node an : parent.getAncestors()) {\n           int ancestorType = an.getType();\n           if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n         }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n@@ -131,7 +130,6 @@\n         (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n-        msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n         msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n             \"' operator is not being used.\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 134, 
          "faulty": "msg=\"Is there a missing '+' on the previous line?\";", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1571/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:06:37.117338576 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -163,7 +157,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1571/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:06:37.117338576 -0500\n@@ -3121,22 +3121,23 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1571/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:06:37.121338604 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "case PARAM_LIST:"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1357/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:04:39.180590529 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1357/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:04:39.180590529 -0500\n@@ -3135,8 +3135,11 @@\n           }\n         }\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_797/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:58:53.579109729 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_797/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:58:53.583109745 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_2018/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:10:46.246862721 -0500\n@@ -112,15 +112,8 @@\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n     if (parent.getType() == Token.COMMA) {\n       if (isResultUsed) {\n-        return;\n-      }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+        int type = n.getType();\n+\t\treturn;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -157,7 +150,6 @@\n       addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_2018/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:10:46.246862721 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tint start = 0;\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "InsertBefore", 
          "seed": "JSType type=n.getJSType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 160, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "InsertBefore", 
          "seed": "break;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_820/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:59:05.883159499 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -156,7 +148,8 @@\n     if (!problemNodes.isEmpty()) {\n       addExtern();\n       for (Node n : problemNodes) {\n-        Node name = IR.name(PROTECTOR_FN).srcref(n);\n+        int type = n.getType();\n+\t\tNode name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_820/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:59:05.887159516 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 159, 
          "faulty": "Node name=IR.name(PROTECTOR_FN).srcref(n);", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_949/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:00:20.623483303 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,7 +155,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n@@ -173,8 +164,6 @@\n     Node var = IR.var(name);\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n-    builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_949/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:00:20.623483303 -0500\n@@ -3121,19 +3121,7 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        ;\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 176, 
          "faulty": "builder.recordNoAlias();", 
          "type": "Delete", 
          "seed": "break;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 177, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1561/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:06:31.361297548 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -163,7 +157,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1561/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:06:31.361297548 -0500\n@@ -3121,22 +3121,23 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1392/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:05:01.012682160 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -174,7 +166,6 @@\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1392/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:05:01.012682160 -0500\n@@ -3135,8 +3135,11 @@\n           }\n         }\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 177, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1978/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:10:24.534744312 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1978/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:10:24.534744312 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "InsertBefore", 
          "seed": "JSType type=n.getJSType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1204/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:03:00.012171430 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,7 +155,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1204/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:03:00.012171430 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1204/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:03:00.016171447 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1878/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:09:28.218427156 -0500\n@@ -115,12 +115,7 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+        int index = -1;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -174,7 +169,6 @@\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1878/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:09:28.218427156 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 177, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1583/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:06:45.301396305 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1583/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:06:45.301396305 -0500\n@@ -3121,19 +3121,7 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        ;\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1959/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:10:13.542683595 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,7 +155,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n@@ -174,7 +165,6 @@\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1959/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:10:13.546683617 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1959/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:10:13.546683617 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 177, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return toString(true,true,true);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_301/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:53:48.925878253 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -156,7 +150,8 @@\n     if (!problemNodes.isEmpty()) {\n       addExtern();\n       for (Node n : problemNodes) {\n-        Node name = IR.name(PROTECTOR_FN).srcref(n);\n+        int type = n.getType();\n+\t\tNode name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 159, 
          "faulty": "Node name=IR.name(PROTECTOR_FN).srcref(n);", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1764/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:08:26.810061473 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,7 +155,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1764/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:08:26.810061473 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1473/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:05:46.904989733 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -174,7 +166,6 @@\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 177, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "JSType type=n.getJSType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_2040/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:11:00.702940502 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -173,7 +165,6 @@\n     Node var = IR.var(name);\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n-    builder.recordNoAlias();\n     var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_2040/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:11:00.702940502 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_2040/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:11:00.706940522 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"SUB\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"SUB\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 176, 
          "faulty": "builder.recordNoAlias();", 
          "type": "Delete", 
          "seed": "break;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1890/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:09:34.134461220 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1890/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:09:34.138461243 -0500\n@@ -3135,8 +3135,11 @@\n           }\n         }\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1890/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:09:34.138461243 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return toString(true,true,true);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "InsertBefore", 
          "seed": "formatConclusion();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_135/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:52:02.057446963 -0500\n@@ -118,8 +118,7 @@\n         for (Node an : parent.getAncestors()) {\n           int ancestorType = an.getType();\n           if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n+          final String PARAM_NAME = \"jscomp_throw_param\";\n         }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_135/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:52:02.057446963 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1772/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:08:30.934086781 -0500\n@@ -115,12 +115,7 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+        int index = -1;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1772/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:08:30.934086781 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return toString(true,true,true);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1790/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:08:40.034142220 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,18 +155,17 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n   private void addExtern() {\n     Node name = IR.name(PROTECTOR_FN);\n     name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n-    Node var = IR.var(name);\n+    int start = 0;\n+\tNode var = IR.var(name);\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1790/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:08:40.038142245 -0500\n@@ -3121,22 +3121,23 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 173, 
          "faulty": "Node var=IR.var(name);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 177, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Delete", 
          "seed": "break;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_570/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:56:36.974557296 -0500\n@@ -114,13 +114,8 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+      StringBuilder builder = new StringBuilder();\n+\tif (n == parent.getLastChild()) {\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_570/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:56:36.974557296 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "JSType type=n.getJSType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_803/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:58:55.947119307 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -154,9 +146,9 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n       for (Node n : problemNodes) {\n-        Node name = IR.name(PROTECTOR_FN).srcref(n);\n+        int type = n.getType();\n+\t\tNode name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 159, 
          "faulty": "Node name=IR.name(PROTECTOR_FN).srcref(n);", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 157, 
          "faulty": "addExtern();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1342/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:04:30.840555473 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1342/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:04:30.840555473 -0500\n@@ -3135,8 +3135,11 @@\n           }\n         }\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1544/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:06:23.721242535 -0500\n@@ -115,12 +115,7 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+        int index = -1;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1544/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:06:23.721242535 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return toString(true,true,true);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_627/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:57:10.402692450 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -156,7 +148,8 @@\n     if (!problemNodes.isEmpty()) {\n       addExtern();\n       for (Node n : problemNodes) {\n-        Node name = IR.name(PROTECTOR_FN).srcref(n);\n+        int type = n.getType();\n+\t\tNode name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_627/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:57:10.402692450 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 159, 
          "faulty": "Node name=IR.name(PROTECTOR_FN).srcref(n);", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1346/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:04:33.352566035 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1346/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:04:33.356566052 -0500\n@@ -3121,22 +3121,13 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        ;\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_719/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:58:07.098921729 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -133,8 +127,6 @@\n       if (n.isString()) {\n         msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n-        msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n-            \"' operator is not being used.\";\n       }\n \n       t.getCompiler().report(\n@@ -156,14 +148,14 @@\n     if (!problemNodes.isEmpty()) {\n       addExtern();\n       for (Node n : problemNodes) {\n-        Node name = IR.name(PROTECTOR_FN).srcref(n);\n+        int type = n.getType();\n+\t\tNode name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_719/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:58:07.102921745 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 159, 
          "faulty": "Node name=IR.name(PROTECTOR_FN).srcref(n);", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 136, 
          "faulty": "msg=\"The result of the '\" + Token.name(n.getType()).toLowerCase() + \"' operator is not being used.\";", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_714/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:58:04.706912055 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -156,14 +150,14 @@\n     if (!problemNodes.isEmpty()) {\n       addExtern();\n       for (Node n : problemNodes) {\n-        Node name = IR.name(PROTECTOR_FN).srcref(n);\n+        int type = n.getType();\n+\t\tNode name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_714/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:58:04.706912055 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_714/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:58:04.710912071 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 159, 
          "faulty": "Node name=IR.name(PROTECTOR_FN).srcref(n);", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1917/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:09:49.898551095 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1917/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:09:49.898551095 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "InsertBefore", 
          "seed": "JSType type=n.getJSType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_372/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:54:35.074064643 -0500\n@@ -114,13 +114,8 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+      StringBuilder builder = new StringBuilder();\n+\tif (n == parent.getLastChild()) {\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "JSType type=n.getJSType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1186/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:02:47.572118460 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -163,7 +157,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1186/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:02:47.576118477 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1186/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:02:47.576118477 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "case PARAM_LIST:"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_659/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:57:30.126772209 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Replace", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1669/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:07:31.753711566 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -163,7 +157,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1669/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:07:31.757711593 -0500\n@@ -3121,22 +3121,23 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1669/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:07:31.757711593 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return toString(true,true,true);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_405/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:54:55.322146446 -0500\n@@ -114,13 +114,8 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+      StringBuilder builder = new StringBuilder();\n+\tif (n == parent.getLastChild()) {\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_405/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:54:55.326146462 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_2080/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:11:22.339055452 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -157,7 +149,8 @@\n       addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n+        int start = 0;\n+\t\tname.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_2080/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:11:22.343055473 -0500\n@@ -3135,8 +3135,11 @@\n           }\n         }\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_2080/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:11:22.343055473 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"SUB\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"SUB\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 160, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Delete", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_402/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:54:53.450138882 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1620/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:07:03.913525070 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1620/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:07:03.917525096 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return toString(true,true,true);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1809/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:08:50.030202494 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -174,7 +166,6 @@\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1809/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:08:50.034202517 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"SUB\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 177, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"SUB\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Replace", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_856/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:59:25.575239419 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -163,7 +157,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_856/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:59:25.575239419 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1361/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:04:41.572600580 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,7 +155,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "return 0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1641/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:07:16.149607904 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -133,8 +127,6 @@\n       if (n.isString()) {\n         msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n-        msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n-            \"' operator is not being used.\";\n       }\n \n       t.getCompiler().report(\n@@ -163,7 +155,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1641/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:07:16.153607930 -0500\n@@ -3121,22 +3121,23 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1641/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:07:16.153607930 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "case PARAM_LIST:"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 136, 
          "faulty": "msg=\"The result of the '\" + Token.name(n.getType()).toLowerCase() + \"' operator is not being used.\";", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1713/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:07:56.241870092 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -157,7 +149,8 @@\n       addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n+        int start = 0;\n+\t\tname.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1713/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:07:56.245870117 -0500\n@@ -3121,22 +3121,23 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tint start = 0;\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 160, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "return toDot(n,null);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_345/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:54:18.381997215 -0500\n@@ -114,13 +114,8 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+      StringBuilder builder = new StringBuilder();\n+\tif (n == parent.getLastChild()) {\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_99/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:51:36.733341302 -0500\n@@ -115,12 +115,7 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+        int start = 0;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -169,7 +164,6 @@\n \n   private void addExtern() {\n     Node name = IR.name(PROTECTOR_FN);\n-    name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n     Node var = IR.var(name);\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 172, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1974/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:10:22.802734782 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1974/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:10:22.806734804 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "InsertBefore", 
          "seed": "JSType type=n.getJSType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "formatPreamble();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_733/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:58:15.838957077 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_733/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:58:15.842957095 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Replace", 
          "seed": "return toDot(n,null);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1758/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:08:23.590041631 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_801/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:58:55.163116136 -0500\n@@ -118,8 +118,7 @@\n         for (Node an : parent.getAncestors()) {\n           int ancestorType = an.getType();\n           if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n+          final String PARAM_NAME = \"jscomp_throw_param\";\n         }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n@@ -154,9 +153,9 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n       for (Node n : problemNodes) {\n-        Node name = IR.name(PROTECTOR_FN).srcref(n);\n+        int type = n.getType();\n+\t\tNode name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_801/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:58:55.163116136 -0500\n@@ -184,7 +184,10 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              {\n+\t\t\t\tNode block = new Node(Token.BLOCK);\n+\t\t\t\treturn \"EQ\";\n+\t\t\t}\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 159, 
          "faulty": "Node name=IR.name(PROTECTOR_FN).srcref(n);", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 157, 
          "faulty": "addExtern();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "InsertBefore", 
          "seed": "Node block=new Node(Token.BLOCK);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "break;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1325/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:04:19.896509423 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -163,7 +157,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_2011/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:10:42.870844438 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -174,7 +168,6 @@\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_2011/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:10:42.870844438 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Delete", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 177, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Delete", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1290/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:03:57.024412999 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,7 +155,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1002/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:00:48.891607086 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1002/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:00:48.895607105 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1002/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:00:48.895607105 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_2063/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:11:13.099006568 -0500\n@@ -112,15 +112,8 @@\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n     if (parent.getType() == Token.COMMA) {\n       if (isResultUsed) {\n-        return;\n-      }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+        int type = n.getType();\n+\t\treturn;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -157,8 +150,8 @@\n       addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n-        Node replacement = IR.call(name).srcref(n);\n+        int start = 0;\n+\t\tNode replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n@@ -174,7 +167,6 @@\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_2063/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:11:13.103006588 -0500\n@@ -3121,22 +3121,23 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tint start = 0;\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 177, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Delete", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 160, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 160, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "InsertBefore", 
          "seed": "break;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_143/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:52:06.329464192 -0500\n@@ -115,12 +115,7 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+        int start = 0;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -154,7 +149,6 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_143/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:52:06.333464208 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 157, 
          "faulty": "addExtern();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1887/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:09:32.434451450 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -174,7 +166,6 @@\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1887/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:09:32.438451473 -0500\n@@ -3121,22 +3121,23 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 177, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_514/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:56:03.182420690 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -133,8 +127,6 @@\n       if (n.isString()) {\n         msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n-        msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n-            \"' operator is not being used.\";\n       }\n \n       t.getCompiler().report(\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_514/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:56:03.182420690 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 136, 
          "faulty": "msg=\"The result of the '\" + Token.name(n.getType()).toLowerCase() + \"' operator is not being used.\";", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1693/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:07:44.961797678 -0500\n@@ -115,12 +115,7 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+        int index = -1;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -163,14 +158,14 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n   private void addExtern() {\n     Node name = IR.name(PROTECTOR_FN);\n     name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n-    Node var = IR.var(name);\n+    int start = 0;\n+\tNode var = IR.var(name);\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1693/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:07:44.961797678 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1693/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:07:44.965797705 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return toString(true,true,true);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 173, 
          "faulty": "Node var=IR.var(name);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1552/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:06:27.133267184 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1552/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:06:27.137267212 -0500\n@@ -3135,8 +3135,11 @@\n           }\n         }\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1552/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:06:27.137267212 -0500\n@@ -184,7 +184,204 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              switch (token) {\n+\t\t\tcase ERROR:\n+\t\t\t\treturn \"ERROR\";\n+\t\t\tcase RETURN:\n+\t\t\t\treturn \"RETURN\";\n+\t\t\tcase BITOR:\n+\t\t\t\treturn \"BITOR\";\n+\t\t\tcase BITXOR:\n+\t\t\t\treturn \"BITXOR\";\n+\t\t\tcase BITAND:\n+\t\t\t\treturn \"BITAND\";\n+\t\t\tcase EQ:\n+\t\t\t\treturn \"EQ\";\n+\t\t\tcase NE:\n+\t\t\t\treturn \"NE\";\n+\t\t\tcase LT:\n+\t\t\t\treturn \"LT\";\n+\t\t\tcase LE:\n+\t\t\t\treturn \"LE\";\n+\t\t\tcase GT:\n+\t\t\t\treturn \"GT\";\n+\t\t\tcase GE:\n+\t\t\t\treturn \"GE\";\n+\t\t\tcase LSH:\n+\t\t\t\treturn \"LSH\";\n+\t\t\tcase RSH:\n+\t\t\t\treturn \"RSH\";\n+\t\t\tcase URSH:\n+\t\t\t\treturn \"URSH\";\n+\t\t\tcase ADD:\n+\t\t\t\treturn \"ADD\";\n+\t\t\tcase SUB:\n+\t\t\t\treturn \"SUB\";\n+\t\t\tcase MUL:\n+\t\t\t\treturn \"MUL\";\n+\t\t\tcase DIV:\n+\t\t\t\treturn \"DIV\";\n+\t\t\tcase MOD:\n+\t\t\t\treturn \"MOD\";\n+\t\t\tcase NOT:\n+\t\t\t\treturn \"NOT\";\n+\t\t\tcase BITNOT:\n+\t\t\t\treturn \"BITNOT\";\n+\t\t\tcase POS:\n+\t\t\t\treturn \"POS\";\n+\t\t\tcase NEG:\n+\t\t\t\treturn \"NEG\";\n+\t\t\tcase NEW:\n+\t\t\t\treturn \"NEW\";\n+\t\t\tcase DELPROP:\n+\t\t\t\treturn \"DELPROP\";\n+\t\t\tcase TYPEOF:\n+\t\t\t\treturn \"TYPEOF\";\n+\t\t\tcase GETPROP:\n+\t\t\t\treturn \"GETPROP\";\n+\t\t\tcase GETELEM:\n+\t\t\t\treturn \"GETELEM\";\n+\t\t\tcase CALL:\n+\t\t\t\treturn \"CALL\";\n+\t\t\tcase NAME:\n+\t\t\t\treturn \"NAME\";\n+\t\t\tcase LABEL_NAME:\n+\t\t\t\treturn \"LABEL_NAME\";\n+\t\t\tcase NUMBER:\n+\t\t\t\treturn \"NUMBER\";\n+\t\t\tcase STRING:\n+\t\t\t\treturn \"STRING\";\n+\t\t\tcase STRING_KEY:\n+\t\t\t\treturn \"STRING_KEY\";\n+\t\t\tcase NULL:\n+\t\t\t\treturn \"NULL\";\n+\t\t\tcase THIS:\n+\t\t\t\treturn \"THIS\";\n+\t\t\tcase FALSE:\n+\t\t\t\treturn \"FALSE\";\n+\t\t\tcase TRUE:\n+\t\t\t\treturn \"TRUE\";\n+\t\t\tcase SHEQ:\n+\t\t\t\treturn \"SHEQ\";\n+\t\t\tcase SHNE:\n+\t\t\t\treturn \"SHNE\";\n+\t\t\tcase REGEXP:\n+\t\t\t\treturn \"REGEXP\";\n+\t\t\tcase THROW:\n+\t\t\t\treturn \"THROW\";\n+\t\t\tcase IN:\n+\t\t\t\treturn \"IN\";\n+\t\t\tcase INSTANCEOF:\n+\t\t\t\treturn \"INSTANCEOF\";\n+\t\t\tcase ARRAYLIT:\n+\t\t\t\treturn \"ARRAYLIT\";\n+\t\t\tcase OBJECTLIT:\n+\t\t\t\treturn \"OBJECTLIT\";\n+\t\t\tcase TRY:\n+\t\t\t\treturn \"TRY\";\n+\t\t\tcase PARAM_LIST:\n+\t\t\t\treturn \"PARAM_LIST\";\n+\t\t\tcase COMMA:\n+\t\t\t\treturn \"COMMA\";\n+\t\t\tcase ASSIGN:\n+\t\t\t\treturn \"ASSIGN\";\n+\t\t\tcase ASSIGN_BITOR:\n+\t\t\t\treturn \"ASSIGN_BITOR\";\n+\t\t\tcase ASSIGN_BITXOR:\n+\t\t\t\treturn \"ASSIGN_BITXOR\";\n+\t\t\tcase ASSIGN_BITAND:\n+\t\t\t\treturn \"ASSIGN_BITAND\";\n+\t\t\tcase ASSIGN_LSH:\n+\t\t\t\treturn \"ASSIGN_LSH\";\n+\t\t\tcase ASSIGN_RSH:\n+\t\t\t\treturn \"ASSIGN_RSH\";\n+\t\t\tcase ASSIGN_URSH:\n+\t\t\t\treturn \"ASSIGN_URSH\";\n+\t\t\tcase ASSIGN_ADD:\n+\t\t\t\treturn \"ASSIGN_ADD\";\n+\t\t\tcase ASSIGN_SUB:\n+\t\t\t\treturn \"ASSIGN_SUB\";\n+\t\t\tcase ASSIGN_MUL:\n+\t\t\t\treturn \"ASSIGN_MUL\";\n+\t\t\tcase ASSIGN_DIV:\n+\t\t\t\treturn \"ASSIGN_DIV\";\n+\t\t\tcase ASSIGN_MOD:\n+\t\t\t\treturn \"ASSIGN_MOD\";\n+\t\t\tcase HOOK:\n+\t\t\t\treturn \"HOOK\";\n+\t\t\tcase COLON:\n+\t\t\t\treturn \"COLON\";\n+\t\t\tcase OR:\n+\t\t\t\treturn \"OR\";\n+\t\t\tcase AND:\n+\t\t\t\treturn \"AND\";\n+\t\t\tcase INC:\n+\t\t\t\treturn \"INC\";\n+\t\t\tcase DEC:\n+\t\t\t\treturn \"DEC\";\n+\t\t\tcase FUNCTION:\n+\t\t\t\treturn \"FUNCTION\";\n+\t\t\tcase IF:\n+\t\t\t\treturn \"IF\";\n+\t\t\tcase SWITCH:\n+\t\t\t\treturn \"SWITCH\";\n+\t\t\tcase CASE:\n+\t\t\t\treturn \"CASE\";\n+\t\t\tcase DEFAULT_CASE:\n+\t\t\t\treturn \"DEFAULT_CASE\";\n+\t\t\tcase WHILE:\n+\t\t\t\treturn \"WHILE\";\n+\t\t\tcase DO:\n+\t\t\t\treturn \"DO\";\n+\t\t\tcase FOR:\n+\t\t\t\treturn \"FOR\";\n+\t\t\tcase BREAK:\n+\t\t\t\treturn \"BREAK\";\n+\t\t\tcase CONTINUE:\n+\t\t\t\treturn \"CONTINUE\";\n+\t\t\tcase VAR:\n+\t\t\t\treturn \"VAR\";\n+\t\t\tcase WITH:\n+\t\t\t\treturn \"WITH\";\n+\t\t\tcase CATCH:\n+\t\t\t\treturn \"CATCH\";\n+\t\t\tcase EMPTY:\n+\t\t\t\treturn \"EMPTY\";\n+\t\t\tcase BLOCK:\n+\t\t\t\treturn \"BLOCK\";\n+\t\t\tcase LABEL:\n+\t\t\t\treturn \"LABEL\";\n+\t\t\tcase EXPR_RESULT:\n+\t\t\t\treturn \"EXPR_RESULT\";\n+\t\t\tcase SCRIPT:\n+\t\t\t\treturn \"SCRIPT\";\n+\t\t\tcase GETTER_DEF:\n+\t\t\t\treturn \"GETTER_DEF\";\n+\t\t\tcase SETTER_DEF:\n+\t\t\t\treturn \"SETTER_DEF\";\n+\t\t\tcase CONST:\n+\t\t\t\treturn \"CONST\";\n+\t\t\tcase DEBUGGER:\n+\t\t\t\treturn \"DEBUGGER\";\n+\t\t\tcase ANNOTATION:\n+\t\t\t\treturn \"ANNOTATION\";\n+\t\t\tcase PIPE:\n+\t\t\t\treturn \"PIPE\";\n+\t\t\tcase STAR:\n+\t\t\t\treturn \"STAR\";\n+\t\t\tcase EOC:\n+\t\t\t\treturn \"EOC\";\n+\t\t\tcase QMARK:\n+\t\t\t\treturn \"QMARK\";\n+\t\t\tcase ELLIPSIS:\n+\t\t\t\treturn \"ELLIPSIS\";\n+\t\t\tcase BANG:\n+\t\t\t\treturn \"BANG\";\n+\t\t\tcase VOID:\n+\t\t\t\treturn \"VOID\";\n+\t\t\tcase EQUALS:\n+\t\t\t\treturn \"EQUALS\";\n+\t\t\t}\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "switch (token) {\ncase ERROR:\n  return \"ERROR\";\ncase RETURN:\nreturn \"RETURN\";\ncase BITOR:\nreturn \"BITOR\";\ncase BITXOR:\nreturn \"BITXOR\";\ncase BITAND:\nreturn \"BITAND\";\ncase EQ:\nreturn \"EQ\";\ncase NE:\nreturn \"NE\";\ncase LT:\nreturn \"LT\";\ncase LE:\nreturn \"LE\";\ncase GT:\nreturn \"GT\";\ncase GE:\nreturn \"GE\";\ncase LSH:\nreturn \"LSH\";\ncase RSH:\nreturn \"RSH\";\ncase URSH:\nreturn \"URSH\";\ncase ADD:\nreturn \"ADD\";\ncase SUB:\nreturn \"SUB\";\ncase MUL:\nreturn \"MUL\";\ncase DIV:\nreturn \"DIV\";\ncase MOD:\nreturn \"MOD\";\ncase NOT:\nreturn \"NOT\";\ncase BITNOT:\nreturn \"BITNOT\";\ncase POS:\nreturn \"POS\";\ncase NEG:\nreturn \"NEG\";\ncase NEW:\nreturn \"NEW\";\ncase DELPROP:\nreturn \"DELPROP\";\ncase TYPEOF:\nreturn \"TYPEOF\";\ncase GETPROP:\nreturn \"GETPROP\";\ncase GETELEM:\nreturn \"GETELEM\";\ncase CALL:\nreturn \"CALL\";\ncase NAME:\nreturn \"NAME\";\ncase LABEL_NAME:\nreturn \"LABEL_NAME\";\ncase NUMBER:\nreturn \"NUMBER\";\ncase STRING:\nreturn \"STRING\";\ncase STRING_KEY:\nreturn \"STRING_KEY\";\ncase NULL:\nreturn \"NULL\";\ncase THIS:\nreturn \"THIS\";\ncase FALSE:\nreturn \"FALSE\";\ncase TRUE:\nreturn \"TRUE\";\ncase SHEQ:\nreturn \"SHEQ\";\ncase SHNE:\nreturn \"SHNE\";\ncase REGEXP:\nreturn \"REGEXP\";\ncase THROW:\nreturn \"THROW\";\ncase IN:\nreturn \"IN\";\ncase INSTANCEOF:\nreturn \"INSTANCEOF\";\ncase ARRAYLIT:\nreturn \"ARRAYLIT\";\ncase OBJECTLIT:\nreturn \"OBJECTLIT\";\ncase TRY:\nreturn \"TRY\";\ncase PARAM_LIST:\nreturn \"PARAM_LIST\";\ncase COMMA:\nreturn \"COMMA\";\ncase ASSIGN:\nreturn \"ASSIGN\";\ncase ASSIGN_BITOR:\nreturn \"ASSIGN_BITOR\";\ncase ASSIGN_BITXOR:\nreturn \"ASSIGN_BITXOR\";\ncase ASSIGN_BITAND:\nreturn \"ASSIGN_BITAND\";\ncase ASSIGN_LSH:\nreturn \"ASSIGN_LSH\";\ncase ASSIGN_RSH:\nreturn \"ASSIGN_RSH\";\ncase ASSIGN_URSH:\nreturn \"ASSIGN_URSH\";\ncase ASSIGN_ADD:\nreturn \"ASSIGN_ADD\";\ncase ASSIGN_SUB:\nreturn \"ASSIGN_SUB\";\ncase ASSIGN_MUL:\nreturn \"ASSIGN_MUL\";\ncase ASSIGN_DIV:\nreturn \"ASSIGN_DIV\";\ncase ASSIGN_MOD:\nreturn \"ASSIGN_MOD\";\ncase HOOK:\nreturn \"HOOK\";\ncase COLON:\nreturn \"COLON\";\ncase OR:\nreturn \"OR\";\ncase AND:\nreturn \"AND\";\ncase INC:\nreturn \"INC\";\ncase DEC:\nreturn \"DEC\";\ncase FUNCTION:\nreturn \"FUNCTION\";\ncase IF:\nreturn \"IF\";\ncase SWITCH:\nreturn \"SWITCH\";\ncase CASE:\nreturn \"CASE\";\ncase DEFAULT_CASE:\nreturn \"DEFAULT_CASE\";\ncase WHILE:\nreturn \"WHILE\";\ncase DO:\nreturn \"DO\";\ncase FOR:\nreturn \"FOR\";\ncase BREAK:\nreturn \"BREAK\";\ncase CONTINUE:\nreturn \"CONTINUE\";\ncase VAR:\nreturn \"VAR\";\ncase WITH:\nreturn \"WITH\";\ncase CATCH:\nreturn \"CATCH\";\ncase EMPTY:\nreturn \"EMPTY\";\ncase BLOCK:\nreturn \"BLOCK\";\ncase LABEL:\nreturn \"LABEL\";\ncase EXPR_RESULT:\nreturn \"EXPR_RESULT\";\ncase SCRIPT:\nreturn \"SCRIPT\";\ncase GETTER_DEF:\nreturn \"GETTER_DEF\";\ncase SETTER_DEF:\nreturn \"SETTER_DEF\";\ncase CONST:\nreturn \"CONST\";\ncase DEBUGGER:\nreturn \"DEBUGGER\";\ncase ANNOTATION:\nreturn \"ANNOTATION\";\ncase PIPE:\nreturn \"PIPE\";\ncase STAR:\nreturn \"STAR\";\ncase EOC:\nreturn \"EOC\";\ncase QMARK:\nreturn \"QMARK\";\ncase ELLIPSIS:\nreturn \"ELLIPSIS\";\ncase BANG:\nreturn \"BANG\";\ncase VOID:\nreturn \"VOID\";\ncase EQUALS:\nreturn \"EQUALS\";\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1501/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:06:00.881084771 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -157,7 +149,8 @@\n       addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n+        int start = 0;\n+\t\tname.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1501/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:06:00.881084771 -0500\n@@ -3121,22 +3121,23 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tint start = 0;\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 160, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1661/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:07:27.661684588 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,7 +155,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n@@ -174,7 +165,6 @@\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 177, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_864/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:59:29.615257458 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,7 +155,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_864/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:59:29.619257477 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1550/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:06:26.273260983 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1550/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:06:26.277261011 -0500\n@@ -3135,8 +3135,11 @@\n           }\n         }\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1550/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:06:26.277261011 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return toString(true,true,true);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_899/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:59:50.915352186 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_899/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:59:50.915352186 -0500\n@@ -3135,8 +3135,11 @@\n           }\n         }\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1014/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:00:56.251639172 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1014/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:00:56.255639189 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1536/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:06:19.669213093 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -174,7 +166,6 @@\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1536/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:06:19.669213093 -0500\n@@ -3121,22 +3121,23 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1536/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:06:19.673213123 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 177, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return toString(true,true,true);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_305/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:53:51.385888186 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -156,7 +150,8 @@\n     if (!problemNodes.isEmpty()) {\n       addExtern();\n       for (Node n : problemNodes) {\n-        Node name = IR.name(PROTECTOR_FN).srcref(n);\n+        int type = n.getType();\n+\t\tNode name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 159, 
          "faulty": "Node name=IR.name(PROTECTOR_FN).srcref(n);", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1903/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:09:40.558498000 -0500\n@@ -112,15 +112,8 @@\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n     if (parent.getType() == Token.COMMA) {\n       if (isResultUsed) {\n-        return;\n-      }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+        int type = n.getType();\n+\t\treturn;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -157,13 +150,12 @@\n       addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n-        Node replacement = IR.call(name).srcref(n);\n+        int start = 0;\n+\t\tNode replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1903/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:09:40.558498000 -0500\n@@ -3121,22 +3121,23 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tint start = 0;\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 160, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 160, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "InsertBefore", 
          "seed": "break;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1097/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:01:49.603870176 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_652/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:57:26.066755792 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -131,7 +125,6 @@\n         (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n-        msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n         msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n             \"' operator is not being used.\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 134, 
          "faulty": "msg=\"Is there a missing '+' on the previous line?\";", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_383/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:54:42.106093051 -0500\n@@ -114,13 +114,8 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+      StringBuilder builder = new StringBuilder();\n+\tif (n == parent.getLastChild()) {\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -133,8 +128,6 @@\n       if (n.isString()) {\n         msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n-        msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n-            \"' operator is not being used.\";\n       }\n \n       t.getCompiler().report(\n@@ -156,7 +149,8 @@\n     if (!problemNodes.isEmpty()) {\n       addExtern();\n       for (Node n : problemNodes) {\n-        Node name = IR.name(PROTECTOR_FN).srcref(n);\n+        int type = n.getType();\n+\t\tNode name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "JSType type=n.getJSType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 136, 
          "faulty": "msg=\"The result of the '\" + Token.name(n.getType()).toLowerCase() + \"' operator is not being used.\";", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 159, 
          "faulty": "Node name=IR.name(PROTECTOR_FN).srcref(n);", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1188/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:02:48.480122330 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -157,13 +149,11 @@\n       addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1188/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:02:48.480122330 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 160, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_225/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:53:00.297681936 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1856/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:09:16.298357936 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,18 +155,17 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n   private void addExtern() {\n     Node name = IR.name(PROTECTOR_FN);\n     name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n-    Node var = IR.var(name);\n+    int start = 0;\n+\tNode var = IR.var(name);\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1856/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:09:16.302357960 -0500\n@@ -3121,22 +3121,23 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1856/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:09:16.302357960 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"RETURN\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 173, 
          "faulty": "Node var=IR.var(name);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 177, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Delete", 
          "seed": "break;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"RETURN\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "JSType type=n.getJSType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_953/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:00:22.199490229 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,7 +155,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_953/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:00:22.199490229 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1699/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:07:48.093817886 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1307/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:04:09.220464447 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,7 +155,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "InsertBefore", 
          "seed": "int keyParent=key(parent);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_696/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:57:54.138869315 -0500\n@@ -111,16 +111,11 @@\n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n     if (parent.getType() == Token.COMMA) {\n-      if (isResultUsed) {\n+      int start = 0;\n+\tif (isResultUsed) {\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -133,8 +128,6 @@\n       if (n.isString()) {\n         msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n-        msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n-            \"' operator is not being used.\";\n       }\n \n       t.getCompiler().report(\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_696/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:57:54.138869315 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 136, 
          "faulty": "msg=\"The result of the '\" + Token.name(n.getType()).toLowerCase() + \"' operator is not being used.\";", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (isResultUsed) {\n  return;\n}", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1546/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:06:24.621249049 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1546/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:06:24.621249049 -0500\n@@ -3135,8 +3135,11 @@\n           }\n         }\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1985/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:10:28.802767746 -0500\n@@ -112,15 +112,8 @@\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n     if (parent.getType() == Token.COMMA) {\n       if (isResultUsed) {\n-        return;\n-      }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+        int type = n.getType();\n+\t\treturn;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -157,8 +150,8 @@\n       addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n-        Node replacement = IR.call(name).srcref(n);\n+        int start = 0;\n+\t\tNode replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1985/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:10:28.802767746 -0500\n@@ -3121,22 +3121,23 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tint start = 0;\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 160, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 160, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "InsertBefore", 
          "seed": "break;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1567/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:06:34.613320770 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1567/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:06:34.617320799 -0500\n@@ -3135,8 +3135,11 @@\n           }\n         }\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_701/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:57:57.406882532 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -156,7 +150,8 @@\n     if (!problemNodes.isEmpty()) {\n       addExtern();\n       for (Node n : problemNodes) {\n-        Node name = IR.name(PROTECTOR_FN).srcref(n);\n+        int type = n.getType();\n+\t\tNode name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_701/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:57:57.410882548 -0500\n@@ -3121,19 +3121,7 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        final String PARAM_NAME = \"jscomp_throw_param\";\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_701/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:57:57.410882548 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 159, 
          "faulty": "Node name=IR.name(PROTECTOR_FN).srcref(n);", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_426/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:55:08.902201317 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Replace", 
          "seed": "JSType type=n.getJSType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1208/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:03:02.380181503 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_750/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:58:26.214999045 -0500\n@@ -111,16 +111,11 @@\n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n     if (parent.getType() == Token.COMMA) {\n-      if (isResultUsed) {\n+      int start = 0;\n+\tif (isResultUsed) {\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -133,8 +128,6 @@\n       if (n.isString()) {\n         msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n-        msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n-            \"' operator is not being used.\";\n       }\n \n       t.getCompiler().report(\n@@ -156,7 +149,8 @@\n     if (!problemNodes.isEmpty()) {\n       addExtern();\n       for (Node n : problemNodes) {\n-        Node name = IR.name(PROTECTOR_FN).srcref(n);\n+        int type = n.getType();\n+\t\tNode name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_750/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:58:26.218999061 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 159, 
          "faulty": "Node name=IR.name(PROTECTOR_FN).srcref(n);", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 136, 
          "faulty": "msg=\"The result of the '\" + Token.name(n.getType()).toLowerCase() + \"' operator is not being used.\";", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (isResultUsed) {\n  return;\n}", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1477/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:05:48.525000844 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1477/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:05:48.529000872 -0500\n@@ -3135,8 +3135,11 @@\n           }\n         }\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1805/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:08:48.386192624 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -157,13 +149,11 @@\n       addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1805/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:08:48.386192624 -0500\n@@ -3121,22 +3121,23 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1805/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:08:48.386192624 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "case PARAM_LIST:"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "InsertBefore", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 160, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "Delete", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "int index=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1045/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:01:15.891724521 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,7 +155,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1045/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:01:15.895724538 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1682/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:07:39.265760721 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,7 +155,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n@@ -174,7 +165,6 @@\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1682/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:07:39.269760746 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"SUB\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 177, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"SUB\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1848/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:09:11.914332278 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -131,7 +123,7 @@\n         (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n-        msg = \"Is there a missing '+' on the previous line?\";\n+        int start = 0;\n       } else if (isSimpleOp) {\n         msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n             \"' operator is not being used.\";\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1848/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:09:11.914332278 -0500\n@@ -3121,22 +3121,23 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 134, 
          "faulty": "msg=\"Is there a missing '+' on the previous line?\";", 
          "type": "Replace", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1634/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:07:12.245581626 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -163,7 +157,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1634/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:07:12.245581626 -0500\n@@ -3121,22 +3121,23 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1956/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:10:11.842674155 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_924/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:00:06.871422745 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -154,9 +146,9 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n       for (Node n : problemNodes) {\n-        Node name = IR.name(PROTECTOR_FN).srcref(n);\n+        int type = n.getType();\n+\t\tNode name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 159, 
          "faulty": "Node name=IR.name(PROTECTOR_FN).srcref(n);", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 157, 
          "faulty": "addExtern();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_598/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:56:53.958625962 -0500\n@@ -115,12 +115,7 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+        int start = 0;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1892/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:09:34.922465744 -0500\n@@ -115,12 +115,7 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+        int index = -1;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1892/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:09:34.922465744 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return toString(true,true,true);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1487/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:05:53.545035119 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,7 +155,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1487/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:05:53.545035119 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_992/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:00:43.247582442 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_992/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:00:43.251582461 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1993/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:10:33.898795623 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -157,7 +151,8 @@\n       addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n+        int start = 0;\n+\t\tname.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n@@ -174,7 +169,6 @@\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1993/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:10:33.902795645 -0500\n@@ -3135,8 +3135,11 @@\n           }\n         }\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 177, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 160, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Delete", 
          "seed": "int type=n.getType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1507/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:06:03.525102541 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,7 +155,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n@@ -174,7 +165,6 @@\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1507/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:06:03.529102567 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1507/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:06:03.529102567 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 177, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return toString(true,true,true);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1559/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:06:30.541291675 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1559/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:06:30.545291703 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return toString(true,true,true);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_600/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:56:54.786629311 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_2022/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:10:48.650875712 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_2022/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:10:48.650875712 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Delete", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_946/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:00:19.035476322 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -163,7 +157,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_946/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:00:19.035476322 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1961/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:10:14.354688098 -0500\n@@ -116,10 +116,6 @@\n       }\n       if (n == parent.getLastChild()) {\n         for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n         }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1961/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:10:14.354688098 -0500\n@@ -3135,8 +3135,11 @@\n           }\n         }\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Delete", 
          "seed": "int type=n.getType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_93/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:51:32.717315717 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_568/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:56:36.190554126 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -133,8 +127,6 @@\n       if (n.isString()) {\n         msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n-        msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n-            \"' operator is not being used.\";\n       }\n \n       t.getCompiler().report(\n@@ -163,7 +155,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 136, 
          "faulty": "msg=\"The result of the '\" + Token.name(n.getType()).toLowerCase() + \"' operator is not being used.\";", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_339/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:54:14.361980978 -0500\n@@ -114,13 +114,8 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+      StringBuilder builder = new StringBuilder();\n+\tif (n == parent.getLastChild()) {\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -133,8 +128,6 @@\n       if (n.isString()) {\n         msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n-        msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n-            \"' operator is not being used.\";\n       }\n \n       t.getCompiler().report(\n@@ -163,7 +156,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "JSType type=n.getJSType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 136, 
          "faulty": "msg=\"The result of the '\" + Token.name(n.getType()).toLowerCase() + \"' operator is not being used.\";", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_735/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:58:16.726960670 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Replace", 
          "seed": "this.level=level;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1449/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:05:34.388902983 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -163,7 +157,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1449/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:05:34.392903012 -0500\n@@ -3121,22 +3121,23 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_816/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:59:03.487149807 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -156,7 +148,8 @@\n     if (!problemNodes.isEmpty()) {\n       addExtern();\n       for (Node n : problemNodes) {\n-        Node name = IR.name(PROTECTOR_FN).srcref(n);\n+        int type = n.getType();\n+\t\tNode name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_816/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:59:03.491149824 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 159, 
          "faulty": "Node name=IR.name(PROTECTOR_FN).srcref(n);", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_807/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:58:58.427129339 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -163,7 +157,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_807/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:58:58.427129339 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_807/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:58:58.431129355 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1262/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:03:39.224337775 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1262/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:03:39.228337791 -0500\n@@ -3121,19 +3121,7 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        ;\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1262/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:03:39.228337791 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_707/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:58:00.662895700 -0500\n@@ -114,13 +114,8 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+      StringBuilder builder = new StringBuilder();\n+\tif (n == parent.getLastChild()) {\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -163,7 +158,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_707/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:58:00.662895700 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_292/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:53:43.165854993 -0500\n@@ -114,13 +114,9 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+      StringBuilder builder = new StringBuilder();\n+\tif (n == parent.getLastChild()) {\n+        int start = 0;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "JSType type=n.getJSType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1760/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:08:24.402046642 -0500\n@@ -115,12 +115,7 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+        int index = -1;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -170,11 +165,11 @@\n   private void addExtern() {\n     Node name = IR.name(PROTECTOR_FN);\n     name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n-    Node var = IR.var(name);\n+    int start = 0;\n+\tNode var = IR.var(name);\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1760/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:08:24.402046642 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 177, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 173, 
          "faulty": "Node var=IR.var(name);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1942/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:10:03.998630430 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -174,7 +166,6 @@\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1942/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:10:04.002630452 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 177, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return toString(true,true,true);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1018/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:00:58.819650353 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,7 +155,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1018/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:00:58.823650372 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1018/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:00:58.823650372 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_582/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:56:43.558583914 -0500\n@@ -114,13 +114,9 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+      StringBuilder builder = new StringBuilder();\n+\tif (n == parent.getLastChild()) {\n+        int start = 0;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -163,7 +159,8 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n+      int start = 0;\n+\tcompiler.reportCodeChange();\n     }\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_155/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:52:13.465492975 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1899/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:09:38.250484811 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,7 +155,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1899/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:09:38.254484833 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1899/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:09:38.254484833 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return toString(true,true,true);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return toString(true,true,true);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1827/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:08:59.774260639 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1652/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:07:22.705651720 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,18 +155,17 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n   private void addExtern() {\n-    Node name = IR.name(PROTECTOR_FN);\n+    final String PARAM_NAME = \"jscomp_throw_param\";\n+\tNode name = IR.name(PROTECTOR_FN);\n     name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n     Node var = IR.var(name);\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 177, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Delete", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 171, 
          "faulty": "Node name=IR.name(PROTECTOR_FN);", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1723/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:08:01.073900808 -0500\n@@ -115,12 +115,7 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+        int index = -1;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -163,14 +158,14 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n   private void addExtern() {\n     Node name = IR.name(PROTECTOR_FN);\n     name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n-    Node var = IR.var(name);\n+    int start = 0;\n+\tNode var = IR.var(name);\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1723/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:08:01.077900832 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1723/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:08:01.077900832 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return toString(true,true,true);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 173, 
          "faulty": "Node var=IR.var(name);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1538/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:06:20.489219066 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -157,13 +151,13 @@\n       addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n+        int start = 0;\n+\t\tname.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1538/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:06:20.493219096 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tint start = 0;\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 160, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Replace", 
          "seed": "formatConclusion();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1514/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:06:06.925125298 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -163,7 +157,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1514/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:06:06.929125324 -0500\n@@ -3121,22 +3121,23 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1514/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:06:06.929125324 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "case PARAM_LIST:"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1870/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:09:24.138403553 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -131,7 +123,8 @@\n         (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n-        msg = \"Is there a missing '+' on the previous line?\";\n+        int type = n.getType();\n+\t\tmsg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n         msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n             \"' operator is not being used.\";\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1870/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:09:24.142403575 -0500\n@@ -3135,8 +3135,11 @@\n           }\n         }\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 134, 
          "faulty": "msg=\"Is there a missing '+' on the previous line?\";", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Delete", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_809/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:58:59.203132478 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,7 +155,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_389/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:54:45.430106480 -0500\n@@ -115,11 +115,11 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n+        int start = 0;\n+\t\tfor (Node an : parent.getAncestors()) {\n           int ancestorType = an.getType();\n           if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n+          final String PARAM_NAME = \"jscomp_throw_param\";\n         }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_2066/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:11:14.859015903 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_2066/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:11:14.859015903 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Delete", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "InsertBefore", 
          "seed": "JSType type=n.getJSType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_282/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:53:36.757829120 -0500\n@@ -114,13 +114,8 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+      StringBuilder builder = new StringBuilder();\n+\tif (n == parent.getLastChild()) {\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -133,8 +128,6 @@\n       if (n.isString()) {\n         msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n-        msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n-            \"' operator is not being used.\";\n       }\n \n       t.getCompiler().report(\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "JSType type=n.getJSType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 136, 
          "faulty": "msg=\"The result of the '\" + Token.name(n.getType()).toLowerCase() + \"' operator is not being used.\";", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1158/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:02:27.716033695 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,7 +155,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1876/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:09:27.358422187 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1876/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:09:27.358422187 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "InsertBefore", 
          "seed": "JSType type=n.getJSType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1730/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:08:05.029925820 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,7 +155,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1730/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:08:05.033925846 -0500\n@@ -3121,22 +3121,23 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1770/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:08:30.062081440 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -131,7 +123,7 @@\n         (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n-        msg = \"Is there a missing '+' on the previous line?\";\n+        int index = -1;\n       } else if (isSimpleOp) {\n         msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n             \"' operator is not being used.\";\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1770/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:08:30.062081440 -0500\n@@ -3135,8 +3135,11 @@\n           }\n         }\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1770/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:08:30.066081465 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return toString(true,true,true);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 134, 
          "faulty": "msg=\"Is there a missing '+' on the previous line?\";", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1721/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:08:00.261895657 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -174,7 +166,6 @@\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1721/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:08:00.261895657 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"SUB\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 177, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"SUB\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Replace", 
          "seed": "return new DefaultCodingConvention();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1463/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:05:40.976948845 -0500\n@@ -112,15 +112,8 @@\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n     if (parent.getType() == Token.COMMA) {\n       if (isResultUsed) {\n-        return;\n-      }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+        final String PARAM_NAME = \"jscomp_throw_param\";\n+\t\treturn;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1463/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:05:40.976948845 -0500\n@@ -3135,8 +3135,11 @@\n           }\n         }\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_958/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:00:24.615500838 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -154,7 +148,6 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_958/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:00:24.615500838 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 157, 
          "faulty": "addExtern();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1585/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:06:46.165402362 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,7 +155,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1585/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:06:46.169402389 -0500\n@@ -3121,22 +3121,23 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_377/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:54:38.218077343 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_444/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:55:20.838249550 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1607/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:06:57.373480212 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Delete", 
          "seed": "int type=n.getType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1971/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:10:21.014724928 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -131,7 +123,8 @@\n         (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n-        msg = \"Is there a missing '+' on the previous line?\";\n+        final String PARAM_NAME = \"jscomp_throw_param\";\n+\t\tmsg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n         msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n             \"' operator is not being used.\";\n@@ -157,8 +150,8 @@\n       addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n-        Node replacement = IR.call(name).srcref(n);\n+        int start = 0;\n+\t\tNode replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n@@ -174,7 +167,6 @@\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1971/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:10:21.014724928 -0500\n@@ -3121,22 +3121,23 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tint start = 0;\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 177, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 160, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 160, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "InsertBefore", 
          "seed": "break;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 134, 
          "faulty": "msg=\"Is there a missing '+' on the previous line?\";", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_983/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:00:38.339560986 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,7 +155,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n@@ -173,8 +164,6 @@\n     Node var = IR.var(name);\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n-    builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_983/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:00:38.339560986 -0500\n@@ -3121,19 +3121,7 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        ;\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 176, 
          "faulty": "builder.recordNoAlias();", 
          "type": "Delete", 
          "seed": "break;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 177, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Replace", 
          "seed": "this.level=level;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1526/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:06:13.801170995 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,7 +155,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1526/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:06:13.801170995 -0500\n@@ -3121,22 +3121,23 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1526/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:06:13.805171022 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "case PARAM_LIST:"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1638/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:07:14.553597177 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -173,7 +167,6 @@\n     Node var = IR.var(name);\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n-    builder.recordNoAlias();\n     var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Delete", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 176, 
          "faulty": "builder.recordNoAlias();", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_247/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:53:13.389734779 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_227/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:53:01.081685100 -0500\n@@ -114,13 +114,8 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+      StringBuilder builder = new StringBuilder();\n+\tif (n == parent.getLastChild()) {\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -157,7 +152,6 @@\n       addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 160, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "JSType type=n.getJSType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_760/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:58:32.491024430 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_760/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:58:32.495024446 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_861/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:59:28.043250441 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -156,14 +150,14 @@\n     if (!problemNodes.isEmpty()) {\n       addExtern();\n       for (Node n : problemNodes) {\n-        Node name = IR.name(PROTECTOR_FN).srcref(n);\n+        int type = n.getType();\n+\t\tNode name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_861/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:59:28.047250459 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 159, 
          "faulty": "Node name=IR.name(PROTECTOR_FN).srcref(n);", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_642/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:57:20.450733082 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -163,7 +157,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_642/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:57:20.450733082 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1850/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:09:12.738337109 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -163,7 +157,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1850/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:09:12.742337132 -0500\n@@ -3121,22 +3121,23 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1154/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:02:25.340023534 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1154/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:02:25.344023551 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1154/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:02:25.344023551 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1375/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:04:50.488638014 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,7 +155,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n@@ -174,7 +165,6 @@\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1375/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:04:50.492638031 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1375/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:04:50.492638031 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 177, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1859/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:09:17.746366387 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1859/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:09:17.750366411 -0500\n@@ -3135,8 +3135,11 @@\n           }\n         }\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1859/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:09:17.750366411 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return toString(true,true,true);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_128/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:51:56.925426266 -0500\n@@ -115,12 +115,7 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+        int start = 0;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1505/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:06:02.649096661 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -163,7 +157,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n@@ -174,7 +167,6 @@\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1505/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:06:02.649096661 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1505/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:06:02.653096687 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 177, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return toString(true,true,true);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_688/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:57:48.482846442 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_688/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:57:48.486846458 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1590/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:06:48.553419054 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -163,7 +157,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n@@ -174,7 +167,6 @@\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1590/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:06:48.557419082 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 177, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return toString(true,true,true);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1944/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:10:05.054636333 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -163,7 +157,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n@@ -174,7 +167,6 @@\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1944/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:10:05.054636333 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1944/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:10:05.058636357 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 177, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return toString(true,true,true);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_2060/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:11:11.426997690 -0500\n@@ -112,15 +112,8 @@\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n     if (parent.getType() == Token.COMMA) {\n       if (isResultUsed) {\n-        return;\n-      }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+        int type = n.getType();\n+\t\treturn;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -157,8 +150,8 @@\n       addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n-        Node replacement = IR.call(name).srcref(n);\n+        int start = 0;\n+\t\tNode replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n@@ -169,12 +162,10 @@\n \n   private void addExtern() {\n     Node name = IR.name(PROTECTOR_FN);\n-    name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n     Node var = IR.var(name);\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_2060/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:11:11.426997690 -0500\n@@ -3121,22 +3121,23 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tint start = 0;\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 177, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 160, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 160, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "InsertBefore", 
          "seed": "break;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 172, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "Delete", 
          "seed": "return isExported(name,false) || isExported(name,true);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_2002/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:10:37.978817861 -0500\n@@ -115,12 +115,7 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+        int index = -1;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1453/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:05:36.028914443 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1453/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:05:36.032914471 -0500\n@@ -3121,22 +3121,23 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "InsertBefore", 
          "seed": "int index=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1784/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:08:36.806122618 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1784/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:08:36.810122642 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"SUB\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"SUB\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Replace", 
          "seed": "return new DefaultCodingConvention();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_460/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:55:28.978282445 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -156,7 +150,8 @@\n     if (!problemNodes.isEmpty()) {\n       addExtern();\n       for (Node n : problemNodes) {\n-        Node name = IR.name(PROTECTOR_FN).srcref(n);\n+        int type = n.getType();\n+\t\tNode name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 159, 
          "faulty": "Node name=IR.name(PROTECTOR_FN).srcref(n);", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1270/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:03:43.916357620 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1270/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:03:43.916357620 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_370/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:54:34.290061476 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -133,8 +127,6 @@\n       if (n.isString()) {\n         msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n-        msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n-            \"' operator is not being used.\";\n       }\n \n       t.getCompiler().report(\n@@ -163,7 +155,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 136, 
          "faulty": "msg=\"The result of the '\" + Token.name(n.getType()).toLowerCase() + \"' operator is not being used.\";", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_506/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:55:58.366401223 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -133,8 +127,6 @@\n       if (n.isString()) {\n         msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n-        msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n-            \"' operator is not being used.\";\n       }\n \n       t.getCompiler().report(\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_506/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:55:58.366401223 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 136, 
          "faulty": "msg=\"The result of the '\" + Token.name(n.getType()).toLowerCase() + \"' operator is not being used.\";", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1965/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:10:16.874702056 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,7 +155,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1965/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:10:16.878702080 -0500\n@@ -3121,22 +3121,23 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1965/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:10:16.878702080 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return toString(true,true,true);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_367/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:54:32.830055578 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -133,8 +127,6 @@\n       if (n.isString()) {\n         msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n-        msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n-            \"' operator is not being used.\";\n       }\n \n       t.getCompiler().report(\n@@ -163,7 +155,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "JSType type=n.getJSType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 136, 
          "faulty": "msg=\"The result of the '\" + Token.name(n.getType()).toLowerCase() + \"' operator is not being used.\";", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1036/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:01:10.939703037 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -131,7 +123,6 @@\n         (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n-        msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n         msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n             \"' operator is not being used.\";\n@@ -173,8 +164,6 @@\n     Node var = IR.var(name);\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n-    builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1036/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:01:10.943703055 -0500\n@@ -3121,19 +3121,7 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        ;\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 176, 
          "faulty": "builder.recordNoAlias();", 
          "type": "Delete", 
          "seed": "break;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 177, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Replace", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 134, 
          "faulty": "msg=\"Is there a missing '+' on the previous line?\";", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_448/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:55:23.222259184 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -156,7 +150,8 @@\n     if (!problemNodes.isEmpty()) {\n       addExtern();\n       for (Node n : problemNodes) {\n-        Node name = IR.name(PROTECTOR_FN).srcref(n);\n+        int type = n.getType();\n+\t\tNode name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n@@ -169,7 +164,6 @@\n \n   private void addExtern() {\n     Node name = IR.name(PROTECTOR_FN);\n-    name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n     Node var = IR.var(name);\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 159, 
          "faulty": "Node name=IR.name(PROTECTOR_FN).srcref(n);", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 172, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_671/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:57:39.010808135 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_956/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:00:23.839497432 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_956/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:00:23.843497448 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1811/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:08:50.858207457 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -174,7 +166,6 @@\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 177, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Delete", 
          "seed": "int type=n.getType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1010/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:00:53.907628960 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,7 +155,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1010/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:00:53.907628960 -0500\n@@ -3135,8 +3135,11 @@\n           }\n         }\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_2068/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:11:15.687020290 -0500\n@@ -112,15 +112,8 @@\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n     if (parent.getType() == Token.COMMA) {\n       if (isResultUsed) {\n-        return;\n-      }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+        int type = n.getType();\n+\t\treturn;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -157,8 +150,8 @@\n       addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n-        Node replacement = IR.call(name).srcref(n);\n+        int start = 0;\n+\t\tNode replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n@@ -174,7 +167,6 @@\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_2068/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:11:15.687020290 -0500\n@@ -3121,22 +3121,23 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tint start = 0;\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_2068/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:11:15.691020311 -0500\n@@ -184,7 +184,207 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              {\n+\t\t\t\tswitch (token) {\n+\t\t\t\tcase ERROR:\n+\t\t\t\t\treturn \"ERROR\";\n+\t\t\t\tcase RETURN:\n+\t\t\t\t\treturn \"RETURN\";\n+\t\t\t\tcase BITOR:\n+\t\t\t\t\treturn \"BITOR\";\n+\t\t\t\tcase BITXOR:\n+\t\t\t\t\treturn \"BITXOR\";\n+\t\t\t\tcase BITAND:\n+\t\t\t\t\treturn \"BITAND\";\n+\t\t\t\tcase EQ:\n+\t\t\t\t\treturn \"EQ\";\n+\t\t\t\tcase NE:\n+\t\t\t\t\treturn \"NE\";\n+\t\t\t\tcase LT:\n+\t\t\t\t\treturn \"LT\";\n+\t\t\t\tcase LE:\n+\t\t\t\t\treturn \"LE\";\n+\t\t\t\tcase GT:\n+\t\t\t\t\treturn \"GT\";\n+\t\t\t\tcase GE:\n+\t\t\t\t\treturn \"GE\";\n+\t\t\t\tcase LSH:\n+\t\t\t\t\treturn \"LSH\";\n+\t\t\t\tcase RSH:\n+\t\t\t\t\treturn \"RSH\";\n+\t\t\t\tcase URSH:\n+\t\t\t\t\treturn \"URSH\";\n+\t\t\t\tcase ADD:\n+\t\t\t\t\treturn \"ADD\";\n+\t\t\t\tcase SUB:\n+\t\t\t\t\treturn \"SUB\";\n+\t\t\t\tcase MUL:\n+\t\t\t\t\treturn \"MUL\";\n+\t\t\t\tcase DIV:\n+\t\t\t\t\treturn \"DIV\";\n+\t\t\t\tcase MOD:\n+\t\t\t\t\treturn \"MOD\";\n+\t\t\t\tcase NOT:\n+\t\t\t\t\treturn \"NOT\";\n+\t\t\t\tcase BITNOT:\n+\t\t\t\t\treturn \"BITNOT\";\n+\t\t\t\tcase POS:\n+\t\t\t\t\treturn \"POS\";\n+\t\t\t\tcase NEG:\n+\t\t\t\t\treturn \"NEG\";\n+\t\t\t\tcase NEW:\n+\t\t\t\t\treturn \"NEW\";\n+\t\t\t\tcase DELPROP:\n+\t\t\t\t\treturn \"DELPROP\";\n+\t\t\t\tcase TYPEOF:\n+\t\t\t\t\treturn \"TYPEOF\";\n+\t\t\t\tcase GETPROP:\n+\t\t\t\t\treturn \"GETPROP\";\n+\t\t\t\tcase GETELEM:\n+\t\t\t\t\treturn \"GETELEM\";\n+\t\t\t\tcase CALL:\n+\t\t\t\t\treturn \"CALL\";\n+\t\t\t\tcase NAME:\n+\t\t\t\t\treturn \"NAME\";\n+\t\t\t\tcase LABEL_NAME:\n+\t\t\t\t\treturn \"LABEL_NAME\";\n+\t\t\t\tcase NUMBER:\n+\t\t\t\t\treturn \"NUMBER\";\n+\t\t\t\tcase STRING:\n+\t\t\t\t\treturn \"STRING\";\n+\t\t\t\tcase STRING_KEY:\n+\t\t\t\t\treturn \"STRING_KEY\";\n+\t\t\t\tcase NULL:\n+\t\t\t\t\treturn \"NULL\";\n+\t\t\t\tcase THIS:\n+\t\t\t\t\treturn \"THIS\";\n+\t\t\t\tcase FALSE:\n+\t\t\t\t\treturn \"FALSE\";\n+\t\t\t\tcase TRUE:\n+\t\t\t\t\treturn \"TRUE\";\n+\t\t\t\tcase SHEQ:\n+\t\t\t\t\treturn \"SHEQ\";\n+\t\t\t\tcase SHNE:\n+\t\t\t\t\treturn \"SHNE\";\n+\t\t\t\tcase REGEXP:\n+\t\t\t\t\treturn \"REGEXP\";\n+\t\t\t\tcase THROW:\n+\t\t\t\t\treturn \"THROW\";\n+\t\t\t\tcase IN:\n+\t\t\t\t\treturn \"IN\";\n+\t\t\t\tcase INSTANCEOF:\n+\t\t\t\t\treturn \"INSTANCEOF\";\n+\t\t\t\tcase ARRAYLIT:\n+\t\t\t\t\treturn \"ARRAYLIT\";\n+\t\t\t\tcase OBJECTLIT:\n+\t\t\t\t\treturn \"OBJECTLIT\";\n+\t\t\t\tcase TRY:\n+\t\t\t\t\treturn \"TRY\";\n+\t\t\t\tcase PARAM_LIST:\n+\t\t\t\t\treturn \"PARAM_LIST\";\n+\t\t\t\tcase COMMA:\n+\t\t\t\t\treturn \"COMMA\";\n+\t\t\t\tcase ASSIGN:\n+\t\t\t\t\treturn \"ASSIGN\";\n+\t\t\t\tcase ASSIGN_BITOR:\n+\t\t\t\t\treturn \"ASSIGN_BITOR\";\n+\t\t\t\tcase ASSIGN_BITXOR:\n+\t\t\t\t\treturn \"ASSIGN_BITXOR\";\n+\t\t\t\tcase ASSIGN_BITAND:\n+\t\t\t\t\treturn \"ASSIGN_BITAND\";\n+\t\t\t\tcase ASSIGN_LSH:\n+\t\t\t\t\treturn \"ASSIGN_LSH\";\n+\t\t\t\tcase ASSIGN_RSH:\n+\t\t\t\t\treturn \"ASSIGN_RSH\";\n+\t\t\t\tcase ASSIGN_URSH:\n+\t\t\t\t\treturn \"ASSIGN_URSH\";\n+\t\t\t\tcase ASSIGN_ADD:\n+\t\t\t\t\treturn \"ASSIGN_ADD\";\n+\t\t\t\tcase ASSIGN_SUB:\n+\t\t\t\t\treturn \"ASSIGN_SUB\";\n+\t\t\t\tcase ASSIGN_MUL:\n+\t\t\t\t\treturn \"ASSIGN_MUL\";\n+\t\t\t\tcase ASSIGN_DIV:\n+\t\t\t\t\treturn \"ASSIGN_DIV\";\n+\t\t\t\tcase ASSIGN_MOD:\n+\t\t\t\t\treturn \"ASSIGN_MOD\";\n+\t\t\t\tcase HOOK:\n+\t\t\t\t\treturn \"HOOK\";\n+\t\t\t\tcase COLON:\n+\t\t\t\t\treturn \"COLON\";\n+\t\t\t\tcase OR:\n+\t\t\t\t\treturn \"OR\";\n+\t\t\t\tcase AND:\n+\t\t\t\t\treturn \"AND\";\n+\t\t\t\tcase INC:\n+\t\t\t\t\treturn \"INC\";\n+\t\t\t\tcase DEC:\n+\t\t\t\t\treturn \"DEC\";\n+\t\t\t\tcase FUNCTION:\n+\t\t\t\t\treturn \"FUNCTION\";\n+\t\t\t\tcase IF:\n+\t\t\t\t\treturn \"IF\";\n+\t\t\t\tcase SWITCH:\n+\t\t\t\t\treturn \"SWITCH\";\n+\t\t\t\tcase CASE:\n+\t\t\t\t\treturn \"CASE\";\n+\t\t\t\tcase DEFAULT_CASE:\n+\t\t\t\t\treturn \"DEFAULT_CASE\";\n+\t\t\t\tcase WHILE:\n+\t\t\t\t\treturn \"WHILE\";\n+\t\t\t\tcase DO:\n+\t\t\t\t\treturn \"DO\";\n+\t\t\t\tcase FOR:\n+\t\t\t\t\treturn \"FOR\";\n+\t\t\t\tcase BREAK:\n+\t\t\t\t\treturn \"BREAK\";\n+\t\t\t\tcase CONTINUE:\n+\t\t\t\t\treturn \"CONTINUE\";\n+\t\t\t\tcase VAR:\n+\t\t\t\t\treturn \"VAR\";\n+\t\t\t\tcase WITH:\n+\t\t\t\t\treturn \"WITH\";\n+\t\t\t\tcase CATCH:\n+\t\t\t\t\treturn \"CATCH\";\n+\t\t\t\tcase EMPTY:\n+\t\t\t\t\treturn \"EMPTY\";\n+\t\t\t\tcase BLOCK:\n+\t\t\t\t\treturn \"BLOCK\";\n+\t\t\t\tcase LABEL:\n+\t\t\t\t\treturn \"LABEL\";\n+\t\t\t\tcase EXPR_RESULT:\n+\t\t\t\t\treturn \"EXPR_RESULT\";\n+\t\t\t\tcase SCRIPT:\n+\t\t\t\t\treturn \"SCRIPT\";\n+\t\t\t\tcase GETTER_DEF:\n+\t\t\t\t\treturn \"GETTER_DEF\";\n+\t\t\t\tcase SETTER_DEF:\n+\t\t\t\t\treturn \"SETTER_DEF\";\n+\t\t\t\tcase CONST:\n+\t\t\t\t\treturn \"CONST\";\n+\t\t\t\tcase DEBUGGER:\n+\t\t\t\t\treturn \"DEBUGGER\";\n+\t\t\t\tcase ANNOTATION:\n+\t\t\t\t\treturn \"ANNOTATION\";\n+\t\t\t\tcase PIPE:\n+\t\t\t\t\treturn \"PIPE\";\n+\t\t\t\tcase STAR:\n+\t\t\t\t\treturn \"STAR\";\n+\t\t\t\tcase EOC:\n+\t\t\t\t\treturn \"EOC\";\n+\t\t\t\tcase QMARK:\n+\t\t\t\t\treturn \"QMARK\";\n+\t\t\t\tcase ELLIPSIS:\n+\t\t\t\t\treturn \"ELLIPSIS\";\n+\t\t\t\tcase BANG:\n+\t\t\t\t\treturn \"BANG\";\n+\t\t\t\tcase VOID:\n+\t\t\t\t\treturn \"VOID\";\n+\t\t\t\tcase EQUALS:\n+\t\t\t\t\treturn \"EQUALS\";\n+\t\t\t\t}\n+\t\t\t\treturn \"EQ\";\n+\t\t\t}\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 177, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 160, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 160, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "InsertBefore", 
          "seed": "break;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "InsertBefore", 
          "seed": "switch (token) {\ncase ERROR:\n  return \"ERROR\";\ncase RETURN:\nreturn \"RETURN\";\ncase BITOR:\nreturn \"BITOR\";\ncase BITXOR:\nreturn \"BITXOR\";\ncase BITAND:\nreturn \"BITAND\";\ncase EQ:\nreturn \"EQ\";\ncase NE:\nreturn \"NE\";\ncase LT:\nreturn \"LT\";\ncase LE:\nreturn \"LE\";\ncase GT:\nreturn \"GT\";\ncase GE:\nreturn \"GE\";\ncase LSH:\nreturn \"LSH\";\ncase RSH:\nreturn \"RSH\";\ncase URSH:\nreturn \"URSH\";\ncase ADD:\nreturn \"ADD\";\ncase SUB:\nreturn \"SUB\";\ncase MUL:\nreturn \"MUL\";\ncase DIV:\nreturn \"DIV\";\ncase MOD:\nreturn \"MOD\";\ncase NOT:\nreturn \"NOT\";\ncase BITNOT:\nreturn \"BITNOT\";\ncase POS:\nreturn \"POS\";\ncase NEG:\nreturn \"NEG\";\ncase NEW:\nreturn \"NEW\";\ncase DELPROP:\nreturn \"DELPROP\";\ncase TYPEOF:\nreturn \"TYPEOF\";\ncase GETPROP:\nreturn \"GETPROP\";\ncase GETELEM:\nreturn \"GETELEM\";\ncase CALL:\nreturn \"CALL\";\ncase NAME:\nreturn \"NAME\";\ncase LABEL_NAME:\nreturn \"LABEL_NAME\";\ncase NUMBER:\nreturn \"NUMBER\";\ncase STRING:\nreturn \"STRING\";\ncase STRING_KEY:\nreturn \"STRING_KEY\";\ncase NULL:\nreturn \"NULL\";\ncase THIS:\nreturn \"THIS\";\ncase FALSE:\nreturn \"FALSE\";\ncase TRUE:\nreturn \"TRUE\";\ncase SHEQ:\nreturn \"SHEQ\";\ncase SHNE:\nreturn \"SHNE\";\ncase REGEXP:\nreturn \"REGEXP\";\ncase THROW:\nreturn \"THROW\";\ncase IN:\nreturn \"IN\";\ncase INSTANCEOF:\nreturn \"INSTANCEOF\";\ncase ARRAYLIT:\nreturn \"ARRAYLIT\";\ncase OBJECTLIT:\nreturn \"OBJECTLIT\";\ncase TRY:\nreturn \"TRY\";\ncase PARAM_LIST:\nreturn \"PARAM_LIST\";\ncase COMMA:\nreturn \"COMMA\";\ncase ASSIGN:\nreturn \"ASSIGN\";\ncase ASSIGN_BITOR:\nreturn \"ASSIGN_BITOR\";\ncase ASSIGN_BITXOR:\nreturn \"ASSIGN_BITXOR\";\ncase ASSIGN_BITAND:\nreturn \"ASSIGN_BITAND\";\ncase ASSIGN_LSH:\nreturn \"ASSIGN_LSH\";\ncase ASSIGN_RSH:\nreturn \"ASSIGN_RSH\";\ncase ASSIGN_URSH:\nreturn \"ASSIGN_URSH\";\ncase ASSIGN_ADD:\nreturn \"ASSIGN_ADD\";\ncase ASSIGN_SUB:\nreturn \"ASSIGN_SUB\";\ncase ASSIGN_MUL:\nreturn \"ASSIGN_MUL\";\ncase ASSIGN_DIV:\nreturn \"ASSIGN_DIV\";\ncase ASSIGN_MOD:\nreturn \"ASSIGN_MOD\";\ncase HOOK:\nreturn \"HOOK\";\ncase COLON:\nreturn \"COLON\";\ncase OR:\nreturn \"OR\";\ncase AND:\nreturn \"AND\";\ncase INC:\nreturn \"INC\";\ncase DEC:\nreturn \"DEC\";\ncase FUNCTION:\nreturn \"FUNCTION\";\ncase IF:\nreturn \"IF\";\ncase SWITCH:\nreturn \"SWITCH\";\ncase CASE:\nreturn \"CASE\";\ncase DEFAULT_CASE:\nreturn \"DEFAULT_CASE\";\ncase WHILE:\nreturn \"WHILE\";\ncase DO:\nreturn \"DO\";\ncase FOR:\nreturn \"FOR\";\ncase BREAK:\nreturn \"BREAK\";\ncase CONTINUE:\nreturn \"CONTINUE\";\ncase VAR:\nreturn \"VAR\";\ncase WITH:\nreturn \"WITH\";\ncase CATCH:\nreturn \"CATCH\";\ncase EMPTY:\nreturn \"EMPTY\";\ncase BLOCK:\nreturn \"BLOCK\";\ncase LABEL:\nreturn \"LABEL\";\ncase EXPR_RESULT:\nreturn \"EXPR_RESULT\";\ncase SCRIPT:\nreturn \"SCRIPT\";\ncase GETTER_DEF:\nreturn \"GETTER_DEF\";\ncase SETTER_DEF:\nreturn \"SETTER_DEF\";\ncase CONST:\nreturn \"CONST\";\ncase DEBUGGER:\nreturn \"DEBUGGER\";\ncase ANNOTATION:\nreturn \"ANNOTATION\";\ncase PIPE:\nreturn \"PIPE\";\ncase STAR:\nreturn \"STAR\";\ncase EOC:\nreturn \"EOC\";\ncase QMARK:\nreturn \"QMARK\";\ncase ELLIPSIS:\nreturn \"ELLIPSIS\";\ncase BANG:\nreturn \"BANG\";\ncase VOID:\nreturn \"VOID\";\ncase EQUALS:\nreturn \"EQUALS\";\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1451/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:05:35.204908689 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1451/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:05:35.208908716 -0500\n@@ -3135,8 +3135,11 @@\n           }\n         }\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1105/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:01:54.615891746 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -163,7 +157,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1105/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:01:54.615891746 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_2075/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:11:19.815042128 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_2075/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:11:19.819042148 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_2075/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:11:19.819042148 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"SUB\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"SUB\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Delete", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_655/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:57:27.678762309 -0500\n@@ -114,13 +114,9 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+      StringBuilder builder = new StringBuilder();\n+\tif (n == parent.getLastChild()) {\n+        int start = 0;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -163,7 +159,8 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n+      int start = 0;\n+\tcompiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_655/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:57:27.682762327 -0500\n@@ -184,7 +184,10 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              {\n+\t\t\t\tNode block = new Node(Token.BLOCK);\n+\t\t\t\treturn \"EQ\";\n+\t\t\t}\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "Node paramList=paramList();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "InsertBefore", 
          "seed": "Node block=new Node(Token.BLOCK);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1598/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:06:53.301452074 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -157,13 +151,11 @@\n       addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n@@ -174,7 +166,6 @@\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1598/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:06:53.305452101 -0500\n@@ -3121,22 +3121,23 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1598/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:06:53.305452101 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 177, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "case PARAM_LIST:"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "InsertBefore", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 160, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "Delete", 
          "seed": "traverseNodes(n);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1754/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:08:21.166026648 -0500\n@@ -111,17 +111,10 @@\n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n     if (parent.getType() == Token.COMMA) {\n-      if (isResultUsed) {\n+      StringBuilder builder = new StringBuilder();\n+\tif (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,7 +156,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1754/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:08:21.166026648 -0500\n@@ -3121,22 +3121,23 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Delete", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (isResultUsed) {\n  return;\n}", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_786/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:58:47.923086850 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_786/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:58:47.923086850 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1735/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:08:07.645942296 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -157,8 +149,8 @@\n       addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n-        Node replacement = IR.call(name).srcref(n);\n+        int start = 0;\n+\t\tNode replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1735/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:08:07.649942322 -0500\n@@ -3121,22 +3121,23 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tint start = 0;\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 160, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 160, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "InsertBefore", 
          "seed": "break;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_971/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:00:31.919532875 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -163,7 +157,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_971/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:00:31.919532875 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1259/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:03:37.380329971 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -163,7 +157,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1259/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:03:37.380329971 -0500\n@@ -3121,22 +3121,23 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_11/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:50:35.876662335 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1305/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:04:08.444461175 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -163,7 +157,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1305/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:04:08.448461193 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1305/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:04:08.448461193 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "case PARAM_LIST:"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_839/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:59:16.567202719 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -154,7 +148,6 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_839/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:59:16.567202719 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 157, 
          "faulty": "addExtern();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1442/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:05:30.144873202 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,7 +155,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1442/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:05:30.144873202 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "case PARAM_LIST:"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1727/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:08:03.429915717 -0500\n@@ -115,12 +115,7 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+        int index = -1;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1727/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:08:03.433915743 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return toString(true,true,true);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Replace", 
          "seed": "formatPreamble();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_232/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:53:04.305698113 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_232/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:53:04.309698129 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Replace", 
          "seed": "formatConclusion();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1520/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:06:10.441148717 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1520/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:06:10.441148717 -0500\n@@ -3121,19 +3121,7 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        ;\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_524/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:56:09.386445768 -0500\n@@ -114,13 +114,8 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+      StringBuilder builder = new StringBuilder();\n+\tif (n == parent.getLastChild()) {\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -133,8 +128,6 @@\n       if (n.isString()) {\n         msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n-        msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n-            \"' operator is not being used.\";\n       }\n \n       t.getCompiler().report(\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_524/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:56:09.390445784 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "JSType type=n.getJSType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 136, 
          "faulty": "msg=\"The result of the '\" + Token.name(n.getType()).toLowerCase() + \"' operator is not being used.\";", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_774/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:58:40.511056869 -0500\n@@ -111,16 +111,11 @@\n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n     if (parent.getType() == Token.COMMA) {\n-      if (isResultUsed) {\n+      int start = 0;\n+\tif (isResultUsed) {\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -133,8 +128,6 @@\n       if (n.isString()) {\n         msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n-        msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n-            \"' operator is not being used.\";\n       }\n \n       t.getCompiler().report(\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_774/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:58:40.511056869 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 136, 
          "faulty": "msg=\"The result of the '\" + Token.name(n.getType()).toLowerCase() + \"' operator is not being used.\";", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (isResultUsed) {\n  return;\n}", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_996/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:00:45.575592613 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,7 +155,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_996/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:00:45.579592629 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return 0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1516/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:06:07.745130769 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -163,7 +157,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1516/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:06:07.745130769 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1618/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:07:03.125519686 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,7 +155,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1618/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:07:03.125519686 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1316/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:04:14.884488315 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1316/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:04:14.884488315 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_556/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:56:28.998525050 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -133,8 +127,6 @@\n       if (n.isString()) {\n         msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n-        msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n-            \"' operator is not being used.\";\n       }\n \n       t.getCompiler().report(\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_556/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:56:28.998525050 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 136, 
          "faulty": "msg=\"The result of the '\" + Token.name(n.getType()).toLowerCase() + \"' operator is not being used.\";", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_919/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:00:04.503412295 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_919/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:00:04.503412295 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_919/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:00:04.507412312 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1107/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:01:55.443895306 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1107/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:01:55.443895306 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1445/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:05:31.928885745 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,7 +155,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1445/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:05:31.932885772 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1399/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:05:04.248695724 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -133,8 +125,7 @@\n       if (n.isString()) {\n         msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n-        msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n-            \"' operator is not being used.\";\n+        int start = 0;\n       }\n \n       t.getCompiler().report(\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1399/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:05:04.252695742 -0500\n@@ -3135,8 +3135,11 @@\n           }\n         }\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 136, 
          "faulty": "msg=\"The result of the '\" + Token.name(n.getType()).toLowerCase() + \"' operator is not being used.\";", 
          "type": "Replace", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1363/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:04:42.392604023 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,7 +155,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n@@ -174,7 +165,6 @@\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1363/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:04:42.392604023 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1363/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:04:42.392604023 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 177, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "InsertBefore", 
          "seed": "formatPreamble();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1841/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:09:08.618312913 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,7 +155,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1841/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:09:08.622312937 -0500\n@@ -3121,22 +3121,23 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_310/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:53:53.809897975 -0500\n@@ -118,8 +118,7 @@\n         for (Node an : parent.getAncestors()) {\n           int ancestorType = an.getType();\n           if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n+          int type = n.getType();\n         }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1623/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:07:05.633536797 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1623/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:07:05.633536797 -0500\n@@ -3135,8 +3135,11 @@\n           }\n         }\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_2058/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:11:10.606993331 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_2058/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:11:10.606993331 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_2058/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:11:10.610993353 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"SUB\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return new Node(Token.PARAM_LIST);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_245/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:53:12.585731534 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -156,7 +150,8 @@\n     if (!problemNodes.isEmpty()) {\n       addExtern();\n       for (Node n : problemNodes) {\n-        Node name = IR.name(PROTECTOR_FN).srcref(n);\n+        int type = n.getType();\n+\t\tNode name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 159, 
          "faulty": "Node name=IR.name(PROTECTOR_FN).srcref(n);", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1823/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:08:57.382246419 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -157,13 +149,12 @@\n       addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n-        Node replacement = IR.call(name).srcref(n);\n+        int start = 0;\n+\t\tNode replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n@@ -174,7 +165,6 @@\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1823/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:08:57.382246419 -0500\n@@ -3121,22 +3121,23 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tint start = 0;\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1823/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:08:57.386246443 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return toString(true,true,true);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 177, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 160, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 160, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "InsertBefore", 
          "seed": "break;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1428/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:05:22.620819933 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -157,7 +149,8 @@\n       addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n+        int start = 0;\n+\t\tname.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1428/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:05:22.624819962 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1428/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:05:22.624819962 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 160, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1114/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:01:59.531912883 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,7 +155,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n@@ -173,7 +164,8 @@\n     Node var = IR.var(name);\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n-    builder.recordNoAlias();\n+    int index = -1;\n+\tbuilder.recordNoAlias();\n     var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1114/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:01:59.531912883 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 176, 
          "faulty": "builder.recordNoAlias();", 
          "type": "InsertBefore", 
          "seed": "int index=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1710/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:07:54.601859626 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1710/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:07:54.601859626 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1710/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:07:54.605859652 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return toString(true,true,true);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1055/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:01:22.283752218 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1055/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:01:22.287752234 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1055/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:01:22.287752234 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1420/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:05:17.652784424 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1420/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:05:17.656784454 -0500\n@@ -3121,22 +3121,23 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_902/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:59:52.527359328 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -163,7 +157,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_902/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:59:52.531359346 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1406/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:05:08.516718404 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,18 +155,17 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n   private void addExtern() {\n     Node name = IR.name(PROTECTOR_FN);\n     name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n-    Node var = IR.var(name);\n+    int start = 0;\n+\tNode var = IR.var(name);\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1406/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:05:08.516718404 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1406/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:05:08.520718434 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 177, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 173, 
          "faulty": "Node var=IR.var(name);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_452/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:55:24.934266102 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_452/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:55:24.934266102 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1883/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:09:30.746441734 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1883/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:09:30.750441758 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_412/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:55:00.126165857 -0500\n@@ -118,8 +118,7 @@\n         for (Node an : parent.getAncestors()) {\n           int ancestorType = an.getType();\n           if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n+          int type = n.getType();\n         }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n@@ -133,8 +132,6 @@\n       if (n.isString()) {\n         msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n-        msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n-            \"' operator is not being used.\";\n       }\n \n       t.getCompiler().report(\n@@ -163,7 +160,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 136, 
          "faulty": "msg=\"The result of the '\" + Token.name(n.getType()).toLowerCase() + \"' operator is not being used.\";", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1057/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:01:23.055755561 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1057/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:01:23.055755561 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1663/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:07:28.477689979 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -163,7 +157,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1663/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:07:28.481690006 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Delete", 
          "seed": "int type=n.getType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_285/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:53:38.333835483 -0500\n@@ -114,13 +114,8 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+      StringBuilder builder = new StringBuilder();\n+\tif (n == parent.getLastChild()) {\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "JSType type=n.getJSType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1674/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:07:34.233727847 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1485/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:05:52.729029564 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -174,7 +166,6 @@\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1485/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:05:52.729029564 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 177, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_32/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:50:50.844914403 -0500\n@@ -115,12 +115,7 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+        int start = 0;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "int type=n.getType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1480/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:05:50.209012371 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Delete", 
          "seed": "int type=n.getType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1272/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:03:44.736361086 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,7 +155,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1272/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:03:44.736361086 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1272/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:03:44.740361103 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_153/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:52:12.673489780 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "int type=n.getType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_940/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:00:15.759461910 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -163,7 +157,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_940/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:00:15.763461929 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_940/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:00:15.763461929 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1117/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:02:01.163919895 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,7 +155,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1117/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:02:01.167919912 -0500\n@@ -3135,8 +3135,11 @@\n           }\n         }\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1935/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:09:59.770606741 -0500\n@@ -115,12 +115,7 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+        int index = -1;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -157,7 +152,8 @@\n       addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n+        int start = 0;\n+\t\tname.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1935/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:09:59.774606765 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 160, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_845/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:59:19.715215453 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1678/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:07:36.649743656 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1678/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:07:36.649743656 -0500\n@@ -3135,8 +3135,11 @@\n           }\n         }\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Delete", 
          "seed": "int type=n.getType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_623/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:57:07.934682472 -0500\n@@ -114,13 +114,9 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+      StringBuilder builder = new StringBuilder();\n+\tif (n == parent.getLastChild()) {\n+        int start = 0;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -163,7 +159,8 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n+      int start = 0;\n+\tcompiler.reportCodeChange();\n     }\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1690/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:07:43.165786054 -0500\n@@ -115,12 +115,7 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+        int index = -1;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1690/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:07:43.165786054 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return toString(true,true,true);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_297/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:53:46.341867818 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1436/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:05:27.504854580 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -159,11 +151,11 @@\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n-        replacement.putBooleanProp(Node.FREE_CALL, true);\n+        int start = 0;\n+\t\treplacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 162, 
          "faulty": "replacement.putBooleanProp(Node.FREE_CALL,true);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1246/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:03:29.116294980 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1246/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:03:29.116294980 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1039/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:01:12.639710416 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,7 +155,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1039/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:01:12.639710416 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1039/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:01:12.643710432 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_252/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:53:16.657747972 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1030/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:01:07.603688550 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,7 +155,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n@@ -173,8 +164,6 @@\n     Node var = IR.var(name);\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n-    builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 176, 
          "faulty": "builder.recordNoAlias();", 
          "type": "Delete", 
          "seed": "break;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 177, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 176, 
          "faulty": "builder.recordNoAlias();", 
          "type": "Delete", 
          "seed": "break;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_639/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:57:18.766726273 -0500\n@@ -118,8 +118,9 @@\n         for (Node an : parent.getAncestors()) {\n           int ancestorType = an.getType();\n           if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n+          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n+\t\t\t;\n+\t\telse break;\n         }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_962/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:00:27.043511496 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,7 +155,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_962/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:00:27.043511496 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_962/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:00:27.047511512 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"ADD\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1339/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:04:29.308549030 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,7 +155,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n@@ -174,7 +165,6 @@\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1339/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:04:29.308549030 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1339/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:04:29.308549030 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 177, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_169/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:52:22.421529102 -0500\n@@ -115,12 +115,7 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+        int start = 0;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_2051/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:11:07.242975429 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -163,7 +157,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n@@ -173,8 +166,6 @@\n     Node var = IR.var(name);\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n-    builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_2051/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:11:07.242975429 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_2051/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:11:07.246975450 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 177, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return toString(true,true,true);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 176, 
          "faulty": "builder.recordNoAlias();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1832/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:09:03.090280293 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1832/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:09:03.094280317 -0500\n@@ -3135,8 +3135,11 @@\n           }\n         }\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1832/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:09:03.094280317 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"SUB\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"SUB\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Replace", 
          "seed": "return new DefaultCodingConvention();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_76/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:51:21.177231533 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -131,7 +125,7 @@\n         (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n-        msg = \"Is there a missing '+' on the previous line?\";\n+        StringBuilder builder = new StringBuilder();\n       } else if (isSimpleOp) {\n         msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n             \"' operator is not being used.\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 134, 
          "faulty": "msg=\"Is there a missing '+' on the previous line?\";", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_176/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:52:26.529545674 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_885/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:59:43.023317160 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -154,7 +148,6 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_885/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:59:43.027317178 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 157, 
          "faulty": "addExtern();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_746/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:58:23.810989322 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_746/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:58:23.810989322 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_647/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:57:22.830742706 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -154,7 +148,6 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 157, 
          "faulty": "addExtern();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_917/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:00:03.691408710 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -154,7 +148,6 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_917/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:00:03.691408710 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 157, 
          "faulty": "addExtern();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_784/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:58:47.095083501 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -156,14 +148,14 @@\n     if (!problemNodes.isEmpty()) {\n       addExtern();\n       for (Node n : problemNodes) {\n-        Node name = IR.name(PROTECTOR_FN).srcref(n);\n+        int type = n.getType();\n+\t\tNode name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_784/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:58:47.099083517 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 159, 
          "faulty": "Node name=IR.name(PROTECTOR_FN).srcref(n);", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_138/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:52:03.685453528 -0500\n@@ -118,8 +118,7 @@\n         for (Node an : parent.getAncestors()) {\n           int ancestorType = an.getType();\n           if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n+          final String PARAM_NAME = \"jscomp_throw_param\";\n         }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_951/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:00:21.407486747 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,7 +155,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n@@ -173,7 +164,6 @@\n     Node var = IR.var(name);\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n-    builder.recordNoAlias();\n     var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 176, 
          "faulty": "builder.recordNoAlias();", 
          "type": "Delete", 
          "seed": "break;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1565/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:06:33.809315041 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,7 +155,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1565/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:06:33.813315070 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1954/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:10:11.074669888 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -174,7 +168,6 @@\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1954/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:10:11.074669888 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 177, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Delete", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "InsertBefore", 
          "seed": "JSType type=n.getJSType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_889/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:59:45.343327465 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,7 +155,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_889/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:59:45.343327465 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "traverseNodes(n);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_471/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:55:35.442308569 -0500\n@@ -114,13 +114,9 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+      StringBuilder builder = new StringBuilder();\n+\tif (n == parent.getLastChild()) {\n+        int start = 0;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1503/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:06:01.693090235 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1503/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:06:01.697090261 -0500\n@@ -3121,19 +3121,7 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        ;\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1503/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:06:01.697090261 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1704/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:07:51.433839349 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,7 +155,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1704/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:07:51.433839349 -0500\n@@ -3121,22 +3121,23 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_537/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:56:17.306477784 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -156,7 +150,8 @@\n     if (!problemNodes.isEmpty()) {\n       addExtern();\n       for (Node n : problemNodes) {\n-        Node name = IR.name(PROTECTOR_FN).srcref(n);\n+        int type = n.getType();\n+\t\tNode name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 159, 
          "faulty": "Node name=IR.name(PROTECTOR_FN).srcref(n);", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_82/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:51:25.469264620 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -131,7 +125,7 @@\n         (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n-        msg = \"Is there a missing '+' on the previous line?\";\n+        StringBuilder builder = new StringBuilder();\n       } else if (isSimpleOp) {\n         msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n             \"' operator is not being used.\";\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_82/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:51:25.473264647 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 134, 
          "faulty": "msg=\"Is there a missing '+' on the previous line?\";", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1383/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:04:54.552655067 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1383/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:04:54.556655084 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1383/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:04:54.556655084 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1659/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:07:26.885679456 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,7 +155,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1659/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:07:26.885679456 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1334/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:04:25.804534289 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -163,7 +157,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1334/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:04:25.808534307 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1334/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:04:25.808534307 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "case PARAM_LIST:"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_167/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:52:21.609525826 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -156,7 +150,8 @@\n     if (!problemNodes.isEmpty()) {\n       addExtern();\n       for (Node n : problemNodes) {\n-        Node name = IR.name(PROTECTOR_FN).srcref(n);\n+        int type = n.getType();\n+\t\tNode name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 159, 
          "faulty": "Node name=IR.name(PROTECTOR_FN).srcref(n);", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1145/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:02:19.367997974 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -157,13 +149,11 @@\n       addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1145/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:02:19.367997974 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 160, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_518/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:56:05.546430246 -0500\n@@ -115,12 +115,7 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+        int start = 0;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -163,7 +158,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1351/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:04:35.864576595 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -163,7 +157,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1351/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:04:35.868576611 -0500\n@@ -3121,22 +3121,23 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1218/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:03:08.780208706 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,7 +155,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1218/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:03:08.780208706 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1423/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:05:19.364796692 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,7 +155,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1423/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:05:19.368796721 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1423/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:05:19.368796721 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1981/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:10:26.254753766 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1981/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:10:26.258753787 -0500\n@@ -3121,22 +3121,23 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Delete", 
          "seed": "int type=n.getType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_937/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:00:14.067454462 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -163,7 +157,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_937/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:00:14.071454481 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1401/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:05:05.052699094 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_266/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:53:26.365787163 -0500\n@@ -114,13 +114,8 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+      StringBuilder builder = new StringBuilder();\n+\tif (n == parent.getLastChild()) {\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "JSType type=n.getJSType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_921/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:00:05.279415721 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,7 +155,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n@@ -173,7 +164,6 @@\n     Node var = IR.var(name);\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n-    builder.recordNoAlias();\n     var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 176, 
          "faulty": "builder.recordNoAlias();", 
          "type": "Delete", 
          "seed": "break;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1323/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:04:19.112506122 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1323/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:04:19.112506122 -0500\n@@ -3135,8 +3135,11 @@\n           }\n         }\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_553/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:56:27.434518727 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -133,8 +127,6 @@\n       if (n.isString()) {\n         msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n-        msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n-            \"' operator is not being used.\";\n       }\n \n       t.getCompiler().report(\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_553/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:56:27.434518727 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 136, 
          "faulty": "msg=\"The result of the '\" + Token.name(n.getType()).toLowerCase() + \"' operator is not being used.\";", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Replace", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_620/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:57:06.266675728 -0500\n@@ -114,13 +114,9 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+      StringBuilder builder = new StringBuilder();\n+\tif (n == parent.getLastChild()) {\n+        int start = 0;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -163,7 +159,8 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n+      int start = 0;\n+\tcompiler.reportCodeChange();\n     }\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1654/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:07:23.521657146 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -157,13 +149,11 @@\n       addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1654/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:07:23.525657172 -0500\n@@ -3121,22 +3121,23 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1654/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:07:23.525657172 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "case PARAM_LIST:"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "InsertBefore", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 160, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "Delete", 
          "seed": "traverseNodes(n);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_843/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:59:18.923212249 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1776/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:08:32.658097327 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1776/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:08:32.658097327 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1372/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:04:48.840631097 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1372/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:04:48.840631097 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1440/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:05:29.356867651 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,7 +155,7 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n+      StringBuilder builder = new StringBuilder();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1440/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:05:29.360867679 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1687/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:07:41.605775935 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -174,7 +166,6 @@\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 177, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1649/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:07:21.085640928 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -133,7 +127,8 @@\n       if (n.isString()) {\n         msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n-        msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n+        int type = n.getType();\n+\t\tmsg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n             \"' operator is not being used.\";\n       }\n \n@@ -157,13 +152,11 @@\n       addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n@@ -174,7 +167,6 @@\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1649/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:07:21.085640928 -0500\n@@ -3121,22 +3121,23 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1649/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:07:21.085640928 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 177, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "case PARAM_LIST:"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "InsertBefore", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 160, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "Delete", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 136, 
          "faulty": "msg=\"The result of the '\" + Token.name(n.getType()).toLowerCase() + \"' operator is not being used.\";", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1819/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:08:54.862231401 -0500\n@@ -112,15 +112,8 @@\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n     if (parent.getType() == Token.COMMA) {\n       if (isResultUsed) {\n-        return;\n-      }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+        int type = n.getType();\n+\t\treturn;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -157,8 +150,8 @@\n       addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n-        Node replacement = IR.call(name).srcref(n);\n+        int start = 0;\n+\t\tNode replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1819/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:08:54.862231401 -0500\n@@ -3121,22 +3121,23 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tint start = 0;\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1819/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:08:54.866231425 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return toString(true,true,true);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 160, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 160, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "InsertBefore", 
          "seed": "break;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_510/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:56:00.806411085 -0500\n@@ -114,13 +114,9 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+      StringBuilder builder = new StringBuilder();\n+\tif (n == parent.getLastChild()) {\n+        int start = 0;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "JSType type=n.getJSType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1128/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:02:08.551951614 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,7 +155,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1128/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:02:08.551951614 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1128/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:02:08.555951631 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_497/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:55:53.610381999 -0500\n@@ -114,13 +114,9 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+      StringBuilder builder = new StringBuilder();\n+\tif (n == parent.getLastChild()) {\n+        int start = 0;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -131,7 +127,6 @@\n         (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n-        msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n         msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n             \"' operator is not being used.\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 134, 
          "faulty": "msg=\"Is there a missing '+' on the previous line?\";", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_926/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:00:07.651426186 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,7 +155,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_631/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:57:12.870702432 -0500\n@@ -114,12 +114,13 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n+      StringBuilder builder = new StringBuilder();\n+\tif (n == parent.getLastChild()) {\n+        int start = 0;\n+\t\tfor (Node an : parent.getAncestors()) {\n           int ancestorType = an.getType();\n           if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n+          final String PARAM_NAME = \"jscomp_throw_param\";\n         }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n@@ -163,7 +164,8 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n+      int start = 0;\n+\tcompiler.reportCodeChange();\n     }\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1227/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:03:15.532237378 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1542/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:06:22.929236795 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -163,7 +157,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n@@ -174,7 +167,6 @@\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1542/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:06:22.929236795 -0500\n@@ -3121,22 +3121,23 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1542/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:06:22.929236795 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 177, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "case PARAM_LIST:"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1233/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:03:20.124256862 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1233/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:03:20.128256879 -0500\n@@ -3135,8 +3135,11 @@\n           }\n         }\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_211/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:52:50.681643127 -0500\n@@ -114,13 +114,8 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+      StringBuilder builder = new StringBuilder();\n+\tif (n == parent.getLastChild()) {\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -131,7 +126,7 @@\n         (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n-        msg = \"Is there a missing '+' on the previous line?\";\n+        StringBuilder builder = new StringBuilder();\n       } else if (isSimpleOp) {\n         msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n             \"' operator is not being used.\";\n@@ -157,7 +152,6 @@\n       addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 134, 
          "faulty": "msg=\"Is there a missing '+' on the previous line?\";", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 160, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_721/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:58:07.946925159 -0500\n@@ -114,13 +114,9 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+      StringBuilder builder = new StringBuilder();\n+\tif (n == parent.getLastChild()) {\n+        int start = 0;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_721/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:58:07.950925175 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_527/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:56:11.022452381 -0500\n@@ -114,13 +114,9 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+      StringBuilder builder = new StringBuilder();\n+\tif (n == parent.getLastChild()) {\n+        int start = 0;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -131,7 +127,6 @@\n         (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n-        msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n         msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n             \"' operator is not being used.\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 134, 
          "faulty": "msg=\"Is there a missing '+' on the previous line?\";", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1911/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:09:45.698527273 -0500\n@@ -112,15 +112,8 @@\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n     if (parent.getType() == Token.COMMA) {\n       if (isResultUsed) {\n-        return;\n-      }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+        int type = n.getType();\n+\t\treturn;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -157,8 +150,8 @@\n       addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n-        Node replacement = IR.call(name).srcref(n);\n+        int start = 0;\n+\t\tNode replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n@@ -174,7 +167,6 @@\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1911/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:09:45.702527296 -0500\n@@ -3121,22 +3121,23 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tint start = 0;\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 177, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 160, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 160, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "InsertBefore", 
          "seed": "break;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1197/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:02:54.964149947 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1396/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:05:02.644689001 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -131,7 +123,6 @@\n         (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n-        msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n         msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n             \"' operator is not being used.\";\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1396/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:05:02.644689001 -0500\n@@ -3135,8 +3135,11 @@\n           }\n         }\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 134, 
          "faulty": "msg=\"Is there a missing '+' on the previous line?\";", 
          "type": "Delete", 
          "seed": "JSType type=n.getJSType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1496/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:05:58.313067449 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1496/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:05:58.313067449 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1496/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:05:58.317067475 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return toString(true,true,true);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_770/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:58:38.099047112 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -163,7 +157,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_770/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:58:38.103047130 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_562/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:56:32.950541027 -0500\n@@ -115,11 +115,11 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n+        int start = 0;\n+\t\tfor (Node an : parent.getAncestors()) {\n           int ancestorType = an.getType();\n           if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n+          final String PARAM_NAME = \"jscomp_throw_param\";\n         }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n@@ -131,7 +131,6 @@\n         (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n-        msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n         msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n             \"' operator is not being used.\";\n@@ -157,7 +156,6 @@\n       addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 134, 
          "faulty": "msg=\"Is there a missing '+' on the previous line?\";", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 160, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_422/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:55:06.530191732 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -133,8 +127,6 @@\n       if (n.isString()) {\n         msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n-        msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n-            \"' operator is not being used.\";\n       }\n \n       t.getCompiler().report(\n@@ -156,7 +148,8 @@\n     if (!problemNodes.isEmpty()) {\n       addExtern();\n       for (Node n : problemNodes) {\n-        Node name = IR.name(PROTECTOR_FN).srcref(n);\n+        int type = n.getType();\n+\t\tNode name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 136, 
          "faulty": "msg=\"The result of the '\" + Token.name(n.getType()).toLowerCase() + \"' operator is not being used.\";", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 159, 
          "faulty": "Node name=IR.name(PROTECTOR_FN).srcref(n);", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1774/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:08:31.838092314 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,7 +155,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1774/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:08:31.838092314 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1774/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:08:31.838092314 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return toString(true,true,true);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1748/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:08:17.906006430 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,7 +155,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1748/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:08:17.906006430 -0500\n@@ -3121,22 +3121,23 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1748/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:08:17.910006455 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return toString(true,true,true);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_565/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:56:34.582547624 -0500\n@@ -118,8 +118,7 @@\n         for (Node an : parent.getAncestors()) {\n           int ancestorType = an.getType();\n           if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n+          int type = n.getType();\n         }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n@@ -131,7 +130,6 @@\n         (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n-        msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n         msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n             \"' operator is not being used.\";\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_565/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:56:34.582547624 -0500\n@@ -184,7 +184,10 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              {\n+\t\t\t\tStringBuilder sb = new StringBuilder();\n+\t\t\t\treturn \"EQ\";\n+\t\t\t}\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 134, 
          "faulty": "msg=\"Is there a missing '+' on the previous line?\";", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "InsertBefore", 
          "seed": "StringBuilder sb=new StringBuilder();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_604/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:56:57.222639160 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_604/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:56:57.222639160 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1408/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:05:09.332724341 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,7 +155,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n@@ -174,7 +165,6 @@\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1408/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:05:09.336724369 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1408/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:05:09.336724369 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 177, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return toString(true,true,true);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_222/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:52:58.697675478 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_222/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:52:58.701675494 -0500\n@@ -3121,19 +3121,7 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        ;\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "break;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_935/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:00:13.247450852 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -163,7 +157,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_935/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:00:13.247450852 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_935/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:00:13.251450868 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_848/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:59:21.363222120 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,7 +155,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_848/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:59:21.367222136 -0500\n@@ -3135,8 +3135,11 @@\n           }\n         }\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_848/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:59:21.367222136 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1041/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:01:13.451713939 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1041/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:01:13.455713955 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1041/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:01:13.455713955 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_308/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:53:53.017894777 -0500\n@@ -114,13 +114,8 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+      StringBuilder builder = new StringBuilder();\n+\tif (n == parent.getLastChild()) {\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -133,8 +128,6 @@\n       if (n.isString()) {\n         msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n-        msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n-            \"' operator is not being used.\";\n       }\n \n       t.getCompiler().report(\n@@ -163,7 +156,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "JSType type=n.getJSType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 136, 
          "faulty": "msg=\"The result of the '\" + Token.name(n.getType()).toLowerCase() + \"' operator is not being used.\";", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_828/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:59:10.107176586 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -156,14 +150,14 @@\n     if (!problemNodes.isEmpty()) {\n       addExtern();\n       for (Node n : problemNodes) {\n-        Node name = IR.name(PROTECTOR_FN).srcref(n);\n+        int type = n.getType();\n+\t\tNode name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_828/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:59:10.111176602 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_828/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:59:10.111176602 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 159, 
          "faulty": "Node name=IR.name(PROTECTOR_FN).srcref(n);", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_998/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:00:46.351596001 -0500\n@@ -115,12 +115,7 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+        int start = 0;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -173,7 +168,6 @@\n     Node var = IR.var(name);\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n-    builder.recordNoAlias();\n     var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 176, 
          "faulty": "builder.recordNoAlias();", 
          "type": "Delete", 
          "seed": "break;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_40/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:50:56.448988249 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_416/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:55:02.466175311 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -154,9 +148,9 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n       for (Node n : problemNodes) {\n-        Node name = IR.name(PROTECTOR_FN).srcref(n);\n+        int type = n.getType();\n+\t\tNode name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 159, 
          "faulty": "Node name=IR.name(PROTECTOR_FN).srcref(n);", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 157, 
          "faulty": "addExtern();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1951/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:10:09.326660162 -0500\n@@ -115,12 +115,7 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+        int index = -1;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1951/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:10:09.326660162 -0500\n@@ -3135,8 +3135,11 @@\n           }\n         }\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Delete", 
          "seed": "int type=n.getType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_850/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:59:22.191225469 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_850/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:59:22.191225469 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_850/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:59:22.195225484 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1799/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:08:45.654176186 -0500\n@@ -115,12 +115,7 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+        int index = -1;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -163,14 +158,14 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n   private void addExtern() {\n     Node name = IR.name(PROTECTOR_FN);\n     name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n-    Node var = IR.var(name);\n+    int start = 0;\n+\tNode var = IR.var(name);\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1799/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:08:45.658176211 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1799/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:08:45.658176211 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return toString(true,true,true);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 173, 
          "faulty": "Node var=IR.var(name);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1843/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:09:09.458317854 -0500\n@@ -115,12 +115,7 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+        int index = -1;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1843/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:09:09.458317854 -0500\n@@ -3135,8 +3135,11 @@\n           }\n         }\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1843/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:09:09.462317878 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return toString(true,true,true);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Delete", 
          "seed": "int type=n.getType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_987/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:00:40.043568437 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -173,7 +165,6 @@\n     Node var = IR.var(name);\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n-    builder.recordNoAlias();\n     var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 176, 
          "faulty": "builder.recordNoAlias();", 
          "type": "Delete", 
          "seed": "break;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_825/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:59:08.503170098 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -163,7 +157,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_825/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:59:08.503170098 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1927/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:09:55.606583327 -0500\n@@ -112,15 +112,8 @@\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n     if (parent.getType() == Token.COMMA) {\n       if (isResultUsed) {\n-        return;\n-      }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+        int type = n.getType();\n+\t\treturn;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -157,7 +150,6 @@\n       addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1927/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:09:55.606583327 -0500\n@@ -3121,22 +3121,23 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tint start = 0;\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 160, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "InsertBefore", 
          "seed": "break;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_976/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:00:35.019546455 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_976/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:00:35.019546455 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_976/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:00:35.023546471 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_529/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:56:11.866455793 -0500\n@@ -114,13 +114,8 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+      StringBuilder builder = new StringBuilder();\n+\tif (n == parent.getLastChild()) {\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -163,7 +158,8 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n+      int start = 0;\n+\tcompiler.reportCodeChange();\n     }\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_878/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:59:39.087299661 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -163,7 +157,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_878/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:59:39.087299661 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_878/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:59:39.091299680 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int keyParent=key(parent);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_104/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:51:40.061358268 -0500\n@@ -115,12 +115,7 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+        int start = 0;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -131,7 +126,6 @@\n         (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n-        msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n         msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n             \"' operator is not being used.\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 134, 
          "faulty": "msg=\"Is there a missing '+' on the previous line?\";", 
          "type": "Delete", 
          "seed": "formatPreamble();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1103/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:01:53.787888184 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -157,7 +149,6 @@\n       addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1103/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:01:53.787888184 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1103/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:01:53.791888201 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 160, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1922/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:09:53.098569184 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1922/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:09:53.098569184 -0500\n@@ -3121,22 +3121,23 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "this.level=level;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_485/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:55:44.966347061 -0500\n@@ -114,13 +114,8 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+      StringBuilder builder = new StringBuilder();\n+\tif (n == parent.getLastChild()) {\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -133,8 +128,6 @@\n       if (n.isString()) {\n         msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n-        msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n-            \"' operator is not being used.\";\n       }\n \n       t.getCompiler().report(\n@@ -163,7 +156,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 136, 
          "faulty": "msg=\"The result of the '\" + Token.name(n.getType()).toLowerCase() + \"' operator is not being used.\";", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_479/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:55:41.010331073 -0500\n@@ -114,13 +114,8 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+      StringBuilder builder = new StringBuilder();\n+\tif (n == parent.getLastChild()) {\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_479/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:55:41.014331089 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "JSType type=n.getJSType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1124/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:02:06.059940920 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1124/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:02:06.059940920 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1124/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:02:06.063940937 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1613/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:06:59.933497821 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1613/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:06:59.933497821 -0500\n@@ -3121,22 +3121,13 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        ;\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_859/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:59:27.223246780 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_859/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:59:27.227246798 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_114/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:51:46.557384459 -0500\n@@ -114,12 +114,12 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n+      StringBuilder builder = new StringBuilder();\n+\tif (n == parent.getLastChild()) {\n         for (Node an : parent.getAncestors()) {\n           int ancestorType = an.getType();\n           if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n+          final String PARAM_NAME = \"jscomp_throw_param\";\n         }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n@@ -157,7 +157,6 @@\n       addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 160, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_799/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:58:54.387112997 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -133,8 +125,6 @@\n       if (n.isString()) {\n         msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n-        msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n-            \"' operator is not being used.\";\n       }\n \n       t.getCompiler().report(\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "InsertBefore", 
          "seed": "JSType type=n.getJSType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 136, 
          "faulty": "msg=\"The result of the '\" + Token.name(n.getType()).toLowerCase() + \"' operator is not being used.\";", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_766/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:58:35.607037034 -0500\n@@ -114,13 +114,9 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+      StringBuilder builder = new StringBuilder();\n+\tif (n == parent.getLastChild()) {\n+        int start = 0;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -133,8 +129,6 @@\n       if (n.isString()) {\n         msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n-        msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n-            \"' operator is not being used.\";\n       }\n \n       t.getCompiler().report(\n@@ -156,7 +150,8 @@\n     if (!problemNodes.isEmpty()) {\n       addExtern();\n       for (Node n : problemNodes) {\n-        Node name = IR.name(PROTECTOR_FN).srcref(n);\n+        int type = n.getType();\n+\t\tNode name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_766/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:58:35.607037034 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 159, 
          "faulty": "Node name=IR.name(PROTECTOR_FN).srcref(n);", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 136, 
          "faulty": "msg=\"The result of the '\" + Token.name(n.getType()).toLowerCase() + \"' operator is not being used.\";", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int type=n.getType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1529/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:06:15.561183055 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1529/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:06:15.561183055 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1529/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:06:15.561183055 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return toString(true,true,true);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_268/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:53:27.157790360 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -156,7 +150,8 @@\n     if (!problemNodes.isEmpty()) {\n       addExtern();\n       for (Node n : problemNodes) {\n-        Node name = IR.name(PROTECTOR_FN).srcref(n);\n+        int type = n.getType();\n+\t\tNode name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 159, 
          "faulty": "Node name=IR.name(PROTECTOR_FN).srcref(n);", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "JSType type=n.getJSType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_454/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:55:25.762269449 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -163,7 +157,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_466/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:55:33.090299063 -0500\n@@ -114,13 +114,9 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+      StringBuilder builder = new StringBuilder();\n+\tif (n == parent.getLastChild()) {\n+        int start = 0;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -163,7 +159,8 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n+      int start = 0;\n+\tcompiler.reportCodeChange();\n     }\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_188/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:52:35.469581744 -0500\n@@ -114,13 +114,8 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+      StringBuilder builder = new StringBuilder();\n+\tif (n == parent.getLastChild()) {\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -157,7 +152,6 @@\n       addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_188/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:52:35.473581760 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 160, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1482/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:05:51.037018028 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,7 +155,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1482/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:05:51.041018054 -0500\n@@ -3121,22 +3121,23 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_2034/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:10:56.430917600 -0500\n@@ -115,12 +115,7 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+        int index = -1;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_2034/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:10:56.434917622 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_2034/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:10:56.434917622 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"SUB\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"SUB\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1377/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:04:51.320641506 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -174,7 +166,6 @@\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1377/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:04:51.320641506 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1377/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:04:51.324641524 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 177, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1989/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:10:31.538782727 -0500\n@@ -112,15 +112,8 @@\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n     if (parent.getType() == Token.COMMA) {\n       if (isResultUsed) {\n-        return;\n-      }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+        int type = n.getType();\n+\t\treturn;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -157,8 +150,8 @@\n       addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n-        Node replacement = IR.call(name).srcref(n);\n+        int start = 0;\n+\t\tNode replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1989/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:10:31.542782748 -0500\n@@ -3121,22 +3121,23 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tint start = 0;\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1989/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:10:31.542782748 -0500\n@@ -184,7 +184,207 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              {\n+\t\t\t\tswitch (token) {\n+\t\t\t\tcase ERROR:\n+\t\t\t\t\treturn \"ERROR\";\n+\t\t\t\tcase RETURN:\n+\t\t\t\t\treturn \"RETURN\";\n+\t\t\t\tcase BITOR:\n+\t\t\t\t\treturn \"BITOR\";\n+\t\t\t\tcase BITXOR:\n+\t\t\t\t\treturn \"BITXOR\";\n+\t\t\t\tcase BITAND:\n+\t\t\t\t\treturn \"BITAND\";\n+\t\t\t\tcase EQ:\n+\t\t\t\t\treturn \"EQ\";\n+\t\t\t\tcase NE:\n+\t\t\t\t\treturn \"NE\";\n+\t\t\t\tcase LT:\n+\t\t\t\t\treturn \"LT\";\n+\t\t\t\tcase LE:\n+\t\t\t\t\treturn \"LE\";\n+\t\t\t\tcase GT:\n+\t\t\t\t\treturn \"GT\";\n+\t\t\t\tcase GE:\n+\t\t\t\t\treturn \"GE\";\n+\t\t\t\tcase LSH:\n+\t\t\t\t\treturn \"LSH\";\n+\t\t\t\tcase RSH:\n+\t\t\t\t\treturn \"RSH\";\n+\t\t\t\tcase URSH:\n+\t\t\t\t\treturn \"URSH\";\n+\t\t\t\tcase ADD:\n+\t\t\t\t\treturn \"ADD\";\n+\t\t\t\tcase SUB:\n+\t\t\t\t\treturn \"SUB\";\n+\t\t\t\tcase MUL:\n+\t\t\t\t\treturn \"MUL\";\n+\t\t\t\tcase DIV:\n+\t\t\t\t\treturn \"DIV\";\n+\t\t\t\tcase MOD:\n+\t\t\t\t\treturn \"MOD\";\n+\t\t\t\tcase NOT:\n+\t\t\t\t\treturn \"NOT\";\n+\t\t\t\tcase BITNOT:\n+\t\t\t\t\treturn \"BITNOT\";\n+\t\t\t\tcase POS:\n+\t\t\t\t\treturn \"POS\";\n+\t\t\t\tcase NEG:\n+\t\t\t\t\treturn \"NEG\";\n+\t\t\t\tcase NEW:\n+\t\t\t\t\treturn \"NEW\";\n+\t\t\t\tcase DELPROP:\n+\t\t\t\t\treturn \"DELPROP\";\n+\t\t\t\tcase TYPEOF:\n+\t\t\t\t\treturn \"TYPEOF\";\n+\t\t\t\tcase GETPROP:\n+\t\t\t\t\treturn \"GETPROP\";\n+\t\t\t\tcase GETELEM:\n+\t\t\t\t\treturn \"GETELEM\";\n+\t\t\t\tcase CALL:\n+\t\t\t\t\treturn \"CALL\";\n+\t\t\t\tcase NAME:\n+\t\t\t\t\treturn \"NAME\";\n+\t\t\t\tcase LABEL_NAME:\n+\t\t\t\t\treturn \"LABEL_NAME\";\n+\t\t\t\tcase NUMBER:\n+\t\t\t\t\treturn \"NUMBER\";\n+\t\t\t\tcase STRING:\n+\t\t\t\t\treturn \"STRING\";\n+\t\t\t\tcase STRING_KEY:\n+\t\t\t\t\treturn \"STRING_KEY\";\n+\t\t\t\tcase NULL:\n+\t\t\t\t\treturn \"NULL\";\n+\t\t\t\tcase THIS:\n+\t\t\t\t\treturn \"THIS\";\n+\t\t\t\tcase FALSE:\n+\t\t\t\t\treturn \"FALSE\";\n+\t\t\t\tcase TRUE:\n+\t\t\t\t\treturn \"TRUE\";\n+\t\t\t\tcase SHEQ:\n+\t\t\t\t\treturn \"SHEQ\";\n+\t\t\t\tcase SHNE:\n+\t\t\t\t\treturn \"SHNE\";\n+\t\t\t\tcase REGEXP:\n+\t\t\t\t\treturn \"REGEXP\";\n+\t\t\t\tcase THROW:\n+\t\t\t\t\treturn \"THROW\";\n+\t\t\t\tcase IN:\n+\t\t\t\t\treturn \"IN\";\n+\t\t\t\tcase INSTANCEOF:\n+\t\t\t\t\treturn \"INSTANCEOF\";\n+\t\t\t\tcase ARRAYLIT:\n+\t\t\t\t\treturn \"ARRAYLIT\";\n+\t\t\t\tcase OBJECTLIT:\n+\t\t\t\t\treturn \"OBJECTLIT\";\n+\t\t\t\tcase TRY:\n+\t\t\t\t\treturn \"TRY\";\n+\t\t\t\tcase PARAM_LIST:\n+\t\t\t\t\treturn \"PARAM_LIST\";\n+\t\t\t\tcase COMMA:\n+\t\t\t\t\treturn \"COMMA\";\n+\t\t\t\tcase ASSIGN:\n+\t\t\t\t\treturn \"ASSIGN\";\n+\t\t\t\tcase ASSIGN_BITOR:\n+\t\t\t\t\treturn \"ASSIGN_BITOR\";\n+\t\t\t\tcase ASSIGN_BITXOR:\n+\t\t\t\t\treturn \"ASSIGN_BITXOR\";\n+\t\t\t\tcase ASSIGN_BITAND:\n+\t\t\t\t\treturn \"ASSIGN_BITAND\";\n+\t\t\t\tcase ASSIGN_LSH:\n+\t\t\t\t\treturn \"ASSIGN_LSH\";\n+\t\t\t\tcase ASSIGN_RSH:\n+\t\t\t\t\treturn \"ASSIGN_RSH\";\n+\t\t\t\tcase ASSIGN_URSH:\n+\t\t\t\t\treturn \"ASSIGN_URSH\";\n+\t\t\t\tcase ASSIGN_ADD:\n+\t\t\t\t\treturn \"ASSIGN_ADD\";\n+\t\t\t\tcase ASSIGN_SUB:\n+\t\t\t\t\treturn \"ASSIGN_SUB\";\n+\t\t\t\tcase ASSIGN_MUL:\n+\t\t\t\t\treturn \"ASSIGN_MUL\";\n+\t\t\t\tcase ASSIGN_DIV:\n+\t\t\t\t\treturn \"ASSIGN_DIV\";\n+\t\t\t\tcase ASSIGN_MOD:\n+\t\t\t\t\treturn \"ASSIGN_MOD\";\n+\t\t\t\tcase HOOK:\n+\t\t\t\t\treturn \"HOOK\";\n+\t\t\t\tcase COLON:\n+\t\t\t\t\treturn \"COLON\";\n+\t\t\t\tcase OR:\n+\t\t\t\t\treturn \"OR\";\n+\t\t\t\tcase AND:\n+\t\t\t\t\treturn \"AND\";\n+\t\t\t\tcase INC:\n+\t\t\t\t\treturn \"INC\";\n+\t\t\t\tcase DEC:\n+\t\t\t\t\treturn \"DEC\";\n+\t\t\t\tcase FUNCTION:\n+\t\t\t\t\treturn \"FUNCTION\";\n+\t\t\t\tcase IF:\n+\t\t\t\t\treturn \"IF\";\n+\t\t\t\tcase SWITCH:\n+\t\t\t\t\treturn \"SWITCH\";\n+\t\t\t\tcase CASE:\n+\t\t\t\t\treturn \"CASE\";\n+\t\t\t\tcase DEFAULT_CASE:\n+\t\t\t\t\treturn \"DEFAULT_CASE\";\n+\t\t\t\tcase WHILE:\n+\t\t\t\t\treturn \"WHILE\";\n+\t\t\t\tcase DO:\n+\t\t\t\t\treturn \"DO\";\n+\t\t\t\tcase FOR:\n+\t\t\t\t\treturn \"FOR\";\n+\t\t\t\tcase BREAK:\n+\t\t\t\t\treturn \"BREAK\";\n+\t\t\t\tcase CONTINUE:\n+\t\t\t\t\treturn \"CONTINUE\";\n+\t\t\t\tcase VAR:\n+\t\t\t\t\treturn \"VAR\";\n+\t\t\t\tcase WITH:\n+\t\t\t\t\treturn \"WITH\";\n+\t\t\t\tcase CATCH:\n+\t\t\t\t\treturn \"CATCH\";\n+\t\t\t\tcase EMPTY:\n+\t\t\t\t\treturn \"EMPTY\";\n+\t\t\t\tcase BLOCK:\n+\t\t\t\t\treturn \"BLOCK\";\n+\t\t\t\tcase LABEL:\n+\t\t\t\t\treturn \"LABEL\";\n+\t\t\t\tcase EXPR_RESULT:\n+\t\t\t\t\treturn \"EXPR_RESULT\";\n+\t\t\t\tcase SCRIPT:\n+\t\t\t\t\treturn \"SCRIPT\";\n+\t\t\t\tcase GETTER_DEF:\n+\t\t\t\t\treturn \"GETTER_DEF\";\n+\t\t\t\tcase SETTER_DEF:\n+\t\t\t\t\treturn \"SETTER_DEF\";\n+\t\t\t\tcase CONST:\n+\t\t\t\t\treturn \"CONST\";\n+\t\t\t\tcase DEBUGGER:\n+\t\t\t\t\treturn \"DEBUGGER\";\n+\t\t\t\tcase ANNOTATION:\n+\t\t\t\t\treturn \"ANNOTATION\";\n+\t\t\t\tcase PIPE:\n+\t\t\t\t\treturn \"PIPE\";\n+\t\t\t\tcase STAR:\n+\t\t\t\t\treturn \"STAR\";\n+\t\t\t\tcase EOC:\n+\t\t\t\t\treturn \"EOC\";\n+\t\t\t\tcase QMARK:\n+\t\t\t\t\treturn \"QMARK\";\n+\t\t\t\tcase ELLIPSIS:\n+\t\t\t\t\treturn \"ELLIPSIS\";\n+\t\t\t\tcase BANG:\n+\t\t\t\t\treturn \"BANG\";\n+\t\t\t\tcase VOID:\n+\t\t\t\t\treturn \"VOID\";\n+\t\t\t\tcase EQUALS:\n+\t\t\t\t\treturn \"EQUALS\";\n+\t\t\t\t}\n+\t\t\t\treturn \"EQ\";\n+\t\t\t}\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 160, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 160, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "InsertBefore", 
          "seed": "break;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "InsertBefore", 
          "seed": "switch (token) {\ncase ERROR:\n  return \"ERROR\";\ncase RETURN:\nreturn \"RETURN\";\ncase BITOR:\nreturn \"BITOR\";\ncase BITXOR:\nreturn \"BITXOR\";\ncase BITAND:\nreturn \"BITAND\";\ncase EQ:\nreturn \"EQ\";\ncase NE:\nreturn \"NE\";\ncase LT:\nreturn \"LT\";\ncase LE:\nreturn \"LE\";\ncase GT:\nreturn \"GT\";\ncase GE:\nreturn \"GE\";\ncase LSH:\nreturn \"LSH\";\ncase RSH:\nreturn \"RSH\";\ncase URSH:\nreturn \"URSH\";\ncase ADD:\nreturn \"ADD\";\ncase SUB:\nreturn \"SUB\";\ncase MUL:\nreturn \"MUL\";\ncase DIV:\nreturn \"DIV\";\ncase MOD:\nreturn \"MOD\";\ncase NOT:\nreturn \"NOT\";\ncase BITNOT:\nreturn \"BITNOT\";\ncase POS:\nreturn \"POS\";\ncase NEG:\nreturn \"NEG\";\ncase NEW:\nreturn \"NEW\";\ncase DELPROP:\nreturn \"DELPROP\";\ncase TYPEOF:\nreturn \"TYPEOF\";\ncase GETPROP:\nreturn \"GETPROP\";\ncase GETELEM:\nreturn \"GETELEM\";\ncase CALL:\nreturn \"CALL\";\ncase NAME:\nreturn \"NAME\";\ncase LABEL_NAME:\nreturn \"LABEL_NAME\";\ncase NUMBER:\nreturn \"NUMBER\";\ncase STRING:\nreturn \"STRING\";\ncase STRING_KEY:\nreturn \"STRING_KEY\";\ncase NULL:\nreturn \"NULL\";\ncase THIS:\nreturn \"THIS\";\ncase FALSE:\nreturn \"FALSE\";\ncase TRUE:\nreturn \"TRUE\";\ncase SHEQ:\nreturn \"SHEQ\";\ncase SHNE:\nreturn \"SHNE\";\ncase REGEXP:\nreturn \"REGEXP\";\ncase THROW:\nreturn \"THROW\";\ncase IN:\nreturn \"IN\";\ncase INSTANCEOF:\nreturn \"INSTANCEOF\";\ncase ARRAYLIT:\nreturn \"ARRAYLIT\";\ncase OBJECTLIT:\nreturn \"OBJECTLIT\";\ncase TRY:\nreturn \"TRY\";\ncase PARAM_LIST:\nreturn \"PARAM_LIST\";\ncase COMMA:\nreturn \"COMMA\";\ncase ASSIGN:\nreturn \"ASSIGN\";\ncase ASSIGN_BITOR:\nreturn \"ASSIGN_BITOR\";\ncase ASSIGN_BITXOR:\nreturn \"ASSIGN_BITXOR\";\ncase ASSIGN_BITAND:\nreturn \"ASSIGN_BITAND\";\ncase ASSIGN_LSH:\nreturn \"ASSIGN_LSH\";\ncase ASSIGN_RSH:\nreturn \"ASSIGN_RSH\";\ncase ASSIGN_URSH:\nreturn \"ASSIGN_URSH\";\ncase ASSIGN_ADD:\nreturn \"ASSIGN_ADD\";\ncase ASSIGN_SUB:\nreturn \"ASSIGN_SUB\";\ncase ASSIGN_MUL:\nreturn \"ASSIGN_MUL\";\ncase ASSIGN_DIV:\nreturn \"ASSIGN_DIV\";\ncase ASSIGN_MOD:\nreturn \"ASSIGN_MOD\";\ncase HOOK:\nreturn \"HOOK\";\ncase COLON:\nreturn \"COLON\";\ncase OR:\nreturn \"OR\";\ncase AND:\nreturn \"AND\";\ncase INC:\nreturn \"INC\";\ncase DEC:\nreturn \"DEC\";\ncase FUNCTION:\nreturn \"FUNCTION\";\ncase IF:\nreturn \"IF\";\ncase SWITCH:\nreturn \"SWITCH\";\ncase CASE:\nreturn \"CASE\";\ncase DEFAULT_CASE:\nreturn \"DEFAULT_CASE\";\ncase WHILE:\nreturn \"WHILE\";\ncase DO:\nreturn \"DO\";\ncase FOR:\nreturn \"FOR\";\ncase BREAK:\nreturn \"BREAK\";\ncase CONTINUE:\nreturn \"CONTINUE\";\ncase VAR:\nreturn \"VAR\";\ncase WITH:\nreturn \"WITH\";\ncase CATCH:\nreturn \"CATCH\";\ncase EMPTY:\nreturn \"EMPTY\";\ncase BLOCK:\nreturn \"BLOCK\";\ncase LABEL:\nreturn \"LABEL\";\ncase EXPR_RESULT:\nreturn \"EXPR_RESULT\";\ncase SCRIPT:\nreturn \"SCRIPT\";\ncase GETTER_DEF:\nreturn \"GETTER_DEF\";\ncase SETTER_DEF:\nreturn \"SETTER_DEF\";\ncase CONST:\nreturn \"CONST\";\ncase DEBUGGER:\nreturn \"DEBUGGER\";\ncase ANNOTATION:\nreturn \"ANNOTATION\";\ncase PIPE:\nreturn \"PIPE\";\ncase STAR:\nreturn \"STAR\";\ncase EOC:\nreturn \"EOC\";\ncase QMARK:\nreturn \"QMARK\";\ncase ELLIPSIS:\nreturn \"ELLIPSIS\";\ncase BANG:\nreturn \"BANG\";\ncase VOID:\nreturn \"VOID\";\ncase EQUALS:\nreturn \"EQUALS\";\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_542/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:56:20.398490283 -0500\n@@ -114,13 +114,9 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+      StringBuilder builder = new StringBuilder();\n+\tif (n == parent.getLastChild()) {\n+        int start = 0;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_795/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:58:52.751106378 -0500\n@@ -114,13 +114,9 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+      StringBuilder builder = new StringBuilder();\n+\tif (n == parent.getLastChild()) {\n+        int start = 0;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_394/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:54:48.558119118 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -156,7 +150,8 @@\n     if (!problemNodes.isEmpty()) {\n       addExtern();\n       for (Node n : problemNodes) {\n-        Node name = IR.name(PROTECTOR_FN).srcref(n);\n+        int type = n.getType();\n+\t\tNode name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 159, 
          "faulty": "Node name=IR.name(PROTECTOR_FN).srcref(n);", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1924/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:09:53.902573723 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1924/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:09:53.902573723 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Delete", 
          "seed": "int type=n.getType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_319/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:54:00.069923256 -0500\n@@ -114,13 +114,8 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+      StringBuilder builder = new StringBuilder();\n+\tif (n == parent.getLastChild()) {\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -133,8 +128,6 @@\n       if (n.isString()) {\n         msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n-        msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n-            \"' operator is not being used.\";\n       }\n \n       t.getCompiler().report(\n@@ -163,7 +156,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "JSType type=n.getJSType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 136, 
          "faulty": "msg=\"The result of the '\" + Token.name(n.getType()).toLowerCase() + \"' operator is not being used.\";", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_275/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:53:32.017809982 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1786/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:08:37.610127506 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -157,8 +149,8 @@\n       addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n-        Node replacement = IR.call(name).srcref(n);\n+        int start = 0;\n+\t\tNode replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n@@ -174,7 +166,6 @@\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1786/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:08:37.610127506 -0500\n@@ -3121,22 +3121,23 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tint start = 0;\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 177, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 160, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 160, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "InsertBefore", 
          "seed": "break;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_192/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:52:37.825591250 -0500\n@@ -114,13 +114,8 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+      StringBuilder builder = new StringBuilder();\n+\tif (n == parent.getLastChild()) {\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -157,7 +152,6 @@\n       addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 160, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "JSType type=n.getJSType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1600/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:06:54.125457781 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -174,7 +166,6 @@\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1600/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:06:54.129457810 -0500\n@@ -3135,8 +3135,11 @@\n           }\n         }\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1600/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:06:54.129457810 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "case PARAM_LIST:"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 177, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1087/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:01:43.243842774 -0500\n@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1149/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:02:21.940008985 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,7 +155,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1149/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:02:21.940008985 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1149/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:02:21.944009002 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1509/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:06:04.361108146 -0500\n@@ -115,12 +115,7 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+        int index = -1;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n@@ -163,7 +158,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n@@ -174,7 +168,6 @@\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1509/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:06:04.361108146 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 177, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return toString(true,true,true);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_398/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:54:50.998128976 -0500\n@@ -114,13 +114,8 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+      StringBuilder builder = new StringBuilder();\n+\tif (n == parent.getLastChild()) {\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "JSType type=n.getJSType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Replace", 
          "seed": "JSType type=n.getJSType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1492/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:05:56.009051854 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n@@ -163,7 +155,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1492/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:05:56.013051882 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:44.461983758 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1492/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:05:56.013051882 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "case PARAM_LIST:"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1779/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:08:34.358107706 -0500\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:46.397015709 -0500\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_1779/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:08:34.358107706 -0500\n@@ -3121,22 +3121,23 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n-        return (expr == parent.getFirstChild())\n-            ? false : isExpressionResultUsed(parent);\n+        {\n+\t\t\tint start = 0;\n+\t\t\treturn (expr == parent.getFirstChild()) ? false\n+\t\t\t\t\t: isExpressionResultUsed(parent);\n+\t\t}\n       case Token.FOR:\n         if (!NodeUtil.isForIn(parent)) {\n           // Only an expression whose result is in the condition part of the\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 118, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 120, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3138, 
          "faulty": "return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 119, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 121, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Delete", 
          "seed": "int type=n.getType();"
        }
      ]
    }
  ]
}