{
  "repair_end": "2018-12-02 14:10:25.523565", 
  "repair_begin": "2018-12-02 13:44:55.079935", 
  "patches": [
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_519/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:56:21.685541387 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "return new DefaultCodingConvention();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1810/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:08:41.580686370 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -180,7 +168,6 @@\n     Node var = IR.var(name);\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n-    builder.recordNoAlias();\n     var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1810/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:08:41.584686360 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 183, 
          "faulty": "builder.recordNoAlias();", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1395/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:04:47.250011996 -0500\n@@ -100,25 +100,7 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+      StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -181,7 +163,6 @@\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 184, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Delete", 
          "seed": "return isExported(name,false) || isExported(name,true);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1791/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:08:30.072719012 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -161,7 +147,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1791/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:08:30.076719000 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1402/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:04:50.393981970 -0500\n@@ -100,25 +100,7 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+      StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1402/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:04:50.393981970 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Replace", 
          "seed": "formatPreamble();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1602/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:06:41.257168044 -0500\n@@ -100,25 +100,7 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+      StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -161,7 +143,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1602/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:06:41.257168044 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SUB\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1080/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:01:43.275806646 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_619/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:57:16.792936135 -0500\n@@ -105,27 +105,8 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+    } else\n+\t\t;\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n@@ -164,7 +145,6 @@\n       addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 167, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "formatConclusion();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1730/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:07:54.308836855 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1730/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:07:54.308836855 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "formatPreamble();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 113, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Replace", 
          "seed": "return new DotFormatter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1448/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:05:15.089760935 -0500\n@@ -100,25 +100,6 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -161,7 +142,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n@@ -181,7 +162,6 @@\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1448/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:05:15.093760902 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 184, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Delete", 
          "seed": "return isExported(name,false) || isExported(name,true);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1050/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:01:25.499820011 -0500\n@@ -109,15 +109,6 @@\n     // This no-op statement was there so that JSDoc information could\n     // be attached to the name. This check should not complain about it.\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1050/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:01:25.499820011 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int keyParent=key(parent);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1239/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:03:15.707079130 -0500\n@@ -105,27 +105,8 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+    } else\n+\t\t;\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Delete", 
          "seed": "formatPreamble();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1298/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:03:50.314638303 -0500\n@@ -105,27 +105,8 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+    } else\n+\t\t;\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n@@ -161,7 +142,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1298/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:03:50.318638252 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_316/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:54:07.354174876 -0500\n@@ -106,26 +106,9 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+    StringBuilder builder = new StringBuilder();\n+    } else\n+\t\t;\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_765/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:58:41.956308924 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_976/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:00:43.571877583 -0500\n@@ -100,25 +100,7 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+      StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_976/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:00:43.571877583 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1269/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:03:32.426870840 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -161,7 +149,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1269/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:03:32.426870840 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "break;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1307/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:03:55.086579352 -0500\n@@ -105,27 +105,8 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+    } else\n+\t\t;\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n@@ -170,7 +151,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 173, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "break;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_486/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:56:01.249814732 -0500\n@@ -106,26 +106,9 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+    StringBuilder builder = new StringBuilder();\n+    } else\n+\t\t;\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1075/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:01:40.847808112 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -180,7 +166,6 @@\n     Node var = IR.var(name);\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n-    builder.recordNoAlias();\n     var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1075/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:01:40.851808109 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1075/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:01:40.851808109 -0500\n@@ -3120,20 +3120,8 @@\n         return (expr == parent.getFirstChild())\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n-        Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        ;\n+        ;\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 183, 
          "faulty": "builder.recordNoAlias();", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3123, 
          "faulty": "Node gramps=parent.getParent();", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_543/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:56:33.493396188 -0500\n@@ -111,21 +111,14 @@\n       if (n == parent.getLastChild()) {\n         for (Node an : parent.getAncestors()) {\n           int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n           if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n+\t\t\t;\n+\t\telse\n             break;\n         }\n       }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+    } else\n+\t\t;\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1003/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:00:58.619852461 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1003/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:00:58.619852461 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_931/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:00:19.079930110 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -180,8 +168,7 @@\n     Node var = IR.var(name);\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n-    builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n+    int start = 0;\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 184, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 183, 
          "faulty": "builder.recordNoAlias();", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1139/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:02:18.419797319 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1139/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:02:18.419797319 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1083/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:01:44.875805738 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -161,7 +147,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1083/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:01:44.875805738 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_829/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:59:20.444122587 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_829/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:59:20.448122569 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_794/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:59:00.988210214 -0500\n@@ -106,26 +106,9 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+    StringBuilder builder = new StringBuilder();\n+    } else\n+\t\t;\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1862/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:09:12.696609719 -0500\n@@ -100,25 +100,7 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+      StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -140,8 +122,6 @@\n       if (n.isString()) {\n         msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n-        msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n-            \"' operator is not being used.\";\n       }\n \n       t.getCompiler().report(\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1862/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:09:12.700609710 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 143, 
          "faulty": "msg=\"The result of the '\" + Token.name(n.getType()).toLowerCase() + \"' operator is not being used.\";", 
          "type": "Delete", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_583/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:56:55.889144654 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_583/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:56:55.889144654 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_709/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:58:09.212511748 -0500\n@@ -100,25 +100,6 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_709/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:58:09.212511748 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1491/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:05:39.157569199 -0500\n@@ -109,15 +109,7 @@\n     // This no-op statement was there so that JSDoc information could\n     // be attached to the name. This check should not complain about it.\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n+        int start = 0;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatPreamble();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1085/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:01:45.659805313 -0500\n@@ -109,15 +109,6 @@\n     // This no-op statement was there so that JSDoc information could\n     // be attached to the name. This check should not complain about it.\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n@@ -138,7 +129,6 @@\n       }\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n-        msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n         msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n             \"' operator is not being used.\";\n@@ -161,7 +151,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1085/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:01:45.659805313 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 141, 
          "faulty": "msg=\"Is there a missing '+' on the previous line?\";", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1921/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:09:48.716540108 -0500\n@@ -100,25 +100,7 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+      StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1921/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:09:48.720540101 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_352/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:54:30.575424962 -0500\n@@ -109,15 +109,6 @@\n     // This no-op statement was there so that JSDoc information could\n     // be attached to the name. This check should not complain about it.\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n@@ -163,7 +154,8 @@\n     if (!problemNodes.isEmpty()) {\n       addExtern();\n       for (Node n : problemNodes) {\n-        Node name = IR.name(PROTECTOR_FN).srcref(n);\n+        int index = -1;\n+\t\tNode name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "Node name=IR.name(PROTECTOR_FN).srcref(n);", 
          "type": "InsertBefore", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 113, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Replace", 
          "seed": "return 0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1978/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:10:24.136489160 -0500\n@@ -100,25 +100,7 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+      StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -140,8 +122,6 @@\n       if (n.isString()) {\n         msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n-        msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n-            \"' operator is not being used.\";\n       }\n \n       t.getCompiler().report(\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1978/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:10:24.140489155 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 143, 
          "faulty": "msg=\"The result of the '\" + Token.name(n.getType()).toLowerCase() + \"' operator is not being used.\";", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_651/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:57:36.192763510 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_651/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:57:36.196763477 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Replace", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Replace", 
          "seed": "break;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "JSType type=n.getJSType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1851/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:09:05.520625961 -0500\n@@ -100,32 +100,8 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+    } else\n+\t\t;\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n@@ -161,7 +137,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n@@ -180,7 +156,6 @@\n     Node var = IR.var(name);\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n-    builder.recordNoAlias();\n     var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1851/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:09:05.524625953 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SUB\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Replace", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 183, 
          "faulty": "builder.recordNoAlias();", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1325/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:04:06.502443388 -0500\n@@ -105,27 +105,8 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+    } else\n+\t\t;\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n@@ -161,7 +142,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1325/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:04:06.502443388 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_493/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:56:06.105747154 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "return new DefaultCodingConvention();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_759/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:58:38.732326991 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_759/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:58:38.732326991 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_805/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:59:06.816182605 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_805/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:59:06.820182585 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1536/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:06:03.253398526 -0500\n@@ -106,26 +106,9 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+    StringBuilder builder = new StringBuilder();\n+    } else\n+\t\t;\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1536/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:06:03.257398500 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_366/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:54:40.359215675 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 113, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Replace", 
          "seed": "return 0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_987/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:00:50.619865168 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_987/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:00:50.623865161 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1052/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:01:26.283819289 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_174/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:52:27.594762079 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Replace", 
          "seed": "break;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_854/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:59:34.380067520 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -161,7 +147,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_854/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:59:34.380067520 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1158/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:02:28.439758359 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1055/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:01:27.943817803 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1055/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:01:27.943817803 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_827/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:59:19.656125887 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_827/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:59:19.656125887 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "StringBuilder s=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"BITOR\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1800/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:08:35.116704406 -0500\n@@ -100,25 +100,6 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -161,7 +142,6 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1800/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:08:35.116704406 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1800/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:08:35.116704406 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tStringBuilder builder = new StringBuilder();\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_459/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:55:43.118082249 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1640/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:07:01.137064432 -0500\n@@ -100,25 +100,6 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -161,7 +142,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1640/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:07:01.137064432 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "formatPreamble();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 113, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Replace", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "case RETURN:"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_511/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:56:16.265611099 -0500\n@@ -106,26 +106,9 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+    StringBuilder builder = new StringBuilder();\n+    } else\n+\t\t;\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n@@ -161,7 +144,6 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1967/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:10:17.760497155 -0500\n@@ -100,25 +100,7 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+      StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -180,7 +162,6 @@\n     Node var = IR.var(name);\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n-    builder.recordNoAlias();\n     var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1967/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:10:17.760497155 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SUB\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Replace", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 183, 
          "faulty": "builder.recordNoAlias();", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "traverseNodes(n);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1503/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:05:44.717528001 -0500\n@@ -106,26 +106,9 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+    StringBuilder builder = new StringBuilder();\n+    } else\n+\t\t;\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n@@ -161,7 +144,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1503/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:05:44.717528001 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Delete", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_796/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:59:01.780206394 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_796/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:59:01.780206394 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_282/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:53:45.240755431 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -138,7 +126,6 @@\n       }\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n-        msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n         msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n             \"' operator is not being used.\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 141, 
          "faulty": "msg=\"Is there a missing '+' on the previous line?\";", 
          "type": "Delete", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1563/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:06:19.169296532 -0500\n@@ -100,25 +100,6 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -161,7 +142,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1563/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:06:19.173296507 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "formatPreamble();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 113, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Replace", 
          "seed": "return new DotFormatter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1094/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:01:50.479802943 -0500\n@@ -106,26 +106,9 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+    StringBuilder builder = new StringBuilder();\n+    } else\n+\t\t;\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n@@ -161,7 +144,8 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      int start = 0;\n+\taddExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1094/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:01:50.479802943 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1172/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:02:36.651629813 -0500\n@@ -105,27 +105,8 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+    } else\n+\t\t;\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1357/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:04:24.226245782 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_506/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:56:13.857642701 -0500\n@@ -106,26 +106,9 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+    StringBuilder builder = new StringBuilder();\n+    } else\n+\t\t;\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_506/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:56:13.861642649 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_156/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:52:13.501702538 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "InsertBefore", 
          "seed": "formatPreamble();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_522/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:56:23.249521634 -0500\n@@ -100,25 +100,6 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -181,7 +162,6 @@\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "break;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 113, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "InsertBefore", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 184, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1280/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:03:39.742773481 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -161,7 +147,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1280/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:03:39.742773481 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "int c=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_674/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:57:48.356664855 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_674/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:57:48.360664825 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1971/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:10:20.200494038 -0500\n@@ -100,25 +100,7 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+      StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -184,7 +166,6 @@\n     var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n-    compiler.reportCodeChange();\n   }\n \n   /**\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1971/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:10:20.204494031 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 187, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "return isExported(name,false) || isExported(name,true);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1292/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:03:47.118678492 -0500\n@@ -100,25 +100,6 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -161,7 +142,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1292/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:03:47.118678492 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_847/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:59:31.016080243 -0500\n@@ -109,15 +109,6 @@\n     // This no-op statement was there so that JSDoc information could\n     // be attached to the name. This check should not complain about it.\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_847/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:59:31.016080243 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 113, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return 0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_903/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:00:03.943970316 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -161,7 +147,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n@@ -180,8 +166,7 @@\n     Node var = IR.var(name);\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n-    builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n+    int start = 0;\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_903/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:00:03.947970305 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 184, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 183, 
          "faulty": "builder.recordNoAlias();", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1881/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:09:23.984585817 -0500\n@@ -100,32 +100,8 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+    } else\n+\t\t;\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n@@ -161,10 +137,11 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      int start = 0;\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n+        final String PARAM_NAME = \"jscomp_throw_param\";\n+\t\tname.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1881/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:09:23.984585817 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SUB\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 167, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_731/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:58:22.768422460 -0500\n@@ -100,32 +100,19 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+    } else {\n+\t\tint start = 0;\n+\t\tif (parent.getType() != Token.EXPR_RESULT\n+\t\t\t\t&& parent.getType() != Token.BLOCK) {\n+\t\t\tif (parent.getType() == Token.FOR\n+\t\t\t\t\t&& parent.getChildCount() == 4\n+\t\t\t\t\t&& (n == parent.getFirstChild() || n == parent\n+\t\t\t\t\t\t\t.getFirstChild().getNext().getNext())) {\n+\t\t\t} else {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\t}\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_731/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:58:22.768422460 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_980/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:00:45.935873287 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_980/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:00:45.935873287 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int keyParent=key(parent);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_933/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:00:19.867928184 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -161,10 +147,10 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n+        StringBuilder builder = new StringBuilder();\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_933/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:00:19.871928175 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 167, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_737/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:58:25.952402599 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1147/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:02:23.611797723 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -180,7 +166,6 @@\n     Node var = IR.var(name);\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n-    builder.recordNoAlias();\n     var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1147/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:02:23.611797723 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1147/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:02:23.611797723 -0500\n@@ -3120,20 +3120,8 @@\n         return (expr == parent.getFirstChild())\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n-        Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        ;\n+        ;\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 183, 
          "faulty": "builder.recordNoAlias();", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3123, 
          "faulty": "Node gramps=parent.getParent();", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1547/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:06:10.381351836 -0500\n@@ -100,25 +100,7 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+      StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -176,7 +158,8 @@\n \n   private void addExtern() {\n     Node name = IR.name(PROTECTOR_FN);\n-    name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n+    int start = 0;\n+\tname.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n     Node var = IR.var(name);\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1547/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:06:10.381351836 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 179, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_706/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:58:07.504523556 -0500\n@@ -106,26 +106,9 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+    StringBuilder builder = new StringBuilder();\n+    } else\n+\t\t;\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_706/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:58:07.508523528 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1169/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:02:34.991655414 -0500\n@@ -106,26 +106,9 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+    StringBuilder builder = new StringBuilder();\n+    } else\n+\t\t;\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n@@ -161,7 +144,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1169/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:02:34.991655414 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_274/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:53:39.680380320 -0500\n@@ -109,15 +109,6 @@\n     // This no-op statement was there so that JSDoc information could\n     // be attached to the name. This check should not complain about it.\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n@@ -180,8 +171,9 @@\n     Node var = IR.var(name);\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n-    builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n+    int start = 0;\n+    int index = -1;\n+\tvar.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 183, 
          "faulty": "builder.recordNoAlias();", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 184, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "InsertBefore", 
          "seed": "int index=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1788/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:08:28.436723853 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1788/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:08:28.436723853 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1914/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:09:44.604547099 -0500\n@@ -106,26 +106,9 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+    StringBuilder builder = new StringBuilder();\n+    } else\n+\t\t;\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n@@ -161,7 +144,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1914/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:09:44.608547092 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 113, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "InsertBefore", 
          "seed": "this.level=level;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1185/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:02:45.247500192 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1185/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:02:45.251500133 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "break;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_816/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:59:14.068149884 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -164,7 +152,7 @@\n       addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n+        StringBuilder builder = new StringBuilder();\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 167, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1688/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:07:30.032932367 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1349/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:04:20.230288945 -0500\n@@ -100,24 +100,10 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n+      // This no-op statement was there so that JSDoc information could\n     // be attached to the name. This check should not complain about it.\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n+        int start = 0;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1349/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:04:20.234288903 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_688/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:57:56.532602483 -0500\n@@ -100,32 +100,19 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+    } else {\n+\t\tint start = 0;\n+\t\tif (parent.getType() != Token.EXPR_RESULT\n+\t\t\t\t&& parent.getType() != Token.BLOCK) {\n+\t\t\tif (parent.getType() == Token.FOR\n+\t\t\t\t\t&& parent.getChildCount() == 4\n+\t\t\t\t\t&& (n == parent.getFirstChild() || n == parent\n+\t\t\t\t\t\t\t.getFirstChild().getNext().getNext())) {\n+\t\t\t} else {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\t}\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_688/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:57:56.536602454 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1842/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:08:59.840639411 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -180,7 +166,6 @@\n     Node var = IR.var(name);\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n-    builder.recordNoAlias();\n     var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1842/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:08:59.844639401 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 183, 
          "faulty": "builder.recordNoAlias();", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1625/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:06:53.177104609 -0500\n@@ -100,25 +100,6 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -161,7 +142,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1625/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:06:53.177104609 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "formatPreamble();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 113, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Replace", 
          "seed": "return new DotFormatter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_961/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:00:35.495893263 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -161,7 +147,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n@@ -181,7 +167,7 @@\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n+    int start = 0;\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_961/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:00:35.499893254 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 184, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "InsertBefore", 
          "seed": "int keyParent=key(parent);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1422/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:05:00.869885050 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1422/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:05:00.869885050 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Replace", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_769/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:58:44.280296152 -0500\n@@ -113,10 +113,6 @@\n           int ancestorType = an.getType();\n           if (ancestorType == Token.COMMA)\n             continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n         }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1776/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:08:20.800747117 -0500\n@@ -100,25 +100,7 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+      StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -161,10 +143,11 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      int start = 0;\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n+        final String PARAM_NAME = \"jscomp_throw_param\";\n+\t\tname.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1776/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:08:20.800747117 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SUB\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 167, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_951/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:00:30.087904651 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -164,7 +152,7 @@\n       addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n+        StringBuilder builder = new StringBuilder();\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 167, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_692/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:57:58.904584959 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -164,7 +150,7 @@\n       addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n+        StringBuilder builder = new StringBuilder();\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_692/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:57:58.904584959 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              StringBuilder s = new StringBuilder();\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "StringBuilder s=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 167, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_684/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:57:54.856615014 -0500\n@@ -106,26 +106,9 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+    StringBuilder builder = new StringBuilder();\n+    } else\n+\t\t;\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_901/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:00:03.155972581 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -164,7 +150,7 @@\n       addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n+        StringBuilder builder = new StringBuilder();\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 167, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "JSType type=n.getJSType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_886/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:59:53.776000869 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -161,7 +147,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n@@ -181,7 +167,7 @@\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n+    int start = 0;\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_886/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:59:53.776000869 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 184, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Replace", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1149/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:02:24.399797824 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1149/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:02:24.399797824 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1416/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:04:57.653914298 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "break;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_834/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:59:23.788108803 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_484/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:56:00.469825745 -0500\n@@ -106,26 +106,9 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+    StringBuilder builder = new StringBuilder();\n+    } else\n+\t\t;\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n@@ -184,7 +167,6 @@\n     var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n-    compiler.reportCodeChange();\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 187, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "return isExported(name,false) || isExported(name,true);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1030/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:01:13.571832522 -0500\n@@ -100,25 +100,6 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -184,7 +165,6 @@\n     var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n-    compiler.reportCodeChange();\n   }\n \n   /**\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1030/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:01:13.575832517 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "JSType type=n.getJSType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 187, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1501/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:05:43.925533800 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -161,7 +147,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1501/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:05:43.929533770 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "break;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1041/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:01:19.763825661 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1041/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:01:19.763825661 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_729/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:58:21.976427463 -0500\n@@ -100,32 +100,19 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+    } else {\n+\t\tint start = 0;\n+\t\tif (parent.getType() != Token.EXPR_RESULT\n+\t\t\t\t&& parent.getType() != Token.BLOCK) {\n+\t\t\tif (parent.getType() == Token.FOR\n+\t\t\t\t\t&& parent.getChildCount() == 4\n+\t\t\t\t\t&& (n == parent.getFirstChild() || n == parent\n+\t\t\t\t\t\t\t.getFirstChild().getNext().getNext())) {\n+\t\t\t} else {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\t}\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n@@ -140,8 +127,6 @@\n       if (n.isString()) {\n         msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n-        msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n-            \"' operator is not being used.\";\n       }\n \n       t.getCompiler().report(\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_729/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:58:21.980427437 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Replace", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 143, 
          "faulty": "msg=\"The result of the '\" + Token.name(n.getType()).toLowerCase() + \"' operator is not being used.\";", 
          "type": "Delete", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1642/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:07:01.977060290 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -163,7 +149,8 @@\n     if (!problemNodes.isEmpty()) {\n       addExtern();\n       for (Node n : problemNodes) {\n-        Node name = IR.name(PROTECTOR_FN).srcref(n);\n+        int type = n.getType();\n+\t\tNode name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1642/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:07:01.981060270 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SUB\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 113, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "Node name=IR.name(PROTECTOR_FN).srcref(n);", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1692/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:07:32.428922341 -0500\n@@ -100,24 +100,9 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n+      // This no-op statement was there so that JSDoc information could\n     // be attached to the name. This check should not complain about it.\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "formatPreamble();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 113, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Replace", 
          "seed": "return new DotFormatter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_899/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:00:02.263975164 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "return toDot(n,null);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1679/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:07:24.552955820 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -181,7 +167,8 @@\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n+    final String PARAM_NAME = \"jscomp_throw_param\";\n+\tvar.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1679/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:07:24.552955820 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 184, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1577/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:06:27.733244972 -0500\n@@ -100,25 +100,6 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -161,7 +142,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1577/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:06:27.733244972 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "formatPreamble();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 113, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Replace", 
          "seed": "return new DotFormatter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_11/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:50:26.289012820 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "JSType type=n.getJSType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1706/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:07:40.472889654 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1136/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:02:16.851797282 -0500\n@@ -105,27 +105,8 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+    } else\n+\t\t;\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1136/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:02:16.851797282 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1404/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:04:51.181974510 -0500\n@@ -100,24 +100,10 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n+      // This no-op statement was there so that JSDoc information could\n     // be attached to the name. This check should not complain about it.\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n+        int start = 0;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1404/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:04:51.181974510 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_313/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:54:05.778077411 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_823/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:59:17.280135965 -0500\n@@ -106,26 +106,9 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+    StringBuilder builder = new StringBuilder();\n+    } else\n+\t\t;\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_823/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:59:17.284135947 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1265/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:03:30.034900308 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -164,7 +152,7 @@\n       addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n+        StringBuilder builder = new StringBuilder();\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1265/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:03:30.034900308 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 167, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1102/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:01:56.075800721 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -180,7 +168,6 @@\n     Node var = IR.var(name);\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n-    builder.recordNoAlias();\n     var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1102/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:01:56.079800720 -0500\n@@ -3120,20 +3120,8 @@\n         return (expr == parent.getFirstChild())\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n-        Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        ;\n+        ;\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 183, 
          "faulty": "builder.recordNoAlias();", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3123, 
          "faulty": "Node gramps=parent.getParent();", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1912/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:09:43.824548451 -0500\n@@ -100,25 +100,7 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+      StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -184,7 +166,6 @@\n     var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n-    compiler.reportCodeChange();\n   }\n \n   /**\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1912/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:09:43.824548451 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 187, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "return isExported(name,false) || isExported(name,true);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1638/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:07:00.357068294 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1638/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:07:00.357068294 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SUB\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int keyParent=key(parent);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_859/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:59:37.620055595 -0500\n@@ -106,26 +106,9 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+    StringBuilder builder = new StringBuilder();\n+    } else\n+\t\t;\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_859/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:59:37.620055595 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1446/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:05:14.301767598 -0500\n@@ -100,25 +100,6 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -161,7 +142,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1446/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:05:14.305767564 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "formatPreamble();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 113, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_670/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:57:45.940683880 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_602/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:57:06.413036645 -0500\n@@ -106,26 +106,9 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+    StringBuilder builder = new StringBuilder();\n+    } else\n+\t\t;\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "formatPreamble();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1286/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:03:43.942719006 -0500\n@@ -106,26 +106,9 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+    StringBuilder builder = new StringBuilder();\n+    } else\n+\t\t;\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n@@ -170,7 +153,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1286/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:03:43.942719006 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 173, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1713/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:07:44.544873672 -0500\n@@ -100,25 +100,6 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -161,7 +142,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1713/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:07:44.548873656 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_636/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:57:27.296840274 -0500\n@@ -109,23 +109,9 @@\n     // This no-op statement was there so that JSDoc information could\n     // be attached to the name. This check should not complain about it.\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n       }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+    } else\n+\t\t;\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1212/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:03:00.407283403 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -164,7 +152,7 @@\n       addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n+        StringBuilder builder = new StringBuilder();\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1212/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:03:00.407283403 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 167, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1766/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:08:14.504767153 -0500\n@@ -109,15 +109,6 @@\n     // This no-op statement was there so that JSDoc information could\n     // be attached to the name. This check should not complain about it.\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1766/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:08:14.504767153 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "formatPreamble();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 113, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Replace", 
          "seed": "return new DotFormatter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_291/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:53:50.061074580 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_992/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:00:53.039861169 -0500\n@@ -100,25 +100,6 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -161,10 +142,10 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n+        StringBuilder builder = new StringBuilder();\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 167, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "JSType type=n.getJSType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_454/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:55:39.798133923 -0500\n@@ -114,8 +114,8 @@\n           if (ancestorType == Token.COMMA)\n             continue;\n           if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n+\t\t\t;\n+\t\telse\n             break;\n         }\n       }\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_454/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:55:39.798133923 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_905/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:00:04.739968049 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -161,7 +147,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n@@ -180,8 +166,7 @@\n     Node var = IR.var(name);\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n-    builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n+    int start = 0;\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_905/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:00:04.739968049 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 184, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 183, 
          "faulty": "builder.recordNoAlias();", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_451/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:55:38.218158813 -0500\n@@ -109,15 +109,6 @@\n     // This no-op statement was there so that JSDoc information could\n     // be attached to the name. This check should not complain about it.\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Replace", 
          "seed": "return 0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_686/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:57:55.656609017 -0500\n@@ -105,27 +105,8 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+    } else\n+\t\t;\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1206/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:02:57.831319204 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -140,8 +128,6 @@\n       if (n.isString()) {\n         msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n-        msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n-            \"' operator is not being used.\";\n       }\n \n       t.getCompiler().report(\n@@ -184,7 +170,8 @@\n     var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n-    compiler.reportCodeChange();\n+    final String PARAM_NAME = \"jscomp_throw_param\";\n+\tcompiler.reportCodeChange();\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 143, 
          "faulty": "msg=\"The result of the '\" + Token.name(n.getType()).toLowerCase() + \"' operator is not being used.\";", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 187, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1072/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:01:39.099809236 -0500\n@@ -109,15 +109,6 @@\n     // This no-op statement was there so that JSDoc information could\n     // be attached to the name. This check should not complain about it.\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1072/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:01:39.099809236 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_524/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:56:24.029511837 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_524/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:56:24.029511837 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"RETURN\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_529/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:56:26.433481919 -0500\n@@ -105,27 +105,8 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+    } else\n+\t\t;\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1336/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:04:13.178367072 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -161,7 +147,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1336/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:04:13.178367072 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1734/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:07:55.868831164 -0500\n@@ -100,24 +100,10 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n+      // This no-op statement was there so that JSDoc information could\n     // be attached to the name. This check should not complain about it.\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n+        int start = 0;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n@@ -161,10 +147,11 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      int start = 0;\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n+        final String PARAM_NAME = \"jscomp_throw_param\";\n+\t\tname.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1734/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:07:55.868831164 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SUB\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 167, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1278/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:03:38.950783862 -0500\n@@ -100,25 +100,7 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+      StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_581/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:56:55.033153715 -0500\n@@ -100,25 +100,6 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -181,7 +162,6 @@\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_581/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:56:55.037153672 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "break;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 113, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "InsertBefore", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 184, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "lazyInitInfo();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_77/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:51:16.137500933 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -183,7 +169,6 @@\n     builder.recordNoAlias();\n     var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n-    input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "JSType type=n.getJSType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 186, 
          "faulty": "input.getAstRoot(compiler).addChildrenToBack(var);", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1091/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:01:48.899803673 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1091/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:01:48.903803671 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 113, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1354/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:04:22.610263143 -0500\n@@ -100,25 +100,6 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -161,7 +142,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1354/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:04:22.614263100 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "formatPreamble();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 113, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_818/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:59:14.856146437 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_818/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:59:14.860146420 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "StringBuilder s=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_679/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:57:51.560640043 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_679/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:57:51.564640012 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1233/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:03:12.531120377 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -164,7 +152,7 @@\n       addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n+        StringBuilder builder = new StringBuilder();\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 167, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1107/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:01:58.491799938 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -161,7 +147,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1107/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:01:58.491799938 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1617/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:06:49.261125011 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -181,7 +167,8 @@\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n+    final String PARAM_NAME = \"jscomp_throw_param\";\n+\tvar.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 184, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_131/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:51:56.921644130 -0500\n@@ -99,7 +99,8 @@\n     // these cases when we visit the child, and the peephole passes will\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n-      Node gramps = parent.getParent();\n+      int start = 0;\n+\tNode gramps = parent.getParent();\n       if (gramps.isCall() && parent == gramps.getFirstChild()) {\n         if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n       return;\n@@ -114,8 +115,8 @@\n           if (ancestorType == Token.COMMA)\n             continue;\n           if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n+\t\t\t;\n+\t\telse\n             break;\n         }\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 102, 
          "faulty": "Node gramps=parent.getParent();", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1472/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:05:28.737649484 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1472/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:05:28.741649452 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Replace", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1572/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:06:24.625263423 -0500\n@@ -100,24 +100,10 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n+      // This no-op statement was there so that JSDoc information could\n     // be attached to the name. This check should not complain about it.\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n+        int start = 0;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1572/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:06:24.625263423 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SUB\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1723/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:07:50.960849241 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_363/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:54:38.627252034 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1464/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:05:23.929687915 -0500\n@@ -100,32 +100,19 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+    } else {\n+\t\tint start = 0;\n+\t\tif (parent.getType() != Token.EXPR_RESULT\n+\t\t\t\t&& parent.getType() != Token.BLOCK) {\n+\t\t\tif (parent.getType() == Token.FOR\n+\t\t\t\t\t&& parent.getChildCount() == 4\n+\t\t\t\t\t&& (n == parent.getFirstChild() || n == parent\n+\t\t\t\t\t\t\t.getFirstChild().getNext().getNext())) {\n+\t\t\t} else {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\t}\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n@@ -161,7 +148,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1464/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:05:23.929687915 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "formatPreamble();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 113, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1341/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:04:15.598339980 -0500\n@@ -100,25 +100,6 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -161,7 +142,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1341/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:04:15.598339980 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_541/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:56:32.693405742 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_541/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:56:32.693405742 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1193/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:02:49.183442479 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -138,7 +124,6 @@\n       }\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n-        msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n         msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n             \"' operator is not being used.\";\n@@ -161,7 +146,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1193/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:02:49.187442423 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 141, 
          "faulty": "msg=\"Is there a missing '+' on the previous line?\";", 
          "type": "Delete", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_234/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:53:12.638444086 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -177,7 +165,8 @@\n   private void addExtern() {\n     Node name = IR.name(PROTECTOR_FN);\n     name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n-    Node var = IR.var(name);\n+    final String PARAM_NAME = \"jscomp_throw_param\";\n+\tNode var = IR.var(name);\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 180, 
          "faulty": "Node var=IR.var(name);", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1737/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:07:57.448825458 -0500\n@@ -100,25 +100,7 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+      StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1737/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:07:57.452825444 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1895/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:09:32.716568662 -0500\n@@ -106,26 +106,9 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+    StringBuilder builder = new StringBuilder();\n+    } else\n+\t\t;\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n@@ -184,7 +167,6 @@\n     var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n-    compiler.reportCodeChange();\n   }\n \n   /**\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1895/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:09:32.716568662 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 187, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1950/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:10:07.388511239 -0500\n@@ -100,25 +100,6 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -138,7 +119,6 @@\n       }\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n-        msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n         msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n             \"' operator is not being used.\";\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1950/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:10:07.392511233 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SUB\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 141, 
          "faulty": "msg=\"Is there a missing '+' on the previous line?\";", 
          "type": "Delete", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_845/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:59:30.216083324 -0500\n@@ -109,15 +109,6 @@\n     // This no-op statement was there so that JSDoc information could\n     // be attached to the name. This check should not complain about it.\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_845/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:59:30.220083309 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1440/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:05:11.181794216 -0500\n@@ -100,25 +100,7 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+      StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1191/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:02:48.403453838 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -161,7 +149,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1191/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:02:48.403453838 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1487/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:05:37.481581842 -0500\n@@ -100,25 +100,6 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -161,7 +142,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1487/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:05:37.481581842 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_746/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:58:30.804373131 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_746/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:58:30.808373107 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "StringBuilder s=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1039/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:01:18.959826504 -0500\n@@ -114,8 +114,8 @@\n           if (ancestorType == Token.COMMA)\n             continue;\n           if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n+\t\t\t;\n+\t\telse\n             break;\n         }\n       }\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1039/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:01:18.959826504 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "switch (token) {\ncase ERROR:\n  return \"ERROR\";\ncase RETURN:\nreturn \"RETURN\";\ncase BITOR:\nreturn \"BITOR\";\ncase BITXOR:\nreturn \"BITXOR\";\ncase BITAND:\nreturn \"BITAND\";\ncase EQ:\nreturn \"EQ\";\ncase NE:\nreturn \"NE\";\ncase LT:\nreturn \"LT\";\ncase LE:\nreturn \"LE\";\ncase GT:\nreturn \"GT\";\ncase GE:\nreturn \"GE\";\ncase LSH:\nreturn \"LSH\";\ncase RSH:\nreturn \"RSH\";\ncase URSH:\nreturn \"URSH\";\ncase ADD:\nreturn \"ADD\";\ncase SUB:\nreturn \"SUB\";\ncase MUL:\nreturn \"MUL\";\ncase DIV:\nreturn \"DIV\";\ncase MOD:\nreturn \"MOD\";\ncase NOT:\nreturn \"NOT\";\ncase BITNOT:\nreturn \"BITNOT\";\ncase POS:\nreturn \"POS\";\ncase NEG:\nreturn \"NEG\";\ncase NEW:\nreturn \"NEW\";\ncase DELPROP:\nreturn \"DELPROP\";\ncase TYPEOF:\nreturn \"TYPEOF\";\ncase GETPROP:\nreturn \"GETPROP\";\ncase GETELEM:\nreturn \"GETELEM\";\ncase CALL:\nreturn \"CALL\";\ncase NAME:\nreturn \"NAME\";\ncase LABEL_NAME:\nreturn \"LABEL_NAME\";\ncase NUMBER:\nreturn \"NUMBER\";\ncase STRING:\nreturn \"STRING\";\ncase STRING_KEY:\nreturn \"STRING_KEY\";\ncase NULL:\nreturn \"NULL\";\ncase THIS:\nreturn \"THIS\";\ncase FALSE:\nreturn \"FALSE\";\ncase TRUE:\nreturn \"TRUE\";\ncase SHEQ:\nreturn \"SHEQ\";\ncase SHNE:\nreturn \"SHNE\";\ncase REGEXP:\nreturn \"REGEXP\";\ncase THROW:\nreturn \"THROW\";\ncase IN:\nreturn \"IN\";\ncase INSTANCEOF:\nreturn \"INSTANCEOF\";\ncase ARRAYLIT:\nreturn \"ARRAYLIT\";\ncase OBJECTLIT:\nreturn \"OBJECTLIT\";\ncase TRY:\nreturn \"TRY\";\ncase PARAM_LIST:\nreturn \"PARAM_LIST\";\ncase COMMA:\nreturn \"COMMA\";\ncase ASSIGN:\nreturn \"ASSIGN\";\ncase ASSIGN_BITOR:\nreturn \"ASSIGN_BITOR\";\ncase ASSIGN_BITXOR:\nreturn \"ASSIGN_BITXOR\";\ncase ASSIGN_BITAND:\nreturn \"ASSIGN_BITAND\";\ncase ASSIGN_LSH:\nreturn \"ASSIGN_LSH\";\ncase ASSIGN_RSH:\nreturn \"ASSIGN_RSH\";\ncase ASSIGN_URSH:\nreturn \"ASSIGN_URSH\";\ncase ASSIGN_ADD:\nreturn \"ASSIGN_ADD\";\ncase ASSIGN_SUB:\nreturn \"ASSIGN_SUB\";\ncase ASSIGN_MUL:\nreturn \"ASSIGN_MUL\";\ncase ASSIGN_DIV:\nreturn \"ASSIGN_DIV\";\ncase ASSIGN_MOD:\nreturn \"ASSIGN_MOD\";\ncase HOOK:\nreturn \"HOOK\";\ncase COLON:\nreturn \"COLON\";\ncase OR:\nreturn \"OR\";\ncase AND:\nreturn \"AND\";\ncase INC:\nreturn \"INC\";\ncase DEC:\nreturn \"DEC\";\ncase FUNCTION:\nreturn \"FUNCTION\";\ncase IF:\nreturn \"IF\";\ncase SWITCH:\nreturn \"SWITCH\";\ncase CASE:\nreturn \"CASE\";\ncase DEFAULT_CASE:\nreturn \"DEFAULT_CASE\";\ncase WHILE:\nreturn \"WHILE\";\ncase DO:\nreturn \"DO\";\ncase FOR:\nreturn \"FOR\";\ncase BREAK:\nreturn \"BREAK\";\ncase CONTINUE:\nreturn \"CONTINUE\";\ncase VAR:\nreturn \"VAR\";\ncase WITH:\nreturn \"WITH\";\ncase CATCH:\nreturn \"CATCH\";\ncase EMPTY:\nreturn \"EMPTY\";\ncase BLOCK:\nreturn \"BLOCK\";\ncase LABEL:\nreturn \"LABEL\";\ncase EXPR_RESULT:\nreturn \"EXPR_RESULT\";\ncase SCRIPT:\nreturn \"SCRIPT\";\ncase GETTER_DEF:\nreturn \"GETTER_DEF\";\ncase SETTER_DEF:\nreturn \"SETTER_DEF\";\ncase CONST:\nreturn \"CONST\";\ncase DEBUGGER:\nreturn \"DEBUGGER\";\ncase ANNOTATION:\nreturn \"ANNOTATION\";\ncase PIPE:\nreturn \"PIPE\";\ncase STAR:\nreturn \"STAR\";\ncase EOC:\nreturn \"EOC\";\ncase QMARK:\nreturn \"QMARK\";\ncase ELLIPSIS:\nreturn \"ELLIPSIS\";\ncase BANG:\nreturn \"BANG\";\ncase VOID:\nreturn \"VOID\";\ncase EQUALS:\nreturn \"EQUALS\";\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_415/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:55:11.850604067 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -138,10 +126,7 @@\n       }\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n-        msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n-        msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n-            \"' operator is not being used.\";\n       }\n \n       t.getCompiler().report(\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 141, 
          "faulty": "msg=\"Is there a missing '+' on the previous line?\";", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 143, 
          "faulty": "msg=\"The result of the '\" + Token.name(n.getType()).toLowerCase() + \"' operator is not being used.\";", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_372/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:54:43.535149766 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_598/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:57:04.825052540 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -164,7 +152,6 @@\n       addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_598/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:57:04.829052500 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              Node block = new Node(Token.BLOCK);\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 167, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "Node block=new Node(Token.BLOCK);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1886/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:09:26.408580940 -0500\n@@ -100,25 +100,7 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+      StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -184,7 +166,6 @@\n     var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n-    compiler.reportCodeChange();\n   }\n \n   /**\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1886/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:09:26.412580932 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 187, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "return isExported(name,false) || isExported(name,true);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_884/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:59:52.940003511 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_884/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:59:52.944003497 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1657/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:07:10.773018045 -0500\n@@ -100,24 +100,10 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n+      // This no-op statement was there so that JSDoc information could\n     // be attached to the name. This check should not complain about it.\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n+        int start = 0;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1657/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:07:10.773018045 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SUB\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int keyParent=key(parent);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_344/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:54:24.951226555 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -138,7 +126,6 @@\n       }\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n-        msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n         msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n             \"' operator is not being used.\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 141, 
          "faulty": "msg=\"Is there a missing '+' on the previous line?\";", 
          "type": "Delete", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1035/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:01:16.555829116 -0500\n@@ -99,26 +99,8 @@\n     // these cases when we visit the child, and the peephole passes will\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n-      Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n+      StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -161,7 +143,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1035/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:01:16.559829110 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "JSType type=n.getJSType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "InsertBefore", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 102, 
          "faulty": "Node gramps=parent.getParent();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1764/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:08:13.684769820 -0500\n@@ -100,25 +100,7 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+      StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -161,7 +143,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1764/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:08:13.688769806 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1814/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:08:43.156682086 -0500\n@@ -106,26 +106,9 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+    StringBuilder builder = new StringBuilder();\n+    } else\n+\t\t;\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n@@ -161,7 +144,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n@@ -184,7 +167,6 @@\n     var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n-    compiler.reportCodeChange();\n   }\n \n   /**\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1814/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:08:43.160682075 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 187, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_138/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:52:01.697660943 -0500\n@@ -114,8 +114,8 @@\n           if (ancestorType == Token.COMMA)\n             continue;\n           if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n+\t\t\t;\n+\t\telse\n             break;\n         }\n       }\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_138/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:52:01.697660943 -0500\n@@ -3121,19 +3121,7 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        int index = -1;\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_306/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:54:00.977777136 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1614/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:06:47.697133277 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1614/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:06:47.697133277 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SUB\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 113, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_741/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:58:28.328388052 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_741/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:58:28.332388028 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1592/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:06:36.461194710 -0500\n@@ -105,27 +105,8 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+    } else\n+\t\t;\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1598/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:06:39.605177154 -0500\n@@ -100,24 +100,10 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n+      // This no-op statement was there so that JSDoc information could\n     // be attached to the name. This check should not complain about it.\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n+        int start = 0;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n@@ -161,7 +147,8 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      StringBuilder builder = new StringBuilder();\n+\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1598/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:06:39.609177131 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_557/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:56:42.369292862 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_557/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:56:42.369292862 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1497/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:05:42.365545293 -0500\n@@ -106,26 +106,9 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+    StringBuilder builder = new StringBuilder();\n+    } else\n+\t\t;\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n@@ -161,7 +144,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1497/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:05:42.369545263 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int type=n.getType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1045/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:01:22.131823245 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1045/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:01:22.135823241 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_625/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:57:19.908907092 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_625/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:57:19.908907092 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1755/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:08:08.156788151 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1755/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:08:08.156788151 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1655/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:07:09.997021690 -0500\n@@ -100,25 +100,7 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+      StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "formatPreamble();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 113, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1001/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:00:57.823853660 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1001/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:00:57.823853660 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "switch (token) {\ncase ERROR:\n  return \"ERROR\";\ncase RETURN:\nreturn \"RETURN\";\ncase BITOR:\nreturn \"BITOR\";\ncase BITXOR:\nreturn \"BITXOR\";\ncase BITAND:\nreturn \"BITAND\";\ncase EQ:\nreturn \"EQ\";\ncase NE:\nreturn \"NE\";\ncase LT:\nreturn \"LT\";\ncase LE:\nreturn \"LE\";\ncase GT:\nreturn \"GT\";\ncase GE:\nreturn \"GE\";\ncase LSH:\nreturn \"LSH\";\ncase RSH:\nreturn \"RSH\";\ncase URSH:\nreturn \"URSH\";\ncase ADD:\nreturn \"ADD\";\ncase SUB:\nreturn \"SUB\";\ncase MUL:\nreturn \"MUL\";\ncase DIV:\nreturn \"DIV\";\ncase MOD:\nreturn \"MOD\";\ncase NOT:\nreturn \"NOT\";\ncase BITNOT:\nreturn \"BITNOT\";\ncase POS:\nreturn \"POS\";\ncase NEG:\nreturn \"NEG\";\ncase NEW:\nreturn \"NEW\";\ncase DELPROP:\nreturn \"DELPROP\";\ncase TYPEOF:\nreturn \"TYPEOF\";\ncase GETPROP:\nreturn \"GETPROP\";\ncase GETELEM:\nreturn \"GETELEM\";\ncase CALL:\nreturn \"CALL\";\ncase NAME:\nreturn \"NAME\";\ncase LABEL_NAME:\nreturn \"LABEL_NAME\";\ncase NUMBER:\nreturn \"NUMBER\";\ncase STRING:\nreturn \"STRING\";\ncase STRING_KEY:\nreturn \"STRING_KEY\";\ncase NULL:\nreturn \"NULL\";\ncase THIS:\nreturn \"THIS\";\ncase FALSE:\nreturn \"FALSE\";\ncase TRUE:\nreturn \"TRUE\";\ncase SHEQ:\nreturn \"SHEQ\";\ncase SHNE:\nreturn \"SHNE\";\ncase REGEXP:\nreturn \"REGEXP\";\ncase THROW:\nreturn \"THROW\";\ncase IN:\nreturn \"IN\";\ncase INSTANCEOF:\nreturn \"INSTANCEOF\";\ncase ARRAYLIT:\nreturn \"ARRAYLIT\";\ncase OBJECTLIT:\nreturn \"OBJECTLIT\";\ncase TRY:\nreturn \"TRY\";\ncase PARAM_LIST:\nreturn \"PARAM_LIST\";\ncase COMMA:\nreturn \"COMMA\";\ncase ASSIGN:\nreturn \"ASSIGN\";\ncase ASSIGN_BITOR:\nreturn \"ASSIGN_BITOR\";\ncase ASSIGN_BITXOR:\nreturn \"ASSIGN_BITXOR\";\ncase ASSIGN_BITAND:\nreturn \"ASSIGN_BITAND\";\ncase ASSIGN_LSH:\nreturn \"ASSIGN_LSH\";\ncase ASSIGN_RSH:\nreturn \"ASSIGN_RSH\";\ncase ASSIGN_URSH:\nreturn \"ASSIGN_URSH\";\ncase ASSIGN_ADD:\nreturn \"ASSIGN_ADD\";\ncase ASSIGN_SUB:\nreturn \"ASSIGN_SUB\";\ncase ASSIGN_MUL:\nreturn \"ASSIGN_MUL\";\ncase ASSIGN_DIV:\nreturn \"ASSIGN_DIV\";\ncase ASSIGN_MOD:\nreturn \"ASSIGN_MOD\";\ncase HOOK:\nreturn \"HOOK\";\ncase COLON:\nreturn \"COLON\";\ncase OR:\nreturn \"OR\";\ncase AND:\nreturn \"AND\";\ncase INC:\nreturn \"INC\";\ncase DEC:\nreturn \"DEC\";\ncase FUNCTION:\nreturn \"FUNCTION\";\ncase IF:\nreturn \"IF\";\ncase SWITCH:\nreturn \"SWITCH\";\ncase CASE:\nreturn \"CASE\";\ncase DEFAULT_CASE:\nreturn \"DEFAULT_CASE\";\ncase WHILE:\nreturn \"WHILE\";\ncase DO:\nreturn \"DO\";\ncase FOR:\nreturn \"FOR\";\ncase BREAK:\nreturn \"BREAK\";\ncase CONTINUE:\nreturn \"CONTINUE\";\ncase VAR:\nreturn \"VAR\";\ncase WITH:\nreturn \"WITH\";\ncase CATCH:\nreturn \"CATCH\";\ncase EMPTY:\nreturn \"EMPTY\";\ncase BLOCK:\nreturn \"BLOCK\";\ncase LABEL:\nreturn \"LABEL\";\ncase EXPR_RESULT:\nreturn \"EXPR_RESULT\";\ncase SCRIPT:\nreturn \"SCRIPT\";\ncase GETTER_DEF:\nreturn \"GETTER_DEF\";\ncase SETTER_DEF:\nreturn \"SETTER_DEF\";\ncase CONST:\nreturn \"CONST\";\ncase DEBUGGER:\nreturn \"DEBUGGER\";\ncase ANNOTATION:\nreturn \"ANNOTATION\";\ncase PIPE:\nreturn \"PIPE\";\ncase STAR:\nreturn \"STAR\";\ncase EOC:\nreturn \"EOC\";\ncase QMARK:\nreturn \"QMARK\";\ncase ELLIPSIS:\nreturn \"ELLIPSIS\";\ncase BANG:\nreturn \"BANG\";\ncase VOID:\nreturn \"VOID\";\ncase EQUALS:\nreturn \"EQUALS\";\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1727/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:07:52.736842641 -0500\n@@ -100,32 +100,9 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+      StringBuilder builder = new StringBuilder();\n+    } else\n+\t\t;\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1727/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:07:52.740842627 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1727/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:07:52.740842627 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tint start = 0;\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "break;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1534/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:06:02.457403846 -0500\n@@ -100,25 +100,6 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -161,7 +142,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1534/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:06:02.457403846 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1513/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:05:51.197481381 -0500\n@@ -100,24 +100,9 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n+      // This no-op statement was there so that JSDoc information could\n     // be attached to the name. This check should not complain about it.\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n@@ -161,7 +146,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1513/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:05:51.201481353 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "formatPreamble();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 113, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1812/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:08:42.372684213 -0500\n@@ -100,32 +100,9 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+      StringBuilder builder = new StringBuilder();\n+    } else\n+\t\t;\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n@@ -161,7 +138,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1812/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:08:42.372684213 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SUB\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Replace", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return -1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1339/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:04:14.790348992 -0500\n@@ -105,27 +105,8 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+    } else\n+\t\t;\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n@@ -161,7 +142,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1339/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:04:14.790348992 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "return 0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_246/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:53:21.447095829 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1804/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:08:37.512697633 -0500\n@@ -99,26 +99,6 @@\n     // these cases when we visit the child, and the peephole passes will\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n-      Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -161,7 +141,6 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1804/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:08:37.516697622 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 102, 
          "faulty": "Node gramps=parent.getParent();", 
          "type": "Delete", 
          "seed": "traverseNodes(n);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1296/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:03:49.534648060 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1296/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:03:49.538648009 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1933/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:09:55.996528296 -0500\n@@ -100,25 +100,7 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+      StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1708/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:07:41.364886119 -0500\n@@ -100,25 +100,6 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -161,7 +142,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1708/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:07:41.368886105 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "int c=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_726/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:58:20.380437631 -0500\n@@ -105,27 +105,8 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+    } else\n+\t\t;\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1309/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:03:55.874569741 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -166,7 +154,8 @@\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n-        replacement.putBooleanProp(Node.FREE_CALL, true);\n+        StringBuilder builder = new StringBuilder();\n+\t\treplacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1309/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:03:55.878569692 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 169, 
          "faulty": "replacement.putBooleanProp(Node.FREE_CALL,true);", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_407/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:55:06.290705468 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -138,7 +126,6 @@\n       }\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n-        msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n         msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n             \"' operator is not being used.\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 141, 
          "faulty": "msg=\"Is there a missing '+' on the previous line?\";", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1517/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:05:52.825469900 -0500\n@@ -100,25 +100,6 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "break;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1344/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:04:17.250321653 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1344/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:04:17.250321653 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "break;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_600/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:57:05.621044556 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_600/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:57:05.625044516 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return new Node(Token.PARAM_LIST);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_610/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:57:11.144990095 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_610/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:57:11.148990055 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Replace", 
          "seed": "formatConclusion();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1327/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:04:07.278434396 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1327/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:04:07.282434350 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1489/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:05:38.349575282 -0500\n@@ -100,24 +100,10 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n+      // This no-op statement was there so that JSDoc information could\n     // be attached to the name. This check should not complain about it.\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n+        int start = 0;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "InsertBefore", 
          "seed": "break;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "InsertBefore", 
          "seed": "return toDot(n,null);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1131/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:02:13.751797329 -0500\n@@ -109,15 +109,6 @@\n     // This no-op statement was there so that JSDoc information could\n     // be attached to the name. This check should not complain about it.\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n@@ -138,7 +129,6 @@\n       }\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n-        msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n         msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n             \"' operator is not being used.\";\n@@ -161,7 +151,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1131/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:02:13.751797329 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 141, 
          "faulty": "msg=\"Is there a missing '+' on the previous line?\";", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1837/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:08:57.552644982 -0500\n@@ -106,26 +106,9 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+    StringBuilder builder = new StringBuilder();\n+    } else\n+\t\t;\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1837/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:08:57.556644972 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int type=n.getType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_381/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:54:49.391030800 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_551/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:56:39.229328854 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_551/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:56:39.229328854 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return new Node(Token.PARAM_LIST);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1434/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:05:08.041821404 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1434/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:05:08.045821368 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "formatPreamble();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 113, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1646/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:07:03.549052593 -0500\n@@ -100,25 +100,7 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_70/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:51:11.117483358 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -180,7 +166,6 @@\n     Node var = IR.var(name);\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n-    builder.recordNoAlias();\n     var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 183, 
          "faulty": "builder.recordNoAlias();", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1600/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:06:40.465172402 -0500\n@@ -100,25 +100,7 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+      StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1600/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:06:40.469172380 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SUB\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int keyParent=key(parent);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1065/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:01:34.323812607 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1666/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:07:16.456991805 -0500\n@@ -100,24 +100,10 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n+      // This no-op statement was there so that JSDoc information could\n     // be attached to the name. This check should not complain about it.\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n+        int start = 0;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n@@ -161,7 +147,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      int start = 0;\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1666/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:07:16.456991805 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SUB\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_326/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:54:12.198471041 -0500\n@@ -114,18 +114,13 @@\n           if (ancestorType == Token.COMMA)\n             continue;\n           if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n+\t\t\t;\n+\t\telse\n             break;\n         }\n       }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+    } else\n+\t\t;\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_560/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:56:43.941275062 -0500\n@@ -106,26 +106,9 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+    StringBuilder builder = new StringBuilder();\n+    } else\n+\t\t;\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n@@ -181,7 +164,6 @@\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 184, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1187/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:02:46.055488257 -0500\n@@ -106,26 +106,9 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+    StringBuilder builder = new StringBuilder();\n+    } else\n+\t\t;\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n@@ -170,7 +153,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 173, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_755/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:58:36.364340514 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_755/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:58:36.364340514 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "StringBuilder s=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1963/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:10:15.320500348 -0500\n@@ -100,24 +100,10 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n+      // This no-op statement was there so that JSDoc information could\n     // be attached to the name. This check should not complain about it.\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n+        int start = 0;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n@@ -138,7 +124,6 @@\n       }\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n-        msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n         msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n             \"' operator is not being used.\";\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1963/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:10:15.324500341 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 141, 
          "faulty": "msg=\"Is there a missing '+' on the previous line?\";", 
          "type": "Delete", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_383/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:54:50.207014479 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -138,10 +126,7 @@\n       }\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n-        msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n-        msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n-            \"' operator is not being used.\";\n       }\n \n       t.getCompiler().report(\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 141, 
          "faulty": "msg=\"Is there a missing '+' on the previous line?\";", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 143, 
          "faulty": "msg=\"The result of the '\" + Token.name(n.getType()).toLowerCase() + \"' operator is not being used.\";", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1704/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:07:39.604893109 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -181,7 +167,8 @@\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n+    final String PARAM_NAME = \"jscomp_throw_param\";\n+\tvar.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1704/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:07:39.604893109 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 184, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"EMPTY\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_592/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:57:00.749093994 -0500\n@@ -109,15 +109,6 @@\n     // This no-op statement was there so that JSDoc information could\n     // be attached to the name. This check should not complain about it.\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "return 0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1237/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:03:14.915089357 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1237/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:03:14.915089357 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1796/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:08:32.648711494 -0500\n@@ -100,32 +100,8 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+    } else\n+\t\t;\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n@@ -161,7 +137,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n@@ -180,7 +156,6 @@\n     Node var = IR.var(name);\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n-    builder.recordNoAlias();\n     var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1796/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:08:32.652711483 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SUB\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Replace", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 183, 
          "faulty": "builder.recordNoAlias();", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_861/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:59:38.412052730 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_861/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:59:38.416052716 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1414/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:04:56.869921493 -0500\n@@ -106,26 +106,9 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+    StringBuilder builder = new StringBuilder();\n+    } else\n+\t\t;\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1414/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:04:56.869921493 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_945/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:00:26.863911787 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -140,8 +126,6 @@\n       if (n.isString()) {\n         msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n-        msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n-            \"' operator is not being used.\";\n       }\n \n       t.getCompiler().report(\n@@ -164,7 +148,7 @@\n       addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n+        StringBuilder builder = new StringBuilder();\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 167, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "JSType type=n.getJSType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 143, 
          "faulty": "msg=\"The result of the '\" + Token.name(n.getType()).toLowerCase() + \"' operator is not being used.\";", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1634/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:06:57.949080316 -0500\n@@ -100,25 +100,7 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+      StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -161,7 +143,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1634/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:06:57.949080316 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "return 0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1229/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:03:10.151151673 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -164,7 +152,7 @@\n       addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n+        StringBuilder builder = new StringBuilder();\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 167, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 113, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1732/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:07:55.088834002 -0500\n@@ -100,24 +100,10 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n+      // This no-op statement was there so that JSDoc information could\n     // be attached to the name. This check should not complain about it.\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n+        int start = 0;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_81/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:51:18.933510727 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1596/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:06:38.821181502 -0500\n@@ -100,25 +100,9 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -161,7 +145,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1596/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:06:38.825181480 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1583/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:06:30.953226160 -0500\n@@ -100,24 +100,10 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n+      // This no-op statement was there so that JSDoc information could\n     // be attached to the name. This check should not complain about it.\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n+        int start = 0;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1583/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:06:30.957226137 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1644/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:07:02.765056425 -0500\n@@ -100,25 +100,6 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -161,7 +142,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1644/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:07:02.769056404 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SUB\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 113, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1151/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:02:25.243797940 -0500\n@@ -106,26 +106,9 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+    StringBuilder builder = new StringBuilder();\n+    } else\n+\t\t;\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n@@ -170,7 +153,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 173, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1870/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:09:16.820600757 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1870/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:09:16.820600757 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int type=n.getType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_622/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:57:18.340921645 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_622/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:57:18.340921645 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Replace", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Replace", 
          "seed": "break;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "JSType type=n.getJSType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_605/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:57:07.989020999 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1223/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:03:06.087205906 -0500\n@@ -105,27 +105,8 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+    } else\n+\t\t;\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n@@ -161,7 +142,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1223/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:03:06.091205852 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_287/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:53:47.660916351 -0500\n@@ -109,15 +109,6 @@\n     // This no-op statement was there so that JSDoc information could\n     // be attached to the name. This check should not complain about it.\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n@@ -163,7 +154,8 @@\n     if (!problemNodes.isEmpty()) {\n       addExtern();\n       for (Node n : problemNodes) {\n-        Node name = IR.name(PROTECTOR_FN).srcref(n);\n+        int index = -1;\n+\t\tNode name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "Node name=IR.name(PROTECTOR_FN).srcref(n);", 
          "type": "InsertBefore", 
          "seed": "int index=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_864/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:59:40.076046771 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1739/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:07:58.248822587 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -161,7 +147,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      int start = 0;\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1739/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:07:58.248822587 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SUB\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_266/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:53:34.920053145 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "return new DefaultCodingConvention();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1556/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:06:15.133321624 -0500\n@@ -100,25 +100,7 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+      StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -161,7 +143,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1556/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:06:15.133321624 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1220/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:03:04.423228408 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -140,8 +128,6 @@\n       if (n.isString()) {\n         msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n-        msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n-            \"' operator is not being used.\";\n       }\n \n       t.getCompiler().report(\n@@ -161,7 +147,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n@@ -184,7 +170,8 @@\n     var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n-    compiler.reportCodeChange();\n+    final String PARAM_NAME = \"jscomp_throw_param\";\n+\tcompiler.reportCodeChange();\n   }\n \n   /**\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1220/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:03:04.423228408 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 143, 
          "faulty": "msg=\"The result of the '\" + Token.name(n.getType()).toLowerCase() + \"' operator is not being used.\";", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 187, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_920/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:00:11.879948467 -0500\n@@ -100,25 +100,6 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -161,7 +142,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_920/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:00:11.883948456 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "JSType type=n.getJSType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_943/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:00:26.027913680 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int keyParent=key(parent);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_667/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:57:44.308696896 -0500\n@@ -109,23 +109,9 @@\n     // This no-op statement was there so that JSDoc information could\n     // be attached to the name. This check should not complain about it.\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n       }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+    } else\n+\t\t;\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n@@ -164,7 +150,6 @@\n       addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_667/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:57:44.312696865 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              Node block = new Node(Token.BLOCK);\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 167, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "Node block=new Node(Token.BLOCK);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1323/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:04:05.586454040 -0500\n@@ -100,25 +100,7 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+      StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_553/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:56:40.013319805 -0500\n@@ -106,26 +106,9 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+    StringBuilder builder = new StringBuilder();\n+    } else\n+\t\t;\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "formatPreamble();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_720/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:58:16.448463122 -0500\n@@ -109,15 +109,6 @@\n     // This no-op statement was there so that JSDoc information could\n     // be attached to the name. This check should not complain about it.\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_720/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:58:16.448463122 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1507/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:05:47.125510501 -0500\n@@ -100,24 +100,10 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n+      // This no-op statement was there so that JSDoc information could\n     // be attached to the name. This check should not complain about it.\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n+        int start = 0;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1507/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:05:47.125510501 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1959/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:10:12.920503559 -0500\n@@ -100,25 +100,6 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -161,16 +142,18 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      int start = 0;\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n+        final String PARAM_NAME = \"jscomp_throw_param\";\n+\t\tname.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n+      StringBuilder builder = new StringBuilder();\n+\tcompiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1959/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:10:12.920503559 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SUB\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 167, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 173, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1153/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:02:26.031796931 -0500\n@@ -106,26 +106,9 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+    StringBuilder builder = new StringBuilder();\n+    } else\n+\t\t;\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n@@ -170,7 +153,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1153/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:02:26.031796931 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 173, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1559/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:06:16.853310867 -0500\n@@ -100,25 +100,7 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+      StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1559/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:06:16.853310867 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "formatPreamble();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 113, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_118/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:51:47.397610627 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1459/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:05:20.597715078 -0500\n@@ -100,24 +100,10 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n+      // This no-op statement was there so that JSDoc information could\n     // be attached to the name. This check should not complain about it.\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n+        int start = 0;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "InsertBefore", 
          "seed": "break;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1163/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:02:31.795705256 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -161,7 +147,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1163/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:02:31.795705256 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1925/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:09:51.124536121 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -140,8 +126,6 @@\n       if (n.isString()) {\n         msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n-        msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n-            \"' operator is not being used.\";\n       }\n \n       t.getCompiler().report(\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1925/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:09:51.124536121 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 143, 
          "faulty": "msg=\"The result of the '\" + Token.name(n.getType()).toLowerCase() + \"' operator is not being used.\";", 
          "type": "Delete", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1165/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:02:32.587692844 -0500\n@@ -99,26 +99,13 @@\n     // these cases when we visit the child, and the peephole passes will\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n-      Node gramps = parent.getParent();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n+\tNode gramps = parent.getParent();\n       if (gramps.isCall() && parent == gramps.getFirstChild()) {\n         if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 102, 
          "faulty": "Node gramps=parent.getParent();", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_780/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:58:50.788261460 -0500\n@@ -106,26 +106,9 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+    StringBuilder builder = new StringBuilder();\n+    } else\n+\t\t;\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_223/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:53:04.905854456 -0500\n@@ -109,15 +109,6 @@\n     // This no-op statement was there so that JSDoc information could\n     // be attached to the name. This check should not complain about it.\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1747/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:08:02.596807225 -0500\n@@ -100,32 +100,9 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+      StringBuilder builder = new StringBuilder();\n+    } else\n+\t\t;\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1747/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:08:02.600807210 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1747/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:08:02.600807210 -0500\n@@ -3121,19 +3121,17 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        {\n+\t\t\tint start = 0;\n+\t\t\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n+\t\t\t\tif (expr == parent.getFirstChild()\n+\t\t\t\t\t\t&& parent.getChildCount() == 2\n+\t\t\t\t\t\t&& expr.getNext().isName()\n+\t\t\t\t\t\t&& \"eval\".equals(expr.getNext().getString())) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "break;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 113, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1216/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:03:01.995261531 -0500\n@@ -106,26 +106,9 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+    StringBuilder builder = new StringBuilder();\n+    } else\n+\t\t;\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1216/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:03:01.995261531 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1794/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:08:31.696714258 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -161,7 +149,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n@@ -180,7 +168,6 @@\n     Node var = IR.var(name);\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n-    builder.recordNoAlias();\n     var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1794/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:08:31.696714258 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SUB\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Replace", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 183, 
          "faulty": "builder.recordNoAlias();", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1410/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:04:54.333944959 -0500\n@@ -100,25 +100,6 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -161,7 +142,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1410/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:04:54.337944922 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "formatPreamble();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 113, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_368/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:54:41.171198725 -0500\n@@ -111,11 +111,9 @@\n       if (n == parent.getLastChild()) {\n         for (Node an : parent.getAncestors()) {\n           int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n           if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n+\t\t\t;\n+\t\telse\n             break;\n         }\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_477/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:55:55.761893138 -0500\n@@ -109,15 +109,6 @@\n     // This no-op statement was there so that JSDoc information could\n     // be attached to the name. This check should not complain about it.\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_536/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:56:30.329434214 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_955/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:00:32.443899601 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_955/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:00:32.443899601 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_215/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:52:59.277414638 -0500\n@@ -100,32 +100,16 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n+      int index = -1;\n+\tif (gramps.isCall() && parent == gramps.getFirstChild()) {\n         if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n       return;\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+    StringBuilder builder = new StringBuilder();\n+    } else\n+\t\t;\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "InsertBefore", 
          "seed": "formatPreamble();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1499/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:05:43.149539505 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -176,7 +162,8 @@\n \n   private void addExtern() {\n     Node name = IR.name(PROTECTOR_FN);\n-    name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n+    final String PARAM_NAME = \"jscomp_throw_param\";\n+\tname.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n     Node var = IR.var(name);\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "break;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 179, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_631/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:57:23.844871141 -0500\n@@ -106,26 +106,9 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+    StringBuilder builder = new StringBuilder();\n+    } else\n+\t\t;\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "formatPreamble();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_564/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:56:46.369247879 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -164,7 +150,6 @@\n       addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_564/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:56:46.373247834 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              Node block = new Node(Token.BLOCK);\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 167, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "Node block=new Node(Token.BLOCK);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1252/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:03:23.770977048 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -161,7 +147,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1252/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:03:23.770977048 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_65/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:51:07.893468617 -0500\n@@ -106,7 +106,8 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n+    int type = n.getType();\n+\t// This no-op statement was there so that JSDoc information could\n     // be attached to the name. This check should not complain about it.\n       if (n == parent.getLastChild()) {\n         for (Node an : parent.getAncestors()) {\n@@ -114,8 +115,8 @@\n           if (ancestorType == Token.COMMA)\n             continue;\n           if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n+\t\t\t;\n+\t\telse\n             break;\n         }\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1612/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:06:46.909137467 -0500\n@@ -100,25 +100,6 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "return 0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_538/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:56:31.121424632 -0500\n@@ -106,26 +106,9 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+    StringBuilder builder = new StringBuilder();\n+    } else\n+\t\t;\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n@@ -180,7 +163,6 @@\n     Node var = IR.var(name);\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n-    builder.recordNoAlias();\n     var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 183, 
          "faulty": "builder.recordNoAlias();", 
          "type": "Delete", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1452/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:05:17.465741008 -0500\n@@ -100,32 +100,9 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+      StringBuilder builder = new StringBuilder();\n+    } else\n+\t\t;\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n@@ -161,7 +138,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1452/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:05:17.465741008 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_531/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:56:27.221472188 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "return new DefaultCodingConvention();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1587/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:06:33.317212553 -0500\n@@ -100,25 +100,6 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -161,7 +142,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1587/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:06:33.321212530 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "formatPreamble();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 113, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_225/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:53:05.701915915 -0500\n@@ -109,15 +109,6 @@\n     // This no-op statement was there so that JSDoc information could\n     // be attached to the name. This check should not complain about it.\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "traverseNodes(n);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_889/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:59:55.247996266 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -161,7 +147,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_889/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:59:55.251996253 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_587/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:56:58.241119969 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -164,7 +150,6 @@\n       addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 167, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_527/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:56:25.597492282 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -164,7 +150,6 @@\n       addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 167, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1672/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:07:19.676977298 -0500\n@@ -100,25 +100,6 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -161,7 +142,6 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1672/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:07:19.676977298 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1257/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:03:26.130947876 -0500\n@@ -106,26 +106,9 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+    StringBuilder builder = new StringBuilder();\n+    } else\n+\t\t;\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n@@ -170,7 +153,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1257/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:03:26.130947876 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 173, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1668/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:07:17.240988249 -0500\n@@ -100,25 +100,6 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -161,7 +142,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n@@ -180,7 +161,6 @@\n     Node var = IR.var(name);\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n-    builder.recordNoAlias();\n     var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1668/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:07:17.240988249 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SUB\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Replace", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 183, 
          "faulty": "builder.recordNoAlias();", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1456/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:05:19.033727973 -0500\n@@ -100,25 +100,6 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -161,7 +142,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1456/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:05:19.033727973 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "formatPreamble();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 113, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 113, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "InsertBefore", 
          "seed": "JSType type=n.getJSType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1088/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:01:47.323804447 -0500\n@@ -100,25 +100,7 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+      StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -184,7 +166,6 @@\n     var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n-    compiler.reportCodeChange();\n   }\n \n   /**\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1088/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:01:47.323804447 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "JSType type=n.getJSType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 187, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_264/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:53:34.131998428 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -168,7 +154,8 @@\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n-        replacement.addChildToBack(n);\n+        StringBuilder builder = new StringBuilder();\n+\t\treplacement.addChildToBack(n);\n       }\n       compiler.reportCodeChange();\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 171, 
          "faulty": "replacement.addChildToBack(n);", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Replace", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1832/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:08:54.360652901 -0500\n@@ -100,32 +100,8 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+    } else\n+\t\t;\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n@@ -161,7 +137,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n@@ -180,7 +156,6 @@\n     Node var = IR.var(name);\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n-    builder.recordNoAlias();\n     var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1832/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:08:54.364652892 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SUB\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Replace", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 183, 
          "faulty": "builder.recordNoAlias();", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_654/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:57:37.832749791 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 113, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_698/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:58:02.068561984 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_502/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:56:11.493674120 -0500\n@@ -106,26 +106,9 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+    StringBuilder builder = new StringBuilder();\n+    } else\n+\t\t;\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n@@ -180,7 +163,6 @@\n     Node var = IR.var(name);\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n-    builder.recordNoAlias();\n     var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 183, 
          "faulty": "builder.recordNoAlias();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_873/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:59:45.644027444 -0500\n@@ -109,15 +109,6 @@\n     // This no-op statement was there so that JSDoc information could\n     // be attached to the name. This check should not complain about it.\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_339/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:54:21.827044635 -0500\n@@ -109,15 +109,6 @@\n     // This no-op statement was there so that JSDoc information could\n     // be attached to the name. This check should not complain about it.\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 113, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "InsertBefore", 
          "seed": "break;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_813/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:59:12.388157307 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_813/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:59:12.388157307 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1006/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:01:00.239850064 -0500\n@@ -88,7 +88,8 @@\n     // so we'll allow it.\n     if (n.isEmpty() ||\n         n.isComma()) {\n-      return;\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n+\treturn;\n     }\n \n     if (parent == null) {\n@@ -105,20 +106,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -161,7 +148,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n@@ -182,7 +169,8 @@\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n     var.setJSDocInfo(builder.build(var));\n-    CompilerInput input = compiler.getSynthesizedExternsInput();\n+    final String PARAM_NAME = \"jscomp_throw_param\";\n+\tCompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n   }\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1006/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:01:00.243850058 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 91, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 185, 
          "faulty": "CompilerInput input=compiler.getSynthesizedExternsInput();", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_639/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:57:29.012825151 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_639/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:57:29.012825151 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              StringBuilder s = new StringBuilder();\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "StringBuilder s=new StringBuilder();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1770/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:08:16.852759589 -0500\n@@ -100,25 +100,7 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+      StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -161,7 +143,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1770/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:08:16.852759589 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1155/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:02:26.815784337 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_100/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:51:33.537561939 -0500\n@@ -109,15 +109,6 @@\n     // This no-op statement was there so that JSDoc information could\n     // be attached to the name. This check should not complain about it.\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1389/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:04:43.182051508 -0500\n@@ -105,27 +105,8 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+    } else\n+\t\t;\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n@@ -170,7 +151,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 173, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "break;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1544/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:06:08.805362014 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1544/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:06:08.809361988 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SUB\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1381/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:04:38.418098743 -0500\n@@ -100,25 +100,7 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+      StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1250/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:03:22.806989054 -0500\n@@ -106,26 +106,9 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+    StringBuilder builder = new StringBuilder();\n+    } else\n+\t\t;\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1250/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:03:22.814988953 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1351/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:04:21.018280367 -0500\n@@ -100,25 +100,7 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+      StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -161,7 +143,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1351/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:04:21.022280323 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1606/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:06:43.661154929 -0500\n@@ -100,25 +100,7 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+      StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -161,7 +143,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1606/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:06:43.665154906 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1425/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:05:02.457870773 -0500\n@@ -105,27 +105,8 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+    } else\n+\t\t;\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n@@ -170,7 +151,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 173, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "break;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1856/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:09:08.692618679 -0500\n@@ -106,26 +106,9 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+    StringBuilder builder = new StringBuilder();\n+    } else\n+\t\t;\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n@@ -161,7 +144,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1856/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:09:08.692618679 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Replace", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Replace", 
          "seed": "return new DotFormatter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1113/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:02:02.279798916 -0500\n@@ -106,26 +106,9 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+    StringBuilder builder = new StringBuilder();\n+    } else\n+\t\t;\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n@@ -170,7 +153,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 173, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1420/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:05:00.093892065 -0500\n@@ -100,25 +100,7 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+      StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -161,7 +143,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1420/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:05:00.097892030 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "formatPreamble();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 113, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_849/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:59:31.888076912 -0500\n@@ -106,26 +106,9 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+    StringBuilder builder = new StringBuilder();\n+    } else\n+\t\t;\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1104/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:01:56.871800452 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1104/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:01:56.875800452 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1696/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:07:34.832912412 -0500\n@@ -100,25 +100,7 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+      StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1696/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:07:34.832912412 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "int c=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_572/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:56:50.329204292 -0500\n@@ -100,25 +100,6 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -181,7 +162,6 @@\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "break;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 113, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "InsertBefore", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 184, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1438/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:05:10.405800899 -0500\n@@ -100,24 +100,10 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n+      // This no-op statement was there so that JSDoc information could\n     // be attached to the name. This check should not complain about it.\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n+        int start = 0;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n@@ -163,7 +149,8 @@\n     if (!problemNodes.isEmpty()) {\n       addExtern();\n       for (Node n : problemNodes) {\n-        Node name = IR.name(PROTECTOR_FN).srcref(n);\n+        int start = 0;\n+\t\tNode name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 166, 
          "faulty": "Node name=IR.name(PROTECTOR_FN).srcref(n);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1526/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:05:57.717435957 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1526/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:05:57.721435930 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "formatPreamble();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 113, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1701/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:07:38.028899425 -0500\n@@ -100,25 +100,7 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+      StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1701/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:07:38.032899408 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1495/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:05:41.501551695 -0500\n@@ -100,32 +100,9 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+      StringBuilder builder = new StringBuilder();\n+    } else\n+\t\t;\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n@@ -161,7 +138,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1495/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:05:41.505551666 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1474/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:05:29.521643303 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "break;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_2/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:50:18.800874157 -0500\n@@ -114,8 +114,8 @@\n           if (ancestorType == Token.COMMA)\n             continue;\n           if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n+\t\t\t;\n+\t\telse\n             break;\n         }\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1784/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:08:25.840731636 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1784/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:08:25.844731625 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_836/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:59:24.580105594 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_836/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:59:24.580105594 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_926/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:00:15.939937947 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -180,8 +166,7 @@\n     Node var = IR.var(name);\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n-    builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n+    int start = 0;\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 184, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 183, 
          "faulty": "builder.recordNoAlias();", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1018/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:01:06.571841252 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -165,7 +153,8 @@\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n-        Node replacement = IR.call(name).srcref(n);\n+        int index = -1;\n+\t\tNode replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1018/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:01:06.575841248 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 168, 
          "faulty": "Node replacement=IR.call(name).srcref(n);", 
          "type": "InsertBefore", 
          "seed": "int index=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_772/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:58:45.928287214 -0500\n@@ -100,32 +100,20 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+      StringBuilder builder = new StringBuilder();\n+    } else {\n+\t\tint start = 0;\n+\t\tif (parent.getType() != Token.EXPR_RESULT\n+\t\t\t\t&& parent.getType() != Token.BLOCK) {\n+\t\t\tif (parent.getType() == Token.FOR\n+\t\t\t\t\t&& parent.getChildCount() == 4\n+\t\t\t\t\t&& (n == parent.getFirstChild() || n == parent\n+\t\t\t\t\t\t\t.getFirstChild().getNext().getNext())) {\n+\t\t\t} else {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\t}\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n@@ -140,8 +128,6 @@\n       if (n.isString()) {\n         msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n-        msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n-            \"' operator is not being used.\";\n       }\n \n       t.getCompiler().report(\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_772/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:58:45.928287214 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Replace", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 143, 
          "faulty": "msg=\"The result of the '\" + Token.name(n.getType()).toLowerCase() + \"' operator is not being used.\";", 
          "type": "Delete", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1117/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:02:04.699798394 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_61/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:51:05.505450887 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1745/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:08:01.540810918 -0500\n@@ -100,25 +100,6 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -161,7 +142,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1745/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:08:01.544810905 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "formatPreamble();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 113, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Replace", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "JSType type=n.getJSType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1127/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:02:11.211797487 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1127/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:02:11.211797487 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Replace", 
          "seed": "int keyParent=key(parent);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1485/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:05:36.697587790 -0500\n@@ -100,24 +100,9 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n+      // This no-op statement was there so that JSDoc information could\n     // be attached to the name. This check should not complain about it.\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1485/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:05:36.697587790 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "formatPreamble();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 113, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_469/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:55:50.205974761 -0500\n@@ -100,25 +100,7 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+      StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_469/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:55:50.209974701 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1125/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:02:10.423797558 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_735/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:58:25.172407429 -0500\n@@ -100,25 +100,7 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+      StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_735/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:58:25.172407429 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1442/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:05:11.961787522 -0500\n@@ -100,24 +100,10 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n+      // This no-op statement was there so that JSDoc information could\n     // be attached to the name. This check should not complain about it.\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n+        int start = 0;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1303/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:03:52.734608252 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_971/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:00:41.211882003 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -161,7 +147,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n@@ -180,8 +166,7 @@\n     Node var = IR.var(name);\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n-    builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n+    int start = 0;\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_971/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:00:41.211882003 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 184, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 183, 
          "faulty": "builder.recordNoAlias();", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_696/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:58:01.296567552 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_696/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:58:01.296567552 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 113, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1883/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:09:24.808584150 -0500\n@@ -100,24 +100,10 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n+      // This no-op statement was there so that JSDoc information could\n     // be attached to the name. This check should not complain about it.\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n+        int start = 0;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n@@ -161,16 +147,18 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      int start = 0;\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n+        final String PARAM_NAME = \"jscomp_throw_param\";\n+\t\tname.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n+      StringBuilder builder = new StringBuilder();\n+\tcompiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1883/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:09:24.808584150 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SUB\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 167, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 173, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1532/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:06:01.673409104 -0500\n@@ -100,25 +100,7 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+      StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1532/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:06:01.673409104 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "InsertBefore", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1910/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:09:43.040549819 -0500\n@@ -100,25 +100,6 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -161,7 +142,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n@@ -180,7 +161,6 @@\n     Node var = IR.var(name);\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n-    builder.recordNoAlias();\n     var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1910/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:09:43.044549812 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SUB\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Replace", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 183, 
          "faulty": "builder.recordNoAlias();", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "this.level=level;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1725/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:07:51.912845694 -0500\n@@ -106,26 +106,9 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+    StringBuilder builder = new StringBuilder();\n+    } else\n+\t\t;\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n@@ -161,7 +144,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1725/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:07:51.916845680 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int type=n.getType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1944/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:10:02.372518539 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1976/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:10:23.356490111 -0500\n@@ -100,24 +100,10 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n+      // This no-op statement was there so that JSDoc information could\n     // be attached to the name. This check should not complain about it.\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n+        int start = 0;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1976/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:10:23.356490111 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1829/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:08:52.740656987 -0500\n@@ -100,25 +100,6 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -161,7 +142,6 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n@@ -180,7 +160,6 @@\n     Node var = IR.var(name);\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n-    builder.recordNoAlias();\n     var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1829/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:08:52.744656977 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SUB\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Replace", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 183, 
          "faulty": "builder.recordNoAlias();", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_948/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:00:28.475908189 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_948/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:00:28.479908178 -0500\n@@ -3121,19 +3121,7 @@\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n         Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        ;\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1244/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:03:18.823039237 -0500\n@@ -100,25 +100,6 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -161,7 +142,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1244/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:03:18.823039237 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_965/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:00:37.899888430 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_965/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:00:37.899888430 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1817/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:08:44.760677773 -0500\n@@ -100,25 +100,6 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -161,10 +142,11 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      int start = 0;\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n+        final String PARAM_NAME = \"jscomp_throw_param\";\n+\t\tname.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1817/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:08:44.760677773 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SUB\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 167, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_913/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:00:07.887959243 -0500\n@@ -109,15 +109,6 @@\n     // This no-op statement was there so that JSDoc information could\n     // be attached to the name. This check should not complain about it.\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n@@ -181,7 +172,8 @@\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n+    int index = -1;\n+\tvar.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_913/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:00:07.887959243 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 184, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "InsertBefore", 
          "seed": "int index=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_999/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:00:57.007854902 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_999/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:00:57.007854902 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 113, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "JSType type=n.getJSType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_318/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:54:08.194226610 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_852/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:59:33.508070786 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_852/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:59:33.508070786 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1664/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:07:15.668995393 -0500\n@@ -100,25 +100,6 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -161,7 +142,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1664/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:07:15.668995393 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "formatPreamble();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 113, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Replace", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "JSType type=n.getJSType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1301/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:03:51.954617898 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -164,7 +152,7 @@\n       addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n+        StringBuilder builder = new StringBuilder();\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 167, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 113, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_566/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:56:47.157239128 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    int index = -1;\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -164,7 +152,6 @@\n       addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 167, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_911/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:00:07.099961421 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_911/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:00:07.103961411 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int keyParent=key(parent);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1942/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:10:01.588519711 -0500\n@@ -100,25 +100,7 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+      StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -170,7 +152,8 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n+      StringBuilder builder = new StringBuilder();\n+\tcompiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1942/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:10:01.588519711 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 173, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_937/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:00:22.087922845 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -161,7 +147,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n@@ -181,7 +167,7 @@\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n+    int start = 0;\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_937/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:00:22.087922845 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 184, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1632/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:06:57.157084306 -0500\n@@ -100,25 +100,6 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -161,7 +142,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1632/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:06:57.157084306 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1937/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:09:58.440524494 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -170,7 +158,8 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n+      StringBuilder builder = new StringBuilder();\n+\tcompiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1937/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:09:58.444524488 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 173, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_509/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:56:15.489621243 -0500\n@@ -109,15 +109,6 @@\n     // This no-op statement was there so that JSDoc information could\n     // be attached to the name. This check should not complain about it.\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Replace", 
          "seed": "return 0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1430/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:05:05.629842572 -0500\n@@ -106,26 +106,9 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+    StringBuilder builder = new StringBuilder();\n+    } else\n+\t\t;\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n@@ -161,7 +144,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1430/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:05:05.633842537 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1515/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:05:51.981475839 -0500\n@@ -100,25 +100,7 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+      StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1515/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:05:51.985475810 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SUB\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1782/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:08:24.868734584 -0500\n@@ -100,25 +100,6 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -161,7 +142,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n@@ -180,7 +161,6 @@\n     Node var = IR.var(name);\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n-    builder.recordNoAlias();\n     var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1782/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:08:24.868734584 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SUB\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Replace", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 183, 
          "faulty": "builder.recordNoAlias();", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_150/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:52:10.269691144 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -168,7 +154,8 @@\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n-        replacement.addChildToBack(n);\n+        StringBuilder builder = new StringBuilder();\n+\t\treplacement.addChildToBack(n);\n       }\n       compiler.reportCodeChange();\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "JSType type=n.getJSType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 171, 
          "faulty": "replacement.addChildToBack(n);", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_568/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:56:47.941230459 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_568/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:56:47.945230416 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_284/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:53:46.040808802 -0500\n@@ -111,11 +111,12 @@\n       if (n == parent.getLastChild()) {\n         for (Node an : parent.getAncestors()) {\n           int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n+          int type = n.getType();\n+\t\tif (ancestorType == Token.COMMA)\n             continue;\n           if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n+\t\t\t;\n+\t\telse\n             break;\n         }\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_403/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:55:03.894750003 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_577/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:56:52.729178328 -0500\n@@ -109,23 +109,9 @@\n     // This no-op statement was there so that JSDoc information could\n     // be attached to the name. This check should not complain about it.\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n       }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+    } else\n+\t\t;\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Replace", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "traverseNodes(n);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1522/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:05:55.325452453 -0500\n@@ -100,32 +100,19 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+    } else {\n+\t\tint start = 0;\n+\t\tif (parent.getType() != Token.EXPR_RESULT\n+\t\t\t\t&& parent.getType() != Token.BLOCK) {\n+\t\t\tif (parent.getType() == Token.FOR\n+\t\t\t\t\t&& parent.getChildCount() == 4\n+\t\t\t\t\t&& (n == parent.getFirstChild() || n == parent\n+\t\t\t\t\t\t\t.getFirstChild().getNext().getNext())) {\n+\t\t\t} else {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\t}\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n@@ -161,7 +148,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1522/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:05:55.325452453 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "formatPreamble();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 113, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_909/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:00:06.299963653 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -161,7 +147,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_909/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:00:06.299963653 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "InsertBefore", 
          "seed": "int keyParent=key(parent);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1718/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:07:47.664861680 -0500\n@@ -100,25 +100,6 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -161,7 +142,6 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1718/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:07:47.664861680 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1549/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:06:11.193346620 -0500\n@@ -100,25 +100,6 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1016/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:01:05.779842307 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1397/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:04:48.034004463 -0500\n@@ -100,24 +100,10 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n+      // This no-op statement was there so that JSDoc information could\n     // be attached to the name. This check should not complain about it.\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n+        int start = 0;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1619/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:06:50.049120870 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1619/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:06:50.053120849 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SUB\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_821/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:59:16.428139625 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_821/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:59:16.428139625 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1288/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:03:44.738708802 -0500\n@@ -105,27 +105,8 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+    } else\n+\t\t;\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n@@ -170,7 +151,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 173, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "break;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_589/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:56:59.021111847 -0500\n@@ -109,23 +109,9 @@\n     // This no-op statement was there so that JSDoc information could\n     // be attached to the name. This check should not complain about it.\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n       }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+    } else\n+\t\t;\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n@@ -161,7 +147,6 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_990/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:00:52.247862462 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_990/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:00:52.247862462 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_801/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:59:05.080190704 -0500\n@@ -106,26 +106,9 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+    StringBuilder builder = new StringBuilder();\n+    } else\n+\t\t;\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_385/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:54:50.994998775 -0500\n@@ -114,8 +114,8 @@\n           if (ancestorType == Token.COMMA)\n             continue;\n           if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n+\t\t\t;\n+\t\telse\n             break;\n         }\n       }\n@@ -178,7 +178,8 @@\n     Node name = IR.name(PROTECTOR_FN);\n     name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n     Node var = IR.var(name);\n-    // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n+    final String PARAM_NAME = \"jscomp_throw_param\";\n+\t// Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n     var.setJSDocInfo(builder.build(var));\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 182, 
          "faulty": "JSDocInfoBuilder builder=new JSDocInfoBuilder(false);", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_776/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:58:48.288274599 -0500\n@@ -106,26 +106,9 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+    StringBuilder builder = new StringBuilder();\n+    } else\n+\t\t;\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n@@ -138,7 +121,6 @@\n       }\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n-        msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n         msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n             \"' operator is not being used.\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 141, 
          "faulty": "msg=\"Is there a missing '+' on the previous line?\";", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_711/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:58:10.028506149 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_711/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:58:10.032506122 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Replace", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Replace", 
          "seed": "break;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "JSType type=n.getJSType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1840/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:08:59.000641445 -0500\n@@ -106,26 +106,20 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+    StringBuilder builder = new StringBuilder();\n+    } else {\n+\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\tif (parent.getType() != Token.EXPR_RESULT\n+\t\t\t\t&& parent.getType() != Token.BLOCK) {\n+\t\t\tif (parent.getType() == Token.FOR\n+\t\t\t\t\t&& parent.getChildCount() == 4\n+\t\t\t\t\t&& (n == parent.getFirstChild() || n == parent\n+\t\t\t\t\t\t\t.getFirstChild().getNext().getNext())) {\n+\t\t\t} else {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\t}\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n@@ -161,7 +155,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n@@ -184,7 +178,6 @@\n     var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n-    compiler.reportCodeChange();\n   }\n \n   /**\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1840/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:08:59.004641435 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int type=n.getType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 187, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_449/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:55:37.434171240 -0500\n@@ -106,26 +106,9 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+    StringBuilder builder = new StringBuilder();\n+    } else\n+\t\t;\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_647/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:57:33.780783932 -0500\n@@ -100,25 +100,6 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_647/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:57:33.780783932 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_320/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:54:08.982275007 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_152/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:52:11.081694006 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -176,7 +162,6 @@\n \n   private void addExtern() {\n     Node name = IR.name(PROTECTOR_FN);\n-    name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n     Node var = IR.var(name);\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "JSType type=n.getJSType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 179, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "Delete", 
          "seed": "return 0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_29/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:50:40.217212165 -0500\n@@ -114,8 +114,8 @@\n           if (ancestorType == Token.COMMA)\n             continue;\n           if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n+\t\t\t;\n+\t\telse\n             break;\n         }\n       }\n@@ -184,7 +184,6 @@\n     var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n-    compiler.reportCodeChange();\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 187, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "formatPreamble();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_427/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:55:20.742447463 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_877/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:59:48.044019398 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -161,7 +147,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_877/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:59:48.048019384 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1406/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:04:51.997966814 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1406/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:04:52.001966777 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "break;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_996/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:00:55.431857350 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -164,7 +150,7 @@\n       addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n+        StringBuilder builder = new StringBuilder();\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n@@ -180,7 +166,6 @@\n     Node var = IR.var(name);\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n-    builder.recordNoAlias();\n     var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 167, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 183, 
          "faulty": "builder.recordNoAlias();", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_269/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:53:36.496162081 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "traverseNodes(n);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_324/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:54:11.410423203 -0500\n@@ -112,10 +112,10 @@\n         for (Node an : parent.getAncestors()) {\n           int ancestorType = an.getType();\n           if (ancestorType == Token.COMMA)\n-            continue;\n+\t\t\t;\n           if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n+\t\t\t;\n+\t\telse\n             break;\n         }\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1866/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:09:14.316606166 -0500\n@@ -100,25 +100,7 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+      StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -138,7 +120,6 @@\n       }\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n-        msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n         msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n             \"' operator is not being used.\";\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1866/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:09:14.320606157 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 141, 
          "faulty": "msg=\"Is there a missing '+' on the previous line?\";", 
          "type": "Delete", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_973/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:00:41.999880511 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -161,7 +149,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n@@ -180,8 +168,7 @@\n     Node var = IR.var(name);\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n-    builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n+    int start = 0;\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_973/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:00:42.003880503 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 184, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 183, 
          "faulty": "builder.recordNoAlias();", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1454/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:05:18.249734479 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -161,7 +147,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n@@ -183,7 +169,6 @@\n     builder.recordNoAlias();\n     var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n-    input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1454/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:05:18.249734479 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "formatPreamble();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 113, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 186, 
          "faulty": "input.getAstRoot(compiler).addChildrenToBack(var);", 
          "type": "Delete", 
          "seed": "formatPreamble();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1623/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:06:52.393108662 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -161,7 +147,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n@@ -181,7 +167,8 @@\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n+    final String PARAM_NAME = \"jscomp_throw_param\";\n+\tvar.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 184, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1012/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:01:03.379845584 -0500\n@@ -100,25 +100,7 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+      StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -161,7 +143,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1012/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:01:03.383845580 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "JSType type=n.getJSType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Replace", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_260/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:53:31.767833338 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -138,7 +124,8 @@\n       }\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n-        msg = \"Is there a missing '+' on the previous line?\";\n+        int index = -1;\n+\t\tmsg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n         msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n             \"' operator is not being used.\";\n@@ -168,7 +155,8 @@\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n-        replacement.addChildToBack(n);\n+        StringBuilder builder = new StringBuilder();\n+\t\treplacement.addChildToBack(n);\n       }\n       compiler.reportCodeChange();\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "JSType type=n.getJSType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 171, 
          "faulty": "replacement.addChildToBack(n);", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Replace", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 141, 
          "faulty": "msg=\"Is there a missing '+' on the previous line?\";", 
          "type": "InsertBefore", 
          "seed": "int index=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_206/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:52:52.860902083 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -168,7 +154,8 @@\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n-        replacement.addChildToBack(n);\n+        StringBuilder builder = new StringBuilder();\n+\t\treplacement.addChildToBack(n);\n       }\n       compiler.reportCodeChange();\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "JSType type=n.getJSType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 171, 
          "faulty": "replacement.addChildToBack(n);", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Replace", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1568/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:06:22.261277655 -0500\n@@ -100,25 +100,6 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_663/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:57:42.644710295 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_663/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:57:42.644710295 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1360/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:04:25.786229144 -0500\n@@ -100,25 +100,7 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+      StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1360/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:04:25.790229101 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "InsertBefore", 
          "seed": "int keyParent=key(parent);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1743/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:08:00.660814016 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1743/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:08:00.664814001 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Replace", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1330/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:04:08.962414992 -0500\n@@ -106,26 +106,9 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+    StringBuilder builder = new StringBuilder();\n+    } else\n+\t\t;\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n@@ -161,7 +144,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1330/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:04:08.962414992 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1024/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:01:09.779837120 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1024/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:01:09.779837120 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1819/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:08:45.548675671 -0500\n@@ -106,26 +106,9 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+    StringBuilder builder = new StringBuilder();\n+    } else\n+\t\t;\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n@@ -161,7 +144,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1819/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:08:45.548675671 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "int type=n.getType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1255/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:03:25.342957585 -0500\n@@ -105,27 +105,8 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+    } else\n+\t\t;\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n@@ -170,7 +151,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 173, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "break;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_665/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:57:43.528703160 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -161,7 +149,6 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1263/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:03:29.246909845 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1263/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:03:29.246909845 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 113, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1179/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:02:41.299559108 -0500\n@@ -100,25 +100,7 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+      StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1179/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:02:41.303559048 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_574/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:56:51.117195726 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_574/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:56:51.117195726 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1683/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:07:26.904945665 -0500\n@@ -100,25 +100,6 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -161,7 +142,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1683/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:07:26.904945665 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "formatPreamble();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 113, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Replace", 
          "seed": "return new DotFormatter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_612/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:57:11.992981880 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "return 0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1879/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:09:23.192587430 -0500\n@@ -100,24 +100,10 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n+      // This no-op statement was there so that JSDoc information could\n     // be attached to the name. This check should not complain about it.\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n+        int start = 0;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n@@ -161,10 +147,11 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      int start = 0;\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n+        final String PARAM_NAME = \"jscomp_throw_param\";\n+\t\tname.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1879/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:09:23.196587421 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SUB\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 167, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "return toDot(n,null);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_659/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:57:41.052723232 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -164,7 +152,6 @@\n       addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_659/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:57:41.056723200 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              Node block = new Node(Token.BLOCK);\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 167, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "Node block=new Node(Token.BLOCK);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "InsertBefore", 
          "seed": "return toDot(n,null);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1260/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:03:27.694928721 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -181,7 +169,7 @@\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n+    int index = -1;\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1260/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:03:27.698928672 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 184, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1917/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:09:46.168544411 -0500\n@@ -100,25 +100,6 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_645/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:57:32.992790662 -0500\n@@ -106,26 +106,9 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+    StringBuilder builder = new StringBuilder();\n+    } else\n+\t\t;\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1316/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:04:00.846509873 -0500\n@@ -100,25 +100,7 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+      StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1316/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:04:00.846509873 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1554/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:06:14.333326660 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1554/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:06:14.333326660 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SUB\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_744/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:58:30.020377826 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -164,7 +150,7 @@\n       addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n+        StringBuilder builder = new StringBuilder();\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_744/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:58:30.020377826 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 167, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1905/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:09:39.868555446 -0500\n@@ -100,25 +100,7 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+      StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -138,7 +120,6 @@\n       }\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n-        msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n         msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n             \"' operator is not being used.\";\n@@ -161,7 +142,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1905/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:09:39.868555446 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 141, 
          "faulty": "msg=\"Is there a missing '+' on the previous line?\";", 
          "type": "Delete", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1948/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:10:06.608512353 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -161,16 +149,18 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      int start = 0;\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n+        final String PARAM_NAME = \"jscomp_throw_param\";\n+\t\tname.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n+      StringBuilder builder = new StringBuilder();\n+\tcompiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1948/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:10:06.612512347 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 167, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 173, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1469/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:05:27.145662109 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1469/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:05:27.149662078 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "break;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Replace", 
          "seed": "int type=n.getType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1062/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:01:32.763813803 -0500\n@@ -106,26 +106,9 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+    StringBuilder builder = new StringBuilder();\n+    } else\n+\t\t;\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n@@ -170,7 +153,6 @@\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n     }\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 173, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_959/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:00:34.715894860 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -180,7 +166,6 @@\n     Node var = IR.var(name);\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n-    builder.recordNoAlias();\n     var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 183, 
          "faulty": "builder.recordNoAlias();", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1399/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:04:48.821996926 -0500\n@@ -100,25 +100,7 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+      StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1399/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:04:48.825996888 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1077/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:01:41.639807620 -0500\n@@ -111,11 +111,9 @@\n       if (n == parent.getLastChild()) {\n         for (Node an : parent.getAncestors()) {\n           int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n           if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n+\t\t\t;\n+\t\telse\n             break;\n         }\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1759/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:08:10.564780092 -0500\n@@ -100,25 +100,6 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -161,7 +142,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n@@ -180,7 +161,6 @@\n     Node var = IR.var(name);\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n-    builder.recordNoAlias();\n     var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1759/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:08:10.568780078 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SUB\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Replace", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 183, 
          "faulty": "builder.recordNoAlias();", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1368/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:04:29.878186065 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -161,7 +149,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1368/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:04:29.878186065 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_499/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:56:09.893695594 -0500\n@@ -106,26 +106,9 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+    StringBuilder builder = new StringBuilder();\n+    } else\n+\t\t;\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 113, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "InsertBefore", 
          "seed": "int type=n.getType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1954/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:10:09.676508015 -0500\n@@ -100,25 +100,7 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+      StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1954/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:10:09.680508009 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1364/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:04:27.390212162 -0500\n@@ -100,25 +100,7 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+      StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1629/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:06:55.517092621 -0500\n@@ -100,24 +100,12 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n \n     // This no-op statement was there so that JSDoc information could\n     // be attached to the name. This check should not complain about it.\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n+        int start = 0;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n@@ -161,7 +149,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1629/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:06:55.521092602 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "JSType type=n.getJSType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1022/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:01:08.999838102 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -180,7 +166,6 @@\n     Node var = IR.var(name);\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n-    builder.recordNoAlias();\n     var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1022/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:01:08.999838102 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 183, 
          "faulty": "builder.recordNoAlias();", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1203/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:02:56.211341934 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1579/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:06:28.513240387 -0500\n@@ -100,25 +100,6 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -161,7 +142,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1579/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:06:28.517240364 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_763/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:58:41.168313303 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_763/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:58:41.172313281 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1864/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:09:13.528607889 -0500\n@@ -99,26 +99,6 @@\n     // these cases when we visit the child, and the peephole passes will\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n-      Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -161,7 +141,6 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 102, 
          "faulty": "Node gramps=parent.getParent();", 
          "type": "Delete", 
          "seed": "traverseNodes(n);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1928/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:09:52.760533459 -0500\n@@ -99,26 +99,7 @@\n     // these cases when we visit the child, and the peephole passes will\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n-      Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+      StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -161,7 +142,6 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1928/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:09:52.760533459 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 102, 
          "faulty": "Node gramps=parent.getParent();", 
          "type": "Delete", 
          "seed": "traverseNodes(n);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1385/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:04:40.846074537 -0500\n@@ -100,25 +100,6 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1385/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:04:40.846074537 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "formatPreamble();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 113, 
          "faulty": "int ancestorType=an.getType();", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1477/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:05:31.157630475 -0500\n@@ -100,25 +100,7 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+      StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1477/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:05:31.157630475 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1210/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:02:59.607294477 -0500\n@@ -106,26 +106,9 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+    StringBuilder builder = new StringBuilder();\n+    } else\n+\t\t;\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "int index=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1214/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:03:01.191272585 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_907/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:00:05.519965843 -0500\n@@ -109,15 +109,6 @@\n     // This no-op statement was there so that JSDoc information could\n     // be attached to the name. This check should not complain about it.\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n@@ -161,7 +152,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_907/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:00:05.523965832 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_379/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:54:48.603046617 -0500\n@@ -106,26 +106,9 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+    StringBuilder builder = new StringBuilder();\n+    } else\n+\t\t;\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_866/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:59:40.864043979 -0500\n@@ -109,15 +109,6 @@\n     // This no-op statement was there so that JSDoc information could\n     // be attached to the name. This check should not complain about it.\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_866/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:59:40.864043979 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "StringBuilder s=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_661/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:57:41.848716748 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -164,7 +152,6 @@\n       addExtern();\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_661/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:57:41.852716715 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              Node block = new Node(Token.BLOCK);\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "Replace", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 167, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "Node block=new Node(Token.BLOCK);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_839/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:59:26.172099199 -0500\n@@ -100,32 +100,20 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+      StringBuilder builder = new StringBuilder();\n+    } else {\n+\t\tint start = 0;\n+\t\tif (parent.getType() != Token.EXPR_RESULT\n+\t\t\t\t&& parent.getType() != Token.BLOCK) {\n+\t\t\tif (parent.getType() == Token.FOR\n+\t\t\t\t\t&& parent.getChildCount() == 4\n+\t\t\t\t\t&& (n == parent.getFirstChild() || n == parent\n+\t\t\t\t\t\t\t.getFirstChild().getNext().getNext())) {\n+\t\t\t} else {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\t}\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n@@ -140,8 +128,6 @@\n       if (n.isString()) {\n         msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n-        msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n-            \"' operator is not being used.\";\n       }\n \n       t.getCompiler().report(\n@@ -183,7 +169,8 @@\n     builder.recordNoAlias();\n     var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n-    input.getAstRoot(compiler).addChildrenToBack(var);\n+    int index = -1;\n+\tinput.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_839/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:59:26.176099182 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Replace", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 143, 
          "faulty": "msg=\"The result of the '\" + Token.name(n.getType()).toLowerCase() + \"' operator is not being used.\";", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 186, 
          "faulty": "input.getAstRoot(compiler).addChildrenToBack(var);", 
          "type": "InsertBefore", 
          "seed": "int index=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1008/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:01:01.027848918 -0500\n@@ -109,15 +109,6 @@\n     // This no-op statement was there so that JSDoc information could\n     // be attached to the name. This check should not complain about it.\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n@@ -161,7 +152,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n@@ -181,7 +172,7 @@\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n     builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n+    int start = 0;\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1008/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:01:01.031848912 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 184, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1519/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:05:53.617464350 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1519/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:05:53.617464350 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "traverseNodes(n);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1372/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:04:32.290161053 -0500\n@@ -106,26 +106,9 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+    StringBuilder builder = new StringBuilder();\n+    } else\n+\t\t;\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_803/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:59:05.864187034 -0500\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_803/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:59:05.864187034 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_750/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:58:33.228358760 -0500\n@@ -106,26 +106,9 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n+    StringBuilder builder = new StringBuilder();\n+    } else\n+\t\t;\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_750/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:58:33.228358760 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 122, 
          "faulty": "if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n  if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n  }\n else {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_967/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:00:38.679886893 -0500\n@@ -100,25 +100,7 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+      StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -161,7 +143,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_967/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:00:38.679886893 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "JSType type=n.getJSType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "InsertBefore", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1144/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:02:21.727797526 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -180,7 +168,6 @@\n     Node var = IR.var(name);\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n-    builder.recordNoAlias();\n     var.setJSDocInfo(builder.build(var));\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1144/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-02 08:02:21.727797526 -0500\n@@ -3120,20 +3120,8 @@\n         return (expr == parent.getFirstChild())\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n-        Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n+        ;\n+        ;\n \n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 183, 
          "faulty": "builder.recordNoAlias();", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3123, 
          "faulty": "Node gramps=parent.getParent();", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/NodeUtil.java", 
          "line": 3124, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && \"eval\".equals(expr.getNext().getString())) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_390/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:54:54.334932899 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1849/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:09:04.708627851 -0500\n@@ -100,25 +100,6 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -161,16 +142,18 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      int start = 0;\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n+        final String PARAM_NAME = \"jscomp_throw_param\";\n+\t\tname.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         Node replacement = IR.call(name).srcref(n);\n         replacement.putBooleanProp(Node.FREE_CALL, true);\n         n.getParent().replaceChild(n, replacement);\n         replacement.addChildToBack(n);\n       }\n-      compiler.reportCodeChange();\n+      StringBuilder builder = new StringBuilder();\n+\tcompiler.reportCodeChange();\n     }\n   }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1849/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:09:04.712627843 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              ;\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 115, 
          "faulty": "continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Delete", 
          "seed": "return \"SUB\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 167, 
          "faulty": "name.putBooleanProp(Node.IS_CONSTANT_NAME,true);", 
          "type": "InsertBefore", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 173, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_918/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:00:11.095950549 -0500\n@@ -109,15 +109,6 @@\n     // This no-op statement was there so that JSDoc information could\n     // be attached to the name. This check should not complain about it.\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n@@ -161,7 +152,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n@@ -180,8 +171,7 @@\n     Node var = IR.var(name);\n     // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n     JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n-    builder.recordNoAlias();\n-    var.setJSDocInfo(builder.build(var));\n+    int start = 0;\n     CompilerInput input = compiler.getSynthesizedExternsInput();\n     input.getAstRoot(compiler).addChildrenToBack(var);\n     compiler.reportCodeChange();\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_918/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:00:11.095950549 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 184, 
          "faulty": "var.setJSDocInfo(builder.build(var));", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 116, 
          "faulty": "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n else break;", 
          "type": "InsertBefore", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 183, 
          "faulty": "builder.recordNoAlias();", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1208/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:02:58.699307094 -0500\n@@ -106,19 +106,7 @@\n         }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+    StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "formatConclusion();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1362/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:04:26.574220787 -0500\n@@ -100,25 +100,7 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n+      StringBuilder builder = new StringBuilder();\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1362/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:04:26.578220744 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 07:44:36.414916381 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1609/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-02 08:06:45.289146139 -0500\n@@ -100,25 +100,6 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n@@ -138,7 +119,8 @@\n       }\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n-        msg = \"Is there a missing '+' on the previous line?\";\n+        int index = -1;\n+\t\tmsg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n         msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n             \"' operator is not being used.\";\n@@ -161,7 +143,7 @@\n    */\n   private void protectSideEffects() {\n     if (!problemNodes.isEmpty()) {\n-      addExtern();\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n       for (Node n : problemNodes) {\n         Node name = IR.name(PROTECTOR_FN).srcref(n);\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n\n\n--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 07:44:34.590004490 -0500\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_qjuv/Patch_1609/patched/tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/rhino/Token.java\t2018-12-02 08:06:45.293146118 -0500\n@@ -184,7 +184,7 @@\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n-          case EQ:              return \"EQ\";\n+          case EQ:              return \"PARAM_LIST\";\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 111, 
          "faulty": "if (n == parent.getLastChild()) {\n  for (  Node an : parent.getAncestors()) {\n    int ancestorType=an.getType();\n    if (ancestorType == Token.COMMA)     continue;\n    if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)     return;\n else     break;\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 117, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "this.level=level;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 187, 
          "faulty": "return \"EQ\";", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 164, 
          "faulty": "addExtern();", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 114, 
          "faulty": "if (ancestorType == Token.COMMA) continue;", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 103, 
          "faulty": "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n  if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n    return;\n  }\n}", 
          "type": "Delete", 
          "seed": "return toDot(n,null);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 112, 
          "faulty": "for (Node an : parent.getAncestors()) {\n  int ancestorType=an.getType();\n  if (ancestorType == Token.COMMA)   continue;\n  if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)   return;\n else   break;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CheckSideEffects.java", 
          "line": 141, 
          "faulty": "msg=\"Is there a missing '+' on the previous line?\";", 
          "type": "InsertBefore", 
          "seed": "int index=-1;"
        }
      ]
    }
  ]
}