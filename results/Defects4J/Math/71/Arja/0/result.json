{
  "repair_end": "2018-12-01 14:00:17.637751", 
  "repair_begin": "2018-12-01 12:00:15.584422", 
  "patches": [
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_559/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:48:35.070384829 -0500\n@@ -208,7 +208,8 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    pendingEvent = true;\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\t2018-12-01 06:00:01.507483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_559/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\t2018-12-01 06:48:35.070384829 -0500\n@@ -207,8 +207,7 @@\n       throws DerivativeException {\n \n     if (initialStep > 0) {\n-      // use the user provided value\n-      return forward ? initialStep : -initialStep;\n+      stepStart = t0;\n     }\n \n     // very rough first guess : h = 0.01 * ||y/scale|| / ||y'/scale||\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java", 
          "line": 211, 
          "faulty": "return forward ? initialStep : -initialStep;", 
          "type": "Replace", 
          "seed": "stepStart=t0;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "pendingEvent=true;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_1074/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 07:30:16.674497418 -0500\n@@ -208,7 +208,11 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n@@ -335,8 +339,6 @@\n             handler.resetState(t, y);\n         }\n         pendingEvent      = false;\n-        pendingEventTime  = Double.NaN;\n-\n         return (nextAction == EventHandler.RESET_STATE) ||\n                (nextAction == EventHandler.RESET_DERIVATIVES);\n \n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_1074/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java\t2018-12-01 07:30:16.678497438 -0500\n@@ -125,7 +125,8 @@\n                 return true;\n             }\n         }\n-        return false;\n+        stepSize = Double.NaN;\n+\t\treturn false;\n     }\n \n     /** {@inheritDoc} */\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 338, 
          "faulty": "pendingEventTime=Double.NaN;", 
          "type": "Delete", 
          "seed": "g0=handler.g(t,y);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java", 
          "line": 128, 
          "faulty": "return false;", 
          "type": "InsertBefore", 
          "seed": "stepSize=Double.NaN;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_1076/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 07:30:22.586526018 -0500\n@@ -208,10 +208,68 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n-                    final UnivariateRealFunction f = new UnivariateRealFunction() {\n+                    if (g0Positive ^ (gb >= 0)) {\n+\t\t\t\t\t\tif (ga * gb > 0) {\n+\t\t\t\t\t\t\tfinal double epsilon = (forward ? 0.25 : -0.25)\n+\t\t\t\t\t\t\t\t\t* convergence;\n+\t\t\t\t\t\t\tfor (int k = 0; (k < 4) && (ga * gb > 0); ++k) {\n+\t\t\t\t\t\t\t\tta += epsilon;\n+\t\t\t\t\t\t\t\tinterpolator.setInterpolatedTime(ta);\n+\t\t\t\t\t\t\t\tga = handler.g(ta,\n+\t\t\t\t\t\t\t\t\t\tinterpolator.getInterpolatedState());\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tif (ga * gb > 0) {\n+\t\t\t\t\t\t\t\tthrow MathRuntimeException\n+\t\t\t\t\t\t\t\t\t\t.createInternalError(null);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tincreasing = gb >= ga;\n+\t\t\t\t\t\tfinal UnivariateRealFunction f = new UnivariateRealFunction() {\n+\t\t\t\t\t\t\tpublic double value(final double t)\n+\t\t\t\t\t\t\t\t\tthrows FunctionEvaluationException {\n+\t\t\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\t\t\tinterpolator.setInterpolatedTime(t);\n+\t\t\t\t\t\t\t\t\treturn handler\n+\t\t\t\t\t\t\t\t\t\t\t.g(t, interpolator\n+\t\t\t\t\t\t\t\t\t\t\t\t\t.getInterpolatedState());\n+\t\t\t\t\t\t\t\t} catch (DerivativeException e) {\n+\t\t\t\t\t\t\t\t\tthrow new FunctionEvaluationException(e, t);\n+\t\t\t\t\t\t\t\t} catch (EventException e) {\n+\t\t\t\t\t\t\t\t\tthrow new FunctionEvaluationException(e, t);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t};\n+\t\t\t\t\t\tfinal BrentSolver solver = new BrentSolver();\n+\t\t\t\t\t\tsolver.setAbsoluteAccuracy(convergence);\n+\t\t\t\t\t\tsolver.setMaximalIterationCount(maxIterationCount);\n+\t\t\t\t\t\tfinal double root = (ta <= tb) ? solver\n+\t\t\t\t\t\t\t\t.solve(f, ta, tb) : solver.solve(f, tb, ta);\n+\t\t\t\t\t\tif ((Math.abs(root - ta) <= convergence)\n+\t\t\t\t\t\t\t\t&& (Math.abs(root - previousEventTime) <= convergence)) {\n+\t\t\t\t\t\t\tta = tb;\n+\t\t\t\t\t\t\tga = gb;\n+\t\t\t\t\t\t} else if (Double.isNaN(previousEventTime)\n+\t\t\t\t\t\t\t\t|| (Math.abs(previousEventTime - root) > convergence)) {\n+\t\t\t\t\t\t\tpendingEventTime = root;\n+\t\t\t\t\t\t\tif (pendingEvent\n+\t\t\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\t\t\treturn false;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tpendingEvent = true;\n+\t\t\t\t\t\t\treturn true;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tta = tb;\n+\t\t\t\t\t\tga = gb;\n+\t\t\t\t\t}\n+\t\t\t\t\tfinal UnivariateRealFunction f = new UnivariateRealFunction() {\n                         public double value(final double t) throws FunctionEvaluationException {\n                             try {\n                                 interpolator.setInterpolatedTime(t);\n@@ -335,7 +393,7 @@\n             handler.resetState(t, y);\n         }\n         pendingEvent      = false;\n-        pendingEventTime  = Double.NaN;\n+        g0 = handler.g(t, y);\n \n         return (nextAction == EventHandler.RESET_STATE) ||\n                (nextAction == EventHandler.RESET_DERIVATIVES);\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 338, 
          "faulty": "pendingEventTime=Double.NaN;", 
          "type": "Replace", 
          "seed": "g0=handler.g(t,y);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 214, 
          "faulty": "final UnivariateRealFunction f=new UnivariateRealFunction(){\n  public double value(  final double t) throws FunctionEvaluationException {\n    try {\n      interpolator.setInterpolatedTime(t);\n      return handler.g(t,interpolator.getInterpolatedState());\n    }\n catch (    DerivativeException e) {\n      throw new FunctionEvaluationException(e,t);\n    }\ncatch (    EventException e) {\n      throw new FunctionEvaluationException(e,t);\n    }\n  }\n}\n;", 
          "type": "InsertBefore", 
          "seed": "if (g0Positive ^ (gb >= 0)) {\n  if (ga * gb > 0) {\n    final double epsilon=(forward ? 0.25 : -0.25) * convergence;\n    for (int k=0; (k < 4) && (ga * gb > 0); ++k) {\n      ta+=epsilon;\n      interpolator.setInterpolatedTime(ta);\n      ga=handler.g(ta,interpolator.getInterpolatedState());\n    }\n    if (ga * gb > 0) {\n      throw MathRuntimeException.createInternalError(null);\n    }\n  }\n  increasing=gb >= ga;\n  final UnivariateRealFunction f=new UnivariateRealFunction(){\n    public double value(    final double t) throws FunctionEvaluationException {\n      try {\n        interpolator.setInterpolatedTime(t);\n        return handler.g(t,interpolator.getInterpolatedState());\n      }\n catch (      DerivativeException e) {\n        throw new FunctionEvaluationException(e,t);\n      }\ncatch (      EventException e) {\n        throw new FunctionEvaluationException(e,t);\n      }\n    }\n  }\n;\n  final BrentSolver solver=new BrentSolver();\n  solver.setAbsoluteAccuracy(convergence);\n  solver.setMaximalIterationCount(maxIterationCount);\n  final double root=(ta <= tb) ? solver.solve(f,ta,tb) : solver.solve(f,tb,ta);\n  if ((Math.abs(root - ta) <= convergence) && (Math.abs(root - previousEventTime) <= convergence)) {\n    ta=tb;\n    ga=gb;\n  }\n else   if (Double.isNaN(previousEventTime) || (Math.abs(previousEventTime - root) > convergence)) {\n    pendingEventTime=root;\n    if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n      return false;\n    }\n    pendingEvent=true;\n    return true;\n  }\n}\n else {\n  ta=tb;\n  ga=gb;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_599/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:51:35.479270220 -0500\n@@ -208,7 +208,11 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:01.483483648 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_599/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:51:35.479270220 -0500\n@@ -333,9 +333,13 @@\n                 x1 = x1 + delta;\n             } else if (dx > 0.0) {\n                 x1 = x1 + 0.5 * tolerance;\n-            } else if (dx <= 0.0) {\n-                x1 = x1 - 0.5 * tolerance;\n-            }\n+            } else if (Math.abs(delta) > tolerance) {\n+\t\t\t\tx1 = x1 + delta;\n+\t\t\t} else if (dx > 0.0) {\n+\t\t\t\tx1 = x1 + 0.5 * tolerance;\n+\t\t\t} else if (dx <= 0.0) {\n+\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t}\n             y1 = f.value(x1);\n             if ((y1 > 0) == (y2 > 0)) {\n                 x2 = x0;\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 336, 
          "faulty": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}", 
          "type": "Replace", 
          "seed": "if (Math.abs(delta) > tolerance) {\n  x1=x1 + delta;\n}\n else if (dx > 0.0) {\n  x1=x1 + 0.5 * tolerance;\n}\n else if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_757/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 07:04:35.439040365 -0500\n@@ -208,7 +208,8 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    pendingEvent = true;\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\t2018-12-01 06:00:01.507483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_757/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\t2018-12-01 07:04:35.439040365 -0500\n@@ -147,11 +147,6 @@\n    * ignore the value and compute the initial step size by itself)\n    */\n   public void setInitialStepSize(final double initialStepSize) {\n-    if ((initialStepSize < minStep) || (initialStepSize > maxStep)) {\n-      initialStep = -1.0;\n-    } else {\n-      initialStep = initialStepSize;\n-    }\n   }\n \n   /** Perform some sanity checks on the integration parameters.\n@@ -207,8 +202,7 @@\n       throws DerivativeException {\n \n     if (initialStep > 0) {\n-      // use the user provided value\n-      return forward ? initialStep : -initialStep;\n+      resetInternalState();\n     }\n \n     // very rough first guess : h = 0.01 * ||y/scale|| / ||y'/scale||\n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_757/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java\t2018-12-01 07:04:35.439040365 -0500\n@@ -125,7 +125,8 @@\n                 return true;\n             }\n         }\n-        return false;\n+        this.equations = equations;\n+\t\treturn false;\n     }\n \n     /** {@inheritDoc} */\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java", 
          "line": 211, 
          "faulty": "return forward ? initialStep : -initialStep;", 
          "type": "Replace", 
          "seed": "resetInternalState();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java", 
          "line": 150, 
          "faulty": "if ((initialStepSize < minStep) || (initialStepSize > maxStep)) {\n  initialStep=-1.0;\n}\n else {\n  initialStep=initialStepSize;\n}", 
          "type": "Delete", 
          "seed": "initialStep=initialStepSize;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java", 
          "line": 128, 
          "faulty": "return false;", 
          "type": "InsertBefore", 
          "seed": "this.equations=equations;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "pendingEvent=true;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_683/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:58:10.377177518 -0500\n@@ -208,7 +208,11 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\t2018-12-01 06:00:01.507483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_683/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\t2018-12-01 06:58:10.377177518 -0500\n@@ -207,8 +207,6 @@\n       throws DerivativeException {\n \n     if (initialStep > 0) {\n-      // use the user provided value\n-      return forward ? initialStep : -initialStep;\n     }\n \n     // very rough first guess : h = 0.01 * ||y/scale|| / ||y'/scale||\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java", 
          "line": 211, 
          "faulty": "return forward ? initialStep : -initialStep;", 
          "type": "Delete", 
          "seed": "resetInternalState();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_1398/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 07:57:36.078601270 -0500\n@@ -208,7 +208,11 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n@@ -232,21 +236,32 @@\n                         // we have either found nothing or found (again ?) a past event, we simply ignore it\n                         ta = tb;\n                         ga = gb;\n-                    } else if (Double.isNaN(previousEventTime) ||\n-                               (Math.abs(previousEventTime - root) > convergence)) {\n-                        pendingEventTime = root;\n-                        if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n-                            // we were already waiting for this event which was\n-                            // found during a previous call for a step that was\n-                            // rejected, this step must now be accepted since it\n-                            // properly ends exactly at the event occurrence\n-                            return false;\n-                        }\n-                        // either we were not waiting for the event or it has\n-                        // moved in such a way the step cannot be accepted\n-                        pendingEvent = true;\n-                        return true;\n-                    }\n+                    } else {\n+\t\t\t\t\t\tif (ga * gb > 0) {\n+\t\t\t\t\t\t\tfinal double epsilon = (forward ? 0.25 : -0.25)\n+\t\t\t\t\t\t\t\t\t* convergence;\n+\t\t\t\t\t\t\tfor (int k = 0; (k < 4) && (ga * gb > 0); ++k) {\n+\t\t\t\t\t\t\t\tta += epsilon;\n+\t\t\t\t\t\t\t\tinterpolator.setInterpolatedTime(ta);\n+\t\t\t\t\t\t\t\tga = handler.g(ta,\n+\t\t\t\t\t\t\t\t\t\tinterpolator.getInterpolatedState());\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tif (ga * gb > 0) {\n+\t\t\t\t\t\t\t\tthrow MathRuntimeException\n+\t\t\t\t\t\t\t\t\t\t.createInternalError(null);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tif (Double.isNaN(previousEventTime)\n+\t\t\t\t\t\t\t\t|| (Math.abs(previousEventTime - root) > convergence)) {\n+\t\t\t\t\t\t\tpendingEventTime = root;\n+\t\t\t\t\t\t\tif (pendingEvent\n+\t\t\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\t\t\treturn false;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tpendingEvent = true;\n+\t\t\t\t\t\t\treturn true;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n \n                 } else {\n                     // no sign change: there is no event for now\n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\t2018-12-01 06:00:01.507483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_1398/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\t2018-12-01 07:57:36.078601270 -0500\n@@ -147,11 +147,6 @@\n    * ignore the value and compute the initial step size by itself)\n    */\n   public void setInitialStepSize(final double initialStepSize) {\n-    if ((initialStepSize < minStep) || (initialStepSize > maxStep)) {\n-      initialStep = -1.0;\n-    } else {\n-      initialStep = initialStepSize;\n-    }\n   }\n \n   /** Perform some sanity checks on the integration parameters.\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java", 
          "line": 150, 
          "faulty": "if ((initialStepSize < minStep) || (initialStepSize > maxStep)) {\n  initialStep=-1.0;\n}\n else {\n  initialStep=initialStepSize;\n}", 
          "type": "Delete", 
          "seed": "if ((initialStepSize < minStep) || (initialStepSize > maxStep)) {\n  initialStep=-1.0;\n}\n else {\n  initialStep=initialStepSize;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 235, 
          "faulty": "if (Double.isNaN(previousEventTime) || (Math.abs(previousEventTime - root) > convergence)) {\n  pendingEventTime=root;\n  if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n    return false;\n  }\n  pendingEvent=true;\n  return true;\n}", 
          "type": "InsertBefore", 
          "seed": "if (ga * gb > 0) {\n  final double epsilon=(forward ? 0.25 : -0.25) * convergence;\n  for (int k=0; (k < 4) && (ga * gb > 0); ++k) {\n    ta+=epsilon;\n    interpolator.setInterpolatedTime(ta);\n    ga=handler.g(ta,interpolator.getInterpolatedState());\n  }\n  if (ga * gb > 0) {\n    throw MathRuntimeException.createInternalError(null);\n  }\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_396/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:35:12.750432641 -0500\n@@ -208,7 +208,11 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:01.483483648 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_396/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:35:12.750432641 -0500\n@@ -334,7 +334,8 @@\n             } else if (dx > 0.0) {\n                 x1 = x1 + 0.5 * tolerance;\n             } else if (dx <= 0.0) {\n-                x1 = x1 - 0.5 * tolerance;\n+                oldDelta = x2 - x1;\n+\t\t\t\tx1 = x1 - 0.5 * tolerance;\n             }\n             y1 = f.value(x1);\n             if ((y1 > 0) == (y2 > 0)) {\n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\t2018-12-01 06:00:05.075483730 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_396/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\t2018-12-01 06:35:12.750432641 -0500\n@@ -292,12 +292,7 @@\n           if (manager.evaluateStep(interpolator)) {\n               final double dt = manager.getEventTime() - stepStart;\n               if (Math.abs(dt) <= Math.ulp(stepStart)) {\n-                  // we cannot simply truncate the step, reject the current computation\n-                  // and let the loop compute another state with the truncated step.\n-                  // it is so small (much probably exactly 0 due to limited accuracy)\n-                  // that the code above would fail handling it.\n-                  // So we set up an artificial 0 size step by copying states\n-                  loop     = false;\n+                  super.sanityChecks(equations, t0, y0, t, y);\n               } else {\n                   // reject the step to match exactly the next switch time\n                   hNew = dt;\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java", 
          "line": 300, 
          "faulty": "loop=false;", 
          "type": "Replace", 
          "seed": "super.sanityChecks(equations,t0,y0,t,y);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 337, 
          "faulty": "x1=x1 - 0.5 * tolerance;", 
          "type": "InsertBefore", 
          "seed": "oldDelta=x2 - x1;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_1122/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 07:34:20.899677089 -0500\n@@ -208,10 +208,68 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n-                    final UnivariateRealFunction f = new UnivariateRealFunction() {\n+                    if (g0Positive ^ (gb >= 0)) {\n+\t\t\t\t\t\tif (ga * gb > 0) {\n+\t\t\t\t\t\t\tfinal double epsilon = (forward ? 0.25 : -0.25)\n+\t\t\t\t\t\t\t\t\t* convergence;\n+\t\t\t\t\t\t\tfor (int k = 0; (k < 4) && (ga * gb > 0); ++k) {\n+\t\t\t\t\t\t\t\tta += epsilon;\n+\t\t\t\t\t\t\t\tinterpolator.setInterpolatedTime(ta);\n+\t\t\t\t\t\t\t\tga = handler.g(ta,\n+\t\t\t\t\t\t\t\t\t\tinterpolator.getInterpolatedState());\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tif (ga * gb > 0) {\n+\t\t\t\t\t\t\t\tthrow MathRuntimeException\n+\t\t\t\t\t\t\t\t\t\t.createInternalError(null);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tincreasing = gb >= ga;\n+\t\t\t\t\t\tfinal UnivariateRealFunction f = new UnivariateRealFunction() {\n+\t\t\t\t\t\t\tpublic double value(final double t)\n+\t\t\t\t\t\t\t\t\tthrows FunctionEvaluationException {\n+\t\t\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\t\t\tinterpolator.setInterpolatedTime(t);\n+\t\t\t\t\t\t\t\t\treturn handler\n+\t\t\t\t\t\t\t\t\t\t\t.g(t, interpolator\n+\t\t\t\t\t\t\t\t\t\t\t\t\t.getInterpolatedState());\n+\t\t\t\t\t\t\t\t} catch (DerivativeException e) {\n+\t\t\t\t\t\t\t\t\tthrow new FunctionEvaluationException(e, t);\n+\t\t\t\t\t\t\t\t} catch (EventException e) {\n+\t\t\t\t\t\t\t\t\tthrow new FunctionEvaluationException(e, t);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t};\n+\t\t\t\t\t\tfinal BrentSolver solver = new BrentSolver();\n+\t\t\t\t\t\tsolver.setAbsoluteAccuracy(convergence);\n+\t\t\t\t\t\tsolver.setMaximalIterationCount(maxIterationCount);\n+\t\t\t\t\t\tfinal double root = (ta <= tb) ? solver\n+\t\t\t\t\t\t\t\t.solve(f, ta, tb) : solver.solve(f, tb, ta);\n+\t\t\t\t\t\tif ((Math.abs(root - ta) <= convergence)\n+\t\t\t\t\t\t\t\t&& (Math.abs(root - previousEventTime) <= convergence)) {\n+\t\t\t\t\t\t\tta = tb;\n+\t\t\t\t\t\t\tga = gb;\n+\t\t\t\t\t\t} else if (Double.isNaN(previousEventTime)\n+\t\t\t\t\t\t\t\t|| (Math.abs(previousEventTime - root) > convergence)) {\n+\t\t\t\t\t\t\tpendingEventTime = root;\n+\t\t\t\t\t\t\tif (pendingEvent\n+\t\t\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\t\t\treturn false;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tpendingEvent = true;\n+\t\t\t\t\t\t\treturn true;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tta = tb;\n+\t\t\t\t\t\tga = gb;\n+\t\t\t\t\t}\n+\t\t\t\t\tfinal UnivariateRealFunction f = new UnivariateRealFunction() {\n                         public double value(final double t) throws FunctionEvaluationException {\n                             try {\n                                 interpolator.setInterpolatedTime(t);\n@@ -337,7 +395,8 @@\n         pendingEvent      = false;\n         pendingEventTime  = Double.NaN;\n \n-        return (nextAction == EventHandler.RESET_STATE) ||\n+        g0 = Double.NaN;\n+\t\treturn (nextAction == EventHandler.RESET_STATE) ||\n                (nextAction == EventHandler.RESET_DERIVATIVES);\n \n     }\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 340, 
          "faulty": "return (nextAction == EventHandler.RESET_STATE) || (nextAction == EventHandler.RESET_DERIVATIVES);", 
          "type": "InsertBefore", 
          "seed": "g0=Double.NaN;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 214, 
          "faulty": "final UnivariateRealFunction f=new UnivariateRealFunction(){\n  public double value(  final double t) throws FunctionEvaluationException {\n    try {\n      interpolator.setInterpolatedTime(t);\n      return handler.g(t,interpolator.getInterpolatedState());\n    }\n catch (    DerivativeException e) {\n      throw new FunctionEvaluationException(e,t);\n    }\ncatch (    EventException e) {\n      throw new FunctionEvaluationException(e,t);\n    }\n  }\n}\n;", 
          "type": "InsertBefore", 
          "seed": "if (g0Positive ^ (gb >= 0)) {\n  if (ga * gb > 0) {\n    final double epsilon=(forward ? 0.25 : -0.25) * convergence;\n    for (int k=0; (k < 4) && (ga * gb > 0); ++k) {\n      ta+=epsilon;\n      interpolator.setInterpolatedTime(ta);\n      ga=handler.g(ta,interpolator.getInterpolatedState());\n    }\n    if (ga * gb > 0) {\n      throw MathRuntimeException.createInternalError(null);\n    }\n  }\n  increasing=gb >= ga;\n  final UnivariateRealFunction f=new UnivariateRealFunction(){\n    public double value(    final double t) throws FunctionEvaluationException {\n      try {\n        interpolator.setInterpolatedTime(t);\n        return handler.g(t,interpolator.getInterpolatedState());\n      }\n catch (      DerivativeException e) {\n        throw new FunctionEvaluationException(e,t);\n      }\ncatch (      EventException e) {\n        throw new FunctionEvaluationException(e,t);\n      }\n    }\n  }\n;\n  final BrentSolver solver=new BrentSolver();\n  solver.setAbsoluteAccuracy(convergence);\n  solver.setMaximalIterationCount(maxIterationCount);\n  final double root=(ta <= tb) ? solver.solve(f,ta,tb) : solver.solve(f,tb,ta);\n  if ((Math.abs(root - ta) <= convergence) && (Math.abs(root - previousEventTime) <= convergence)) {\n    ta=tb;\n    ga=gb;\n  }\n else   if (Double.isNaN(previousEventTime) || (Math.abs(previousEventTime - root) > convergence)) {\n    pendingEventTime=root;\n    if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n      return false;\n    }\n    pendingEvent=true;\n    return true;\n  }\n}\n else {\n  ta=tb;\n  ga=gb;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_511/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:44:39.881222249 -0500\n@@ -208,10 +208,68 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n-                    final UnivariateRealFunction f = new UnivariateRealFunction() {\n+                    if (g0Positive ^ (gb >= 0)) {\n+\t\t\t\t\t\tif (ga * gb > 0) {\n+\t\t\t\t\t\t\tfinal double epsilon = (forward ? 0.25 : -0.25)\n+\t\t\t\t\t\t\t\t\t* convergence;\n+\t\t\t\t\t\t\tfor (int k = 0; (k < 4) && (ga * gb > 0); ++k) {\n+\t\t\t\t\t\t\t\tta += epsilon;\n+\t\t\t\t\t\t\t\tinterpolator.setInterpolatedTime(ta);\n+\t\t\t\t\t\t\t\tga = handler.g(ta,\n+\t\t\t\t\t\t\t\t\t\tinterpolator.getInterpolatedState());\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tif (ga * gb > 0) {\n+\t\t\t\t\t\t\t\tthrow MathRuntimeException\n+\t\t\t\t\t\t\t\t\t\t.createInternalError(null);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tincreasing = gb >= ga;\n+\t\t\t\t\t\tfinal UnivariateRealFunction f = new UnivariateRealFunction() {\n+\t\t\t\t\t\t\tpublic double value(final double t)\n+\t\t\t\t\t\t\t\t\tthrows FunctionEvaluationException {\n+\t\t\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\t\t\tinterpolator.setInterpolatedTime(t);\n+\t\t\t\t\t\t\t\t\treturn handler\n+\t\t\t\t\t\t\t\t\t\t\t.g(t, interpolator\n+\t\t\t\t\t\t\t\t\t\t\t\t\t.getInterpolatedState());\n+\t\t\t\t\t\t\t\t} catch (DerivativeException e) {\n+\t\t\t\t\t\t\t\t\tthrow new FunctionEvaluationException(e, t);\n+\t\t\t\t\t\t\t\t} catch (EventException e) {\n+\t\t\t\t\t\t\t\t\tthrow new FunctionEvaluationException(e, t);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t};\n+\t\t\t\t\t\tfinal BrentSolver solver = new BrentSolver();\n+\t\t\t\t\t\tsolver.setAbsoluteAccuracy(convergence);\n+\t\t\t\t\t\tsolver.setMaximalIterationCount(maxIterationCount);\n+\t\t\t\t\t\tfinal double root = (ta <= tb) ? solver\n+\t\t\t\t\t\t\t\t.solve(f, ta, tb) : solver.solve(f, tb, ta);\n+\t\t\t\t\t\tif ((Math.abs(root - ta) <= convergence)\n+\t\t\t\t\t\t\t\t&& (Math.abs(root - previousEventTime) <= convergence)) {\n+\t\t\t\t\t\t\tta = tb;\n+\t\t\t\t\t\t\tga = gb;\n+\t\t\t\t\t\t} else if (Double.isNaN(previousEventTime)\n+\t\t\t\t\t\t\t\t|| (Math.abs(previousEventTime - root) > convergence)) {\n+\t\t\t\t\t\t\tpendingEventTime = root;\n+\t\t\t\t\t\t\tif (pendingEvent\n+\t\t\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\t\t\treturn false;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tpendingEvent = true;\n+\t\t\t\t\t\t\treturn true;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tta = tb;\n+\t\t\t\t\t\tga = gb;\n+\t\t\t\t\t}\n+\t\t\t\t\tfinal UnivariateRealFunction f = new UnivariateRealFunction() {\n                         public double value(final double t) throws FunctionEvaluationException {\n                             try {\n                                 interpolator.setInterpolatedTime(t);\n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\t2018-12-01 06:00:01.507483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_511/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\t2018-12-01 06:44:39.901222347 -0500\n@@ -289,7 +289,6 @@\n       }\n \n       if (filteredH > maxStep) {\n-          filteredH = maxStep;\n       } else if (filteredH < -maxStep) {\n           filteredH = -maxStep;\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java", 
          "line": 292, 
          "faulty": "filteredH=maxStep;", 
          "type": "Delete", 
          "seed": "stepSize=filterStep(stepSize,forward,true);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 214, 
          "faulty": "final UnivariateRealFunction f=new UnivariateRealFunction(){\n  public double value(  final double t) throws FunctionEvaluationException {\n    try {\n      interpolator.setInterpolatedTime(t);\n      return handler.g(t,interpolator.getInterpolatedState());\n    }\n catch (    DerivativeException e) {\n      throw new FunctionEvaluationException(e,t);\n    }\ncatch (    EventException e) {\n      throw new FunctionEvaluationException(e,t);\n    }\n  }\n}\n;", 
          "type": "InsertBefore", 
          "seed": "if (g0Positive ^ (gb >= 0)) {\n  if (ga * gb > 0) {\n    final double epsilon=(forward ? 0.25 : -0.25) * convergence;\n    for (int k=0; (k < 4) && (ga * gb > 0); ++k) {\n      ta+=epsilon;\n      interpolator.setInterpolatedTime(ta);\n      ga=handler.g(ta,interpolator.getInterpolatedState());\n    }\n    if (ga * gb > 0) {\n      throw MathRuntimeException.createInternalError(null);\n    }\n  }\n  increasing=gb >= ga;\n  final UnivariateRealFunction f=new UnivariateRealFunction(){\n    public double value(    final double t) throws FunctionEvaluationException {\n      try {\n        interpolator.setInterpolatedTime(t);\n        return handler.g(t,interpolator.getInterpolatedState());\n      }\n catch (      DerivativeException e) {\n        throw new FunctionEvaluationException(e,t);\n      }\ncatch (      EventException e) {\n        throw new FunctionEvaluationException(e,t);\n      }\n    }\n  }\n;\n  final BrentSolver solver=new BrentSolver();\n  solver.setAbsoluteAccuracy(convergence);\n  solver.setMaximalIterationCount(maxIterationCount);\n  final double root=(ta <= tb) ? solver.solve(f,ta,tb) : solver.solve(f,tb,ta);\n  if ((Math.abs(root - ta) <= convergence) && (Math.abs(root - previousEventTime) <= convergence)) {\n    ta=tb;\n    ga=gb;\n  }\n else   if (Double.isNaN(previousEventTime) || (Math.abs(previousEventTime - root) > convergence)) {\n    pendingEventTime=root;\n    if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n      return false;\n    }\n    pendingEvent=true;\n    return true;\n  }\n}\n else {\n  ta=tb;\n  ga=gb;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/CombinedEventsManager.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_249/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/CombinedEventsManager.java\t2018-12-01 06:22:58.790873757 -0500\n@@ -214,7 +214,9 @@\n     public boolean stop() {\n         for (EventState state : states) {\n             if (state.stop()) {\n-                return true;\n+                if (state.stop()) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n             }\n         }\n         return false;\n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_249/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:22:58.794873775 -0500\n@@ -208,7 +208,11 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\t2018-12-01 06:00:01.507483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_249/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\t2018-12-01 06:22:58.794873775 -0500\n@@ -147,11 +147,6 @@\n    * ignore the value and compute the initial step size by itself)\n    */\n   public void setInitialStepSize(final double initialStepSize) {\n-    if ((initialStepSize < minStep) || (initialStepSize > maxStep)) {\n-      initialStep = -1.0;\n-    } else {\n-      initialStep = initialStepSize;\n-    }\n   }\n \n   /** Perform some sanity checks on the integration parameters.\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/CombinedEventsManager.java", 
          "line": 217, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "if (state.stop()) {\n  return true;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java", 
          "line": 150, 
          "faulty": "if ((initialStepSize < minStep) || (initialStepSize > maxStep)) {\n  initialStep=-1.0;\n}\n else {\n  initialStep=initialStepSize;\n}", 
          "type": "Delete", 
          "seed": "if ((initialStepSize < minStep) || (initialStepSize > maxStep)) {\n  initialStep=-1.0;\n}\n else {\n  initialStep=initialStepSize;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_1355/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 07:54:10.825578549 -0500\n@@ -208,7 +208,11 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n@@ -337,8 +341,8 @@\n         pendingEvent      = false;\n         pendingEventTime  = Double.NaN;\n \n-        return (nextAction == EventHandler.RESET_STATE) ||\n-               (nextAction == EventHandler.RESET_DERIVATIVES);\n+        return (nextAction == EventHandler.RESET_STATE)\n+\t\t\t\t|| (nextAction == EventHandler.RESET_DERIVATIVES);\n \n     }\n \n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 340, 
          "faulty": "return (nextAction == EventHandler.RESET_STATE) || (nextAction == EventHandler.RESET_DERIVATIVES);", 
          "type": "Replace", 
          "seed": "return (nextAction == EventHandler.RESET_STATE) || (nextAction == EventHandler.RESET_DERIVATIVES);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_1239/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 07:44:15.514596746 -0500\n@@ -223,9 +223,14 @@\n                             }\n                         }\n                     };\n-                    final BrentSolver solver = new BrentSolver();\n+                    forward = interpolator.isForward();\n+\t\t\t\t\tfinal BrentSolver solver = new BrentSolver();\n                     solver.setAbsoluteAccuracy(convergence);\n-                    solver.setMaximalIterationCount(maxIterationCount);\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\tsolver.setMaximalIterationCount(maxIterationCount);\n                     final double root = (ta <= tb) ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta);\n                     if ((Math.abs(root - ta) <= convergence) &&\n                          (Math.abs(root - previousEventTime) <= convergence)) {\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 228, 
          "faulty": "solver.setMaximalIterationCount(maxIterationCount);", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 226, 
          "faulty": "final BrentSolver solver=new BrentSolver();", 
          "type": "InsertBefore", 
          "seed": "forward=interpolator.isForward();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_300/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:26:56.556018055 -0500\n@@ -208,7 +208,11 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n@@ -335,7 +339,8 @@\n             handler.resetState(t, y);\n         }\n         pendingEvent      = false;\n-        pendingEventTime  = Double.NaN;\n+        g0 = handler.g(t, y);\n+\t\tpendingEventTime  = Double.NaN;\n \n         return (nextAction == EventHandler.RESET_STATE) ||\n                (nextAction == EventHandler.RESET_DERIVATIVES);\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 338, 
          "faulty": "pendingEventTime=Double.NaN;", 
          "type": "InsertBefore", 
          "seed": "g0=handler.g(t,y);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\t2018-12-01 06:00:05.075483730 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_371/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\t2018-12-01 06:33:01.577794261 -0500\n@@ -172,7 +172,18 @@\n         if (manager.evaluateStep(interpolator)) {\n             final double dt = manager.getEventTime() - stepStart;\n             if (Math.abs(dt) <= Math.ulp(stepStart)) {\n-                // we cannot simply truncate the step, reject the current computation\n+                for (int k = 1; k < stages; ++k) {\n+\t\t\t\t\tfor (int j = 0; j < y0.length; ++j) {\n+\t\t\t\t\t\tdouble sum = a[k - 1][0] * yDotK[0][j];\n+\t\t\t\t\t\tfor (int l = 1; l < k; ++l) {\n+\t\t\t\t\t\t\tsum += a[k - 1][l] * yDotK[l][j];\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tyTmp[j] = y[j] + stepSize * sum;\n+\t\t\t\t\t}\n+\t\t\t\t\tcomputeDerivatives(stepStart + c[k - 1] * stepSize, yTmp,\n+\t\t\t\t\t\t\tyDotK[k]);\n+\t\t\t\t}\n+\t\t\t\t// we cannot simply truncate the step, reject the current computation\n                 // and let the loop compute another state with the truncated step.\n                 // it is so small (much probably exactly 0 due to limited accuracy)\n                 // that the code above would fail handling it.\n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_371/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:33:01.581794281 -0500\n@@ -208,7 +208,11 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java", 
          "line": 180, 
          "faulty": "loop=false;", 
          "type": "InsertBefore", 
          "seed": "for (int k=1; k < stages; ++k) {\n  for (int j=0; j < y0.length; ++j) {\n    double sum=a[k - 1][0] * yDotK[0][j];\n    for (int l=1; l < k; ++l) {\n      sum+=a[k - 1][l] * yDotK[l][j];\n    }\n    yTmp[j]=y[j] + stepSize * sum;\n  }\n  computeDerivatives(stepStart + c[k - 1] * stepSize,yTmp,yDotK[k]);\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_1128/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 07:34:48.723811272 -0500\n@@ -208,7 +208,8 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    pendingEvent = true;\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n@@ -227,7 +228,8 @@\n                     solver.setAbsoluteAccuracy(convergence);\n                     solver.setMaximalIterationCount(maxIterationCount);\n                     final double root = (ta <= tb) ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta);\n-                    if ((Math.abs(root - ta) <= convergence) &&\n+                    previousEventTime = Double.NaN;\n+\t\t\t\t\tif ((Math.abs(root - ta) <= convergence) &&\n                          (Math.abs(root - previousEventTime) <= convergence)) {\n                         // we have either found nothing or found (again ?) a past event, we simply ignore it\n                         ta = tb;\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 230, 
          "faulty": "if ((Math.abs(root - ta) <= convergence) && (Math.abs(root - previousEventTime) <= convergence)) {\n  ta=tb;\n  ga=gb;\n}\n else if (Double.isNaN(previousEventTime) || (Math.abs(previousEventTime - root) > convergence)) {\n  pendingEventTime=root;\n  if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n    return false;\n  }\n  pendingEvent=true;\n  return true;\n}", 
          "type": "InsertBefore", 
          "seed": "previousEventTime=Double.NaN;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "pendingEvent=true;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/CombinedEventsManager.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_1413/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/CombinedEventsManager.java\t2018-12-01 07:58:53.662985984 -0500\n@@ -150,7 +150,10 @@\n             for (EventState state : states) {\n \n                 if (state.evaluateStep(interpolator)) {\n-                    if (first == null) {\n+                    if (states.isEmpty()) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (first == null) {\n                         first = state;\n                     } else {\n                         if (interpolator.isForward()) {\n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_1413/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 07:58:53.662985984 -0500\n@@ -208,7 +208,11 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/CombinedEventsManager.java", 
          "line": 153, 
          "faulty": "if (first == null) {\n  first=state;\n}\n else {\n  if (interpolator.isForward()) {\n    if (state.getEventTime() < first.getEventTime()) {\n      first=state;\n    }\n  }\n else {\n    if (state.getEventTime() > first.getEventTime()) {\n      first=state;\n    }\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "if (states.isEmpty()) {\n  return false;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/CombinedEventsManager.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_490/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/CombinedEventsManager.java\t2018-12-01 06:42:54.124703097 -0500\n@@ -151,7 +151,23 @@\n \n                 if (state.evaluateStep(interpolator)) {\n                     if (first == null) {\n-                        first = state;\n+                        if (state.evaluateStep(interpolator)) {\n+\t\t\t\t\t\t\tif (first == null) {\n+\t\t\t\t\t\t\t\tfirst = state;\n+\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\tif (interpolator.isForward()) {\n+\t\t\t\t\t\t\t\t\tif (state.getEventTime() < first\n+\t\t\t\t\t\t\t\t\t\t\t.getEventTime()) {\n+\t\t\t\t\t\t\t\t\t\tfirst = state;\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\tif (state.getEventTime() > first\n+\t\t\t\t\t\t\t\t\t\t\t.getEventTime()) {\n+\t\t\t\t\t\t\t\t\t\tfirst = state;\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n                     } else {\n                         if (interpolator.isForward()) {\n                             if (state.getEventTime() < first.getEventTime()) {\n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\t2018-12-01 06:00:05.075483730 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_490/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\t2018-12-01 06:42:54.128703117 -0500\n@@ -172,7 +172,8 @@\n         if (manager.evaluateStep(interpolator)) {\n             final double dt = manager.getEventTime() - stepStart;\n             if (Math.abs(dt) <= Math.ulp(stepStart)) {\n-                // we cannot simply truncate the step, reject the current computation\n+                lastStep = false;\n+\t\t\t\t// we cannot simply truncate the step, reject the current computation\n                 // and let the loop compute another state with the truncated step.\n                 // it is so small (much probably exactly 0 due to limited accuracy)\n                 // that the code above would fail handling it.\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/CombinedEventsManager.java", 
          "line": 154, 
          "faulty": "first=state;", 
          "type": "Replace", 
          "seed": "if (state.evaluateStep(interpolator)) {\n  if (first == null) {\n    first=state;\n  }\n else {\n    if (interpolator.isForward()) {\n      if (state.getEventTime() < first.getEventTime()) {\n        first=state;\n      }\n    }\n else {\n      if (state.getEventTime() > first.getEventTime()) {\n        first=state;\n      }\n    }\n  }\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java", 
          "line": 180, 
          "faulty": "loop=false;", 
          "type": "InsertBefore", 
          "seed": "lastStep=false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_591/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:51:03.711115564 -0500\n@@ -208,10 +208,68 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n-                    final UnivariateRealFunction f = new UnivariateRealFunction() {\n+                    if (g0Positive ^ (gb >= 0)) {\n+\t\t\t\t\t\tif (ga * gb > 0) {\n+\t\t\t\t\t\t\tfinal double epsilon = (forward ? 0.25 : -0.25)\n+\t\t\t\t\t\t\t\t\t* convergence;\n+\t\t\t\t\t\t\tfor (int k = 0; (k < 4) && (ga * gb > 0); ++k) {\n+\t\t\t\t\t\t\t\tta += epsilon;\n+\t\t\t\t\t\t\t\tinterpolator.setInterpolatedTime(ta);\n+\t\t\t\t\t\t\t\tga = handler.g(ta,\n+\t\t\t\t\t\t\t\t\t\tinterpolator.getInterpolatedState());\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tif (ga * gb > 0) {\n+\t\t\t\t\t\t\t\tthrow MathRuntimeException\n+\t\t\t\t\t\t\t\t\t\t.createInternalError(null);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tincreasing = gb >= ga;\n+\t\t\t\t\t\tfinal UnivariateRealFunction f = new UnivariateRealFunction() {\n+\t\t\t\t\t\t\tpublic double value(final double t)\n+\t\t\t\t\t\t\t\t\tthrows FunctionEvaluationException {\n+\t\t\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\t\t\tinterpolator.setInterpolatedTime(t);\n+\t\t\t\t\t\t\t\t\treturn handler\n+\t\t\t\t\t\t\t\t\t\t\t.g(t, interpolator\n+\t\t\t\t\t\t\t\t\t\t\t\t\t.getInterpolatedState());\n+\t\t\t\t\t\t\t\t} catch (DerivativeException e) {\n+\t\t\t\t\t\t\t\t\tthrow new FunctionEvaluationException(e, t);\n+\t\t\t\t\t\t\t\t} catch (EventException e) {\n+\t\t\t\t\t\t\t\t\tthrow new FunctionEvaluationException(e, t);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t};\n+\t\t\t\t\t\tfinal BrentSolver solver = new BrentSolver();\n+\t\t\t\t\t\tsolver.setAbsoluteAccuracy(convergence);\n+\t\t\t\t\t\tsolver.setMaximalIterationCount(maxIterationCount);\n+\t\t\t\t\t\tfinal double root = (ta <= tb) ? solver\n+\t\t\t\t\t\t\t\t.solve(f, ta, tb) : solver.solve(f, tb, ta);\n+\t\t\t\t\t\tif ((Math.abs(root - ta) <= convergence)\n+\t\t\t\t\t\t\t\t&& (Math.abs(root - previousEventTime) <= convergence)) {\n+\t\t\t\t\t\t\tta = tb;\n+\t\t\t\t\t\t\tga = gb;\n+\t\t\t\t\t\t} else if (Double.isNaN(previousEventTime)\n+\t\t\t\t\t\t\t\t|| (Math.abs(previousEventTime - root) > convergence)) {\n+\t\t\t\t\t\t\tpendingEventTime = root;\n+\t\t\t\t\t\t\tif (pendingEvent\n+\t\t\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\t\t\treturn false;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tpendingEvent = true;\n+\t\t\t\t\t\t\treturn true;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tta = tb;\n+\t\t\t\t\t\tga = gb;\n+\t\t\t\t\t}\n+\t\t\t\t\tfinal UnivariateRealFunction f = new UnivariateRealFunction() {\n                         public double value(final double t) throws FunctionEvaluationException {\n                             try {\n                                 interpolator.setInterpolatedTime(t);\n@@ -335,8 +393,6 @@\n             handler.resetState(t, y);\n         }\n         pendingEvent      = false;\n-        pendingEventTime  = Double.NaN;\n-\n         return (nextAction == EventHandler.RESET_STATE) ||\n                (nextAction == EventHandler.RESET_DERIVATIVES);\n \n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 338, 
          "faulty": "pendingEventTime=Double.NaN;", 
          "type": "Delete", 
          "seed": "g0=handler.g(t,y);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 214, 
          "faulty": "final UnivariateRealFunction f=new UnivariateRealFunction(){\n  public double value(  final double t) throws FunctionEvaluationException {\n    try {\n      interpolator.setInterpolatedTime(t);\n      return handler.g(t,interpolator.getInterpolatedState());\n    }\n catch (    DerivativeException e) {\n      throw new FunctionEvaluationException(e,t);\n    }\ncatch (    EventException e) {\n      throw new FunctionEvaluationException(e,t);\n    }\n  }\n}\n;", 
          "type": "InsertBefore", 
          "seed": "if (g0Positive ^ (gb >= 0)) {\n  if (ga * gb > 0) {\n    final double epsilon=(forward ? 0.25 : -0.25) * convergence;\n    for (int k=0; (k < 4) && (ga * gb > 0); ++k) {\n      ta+=epsilon;\n      interpolator.setInterpolatedTime(ta);\n      ga=handler.g(ta,interpolator.getInterpolatedState());\n    }\n    if (ga * gb > 0) {\n      throw MathRuntimeException.createInternalError(null);\n    }\n  }\n  increasing=gb >= ga;\n  final UnivariateRealFunction f=new UnivariateRealFunction(){\n    public double value(    final double t) throws FunctionEvaluationException {\n      try {\n        interpolator.setInterpolatedTime(t);\n        return handler.g(t,interpolator.getInterpolatedState());\n      }\n catch (      DerivativeException e) {\n        throw new FunctionEvaluationException(e,t);\n      }\ncatch (      EventException e) {\n        throw new FunctionEvaluationException(e,t);\n      }\n    }\n  }\n;\n  final BrentSolver solver=new BrentSolver();\n  solver.setAbsoluteAccuracy(convergence);\n  solver.setMaximalIterationCount(maxIterationCount);\n  final double root=(ta <= tb) ? solver.solve(f,ta,tb) : solver.solve(f,tb,ta);\n  if ((Math.abs(root - ta) <= convergence) && (Math.abs(root - previousEventTime) <= convergence)) {\n    ta=tb;\n    ga=gb;\n  }\n else   if (Double.isNaN(previousEventTime) || (Math.abs(previousEventTime - root) > convergence)) {\n    pendingEventTime=root;\n    if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n      return false;\n    }\n    pendingEvent=true;\n    return true;\n  }\n}\n else {\n  ta=tb;\n  ga=gb;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_157/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:15:34.492761554 -0500\n@@ -225,7 +225,11 @@\n                     };\n                     final BrentSolver solver = new BrentSolver();\n                     solver.setAbsoluteAccuracy(convergence);\n-                    solver.setMaximalIterationCount(maxIterationCount);\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\tsolver.setMaximalIterationCount(maxIterationCount);\n                     final double root = (ta <= tb) ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta);\n                     if ((Math.abs(root - ta) <= convergence) &&\n                          (Math.abs(root - previousEventTime) <= convergence)) {\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 228, 
          "faulty": "solver.setMaximalIterationCount(maxIterationCount);", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\t2018-12-01 06:00:05.075483730 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_1258/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\t2018-12-01 07:45:43.543033144 -0500\n@@ -172,7 +172,18 @@\n         if (manager.evaluateStep(interpolator)) {\n             final double dt = manager.getEventTime() - stepStart;\n             if (Math.abs(dt) <= Math.ulp(stepStart)) {\n-                // we cannot simply truncate the step, reject the current computation\n+                for (int k = 1; k < stages; ++k) {\n+\t\t\t\t\tfor (int j = 0; j < y0.length; ++j) {\n+\t\t\t\t\t\tdouble sum = a[k - 1][0] * yDotK[0][j];\n+\t\t\t\t\t\tfor (int l = 1; l < k; ++l) {\n+\t\t\t\t\t\t\tsum += a[k - 1][l] * yDotK[l][j];\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tyTmp[j] = y[j] + stepSize * sum;\n+\t\t\t\t\t}\n+\t\t\t\t\tcomputeDerivatives(stepStart + c[k - 1] * stepSize, yTmp,\n+\t\t\t\t\t\t\tyDotK[k]);\n+\t\t\t\t}\n+\t\t\t\t// we cannot simply truncate the step, reject the current computation\n                 // and let the loop compute another state with the truncated step.\n                 // it is so small (much probably exactly 0 due to limited accuracy)\n                 // that the code above would fail handling it.\n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_1258/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 07:45:43.547033163 -0500\n@@ -208,7 +208,11 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/sampling/DummyStepInterpolator.java\t2018-12-01 06:00:01.511483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_1258/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/sampling/DummyStepInterpolator.java\t2018-12-01 07:45:43.547033163 -0500\n@@ -104,7 +104,9 @@\n   @Override\n   protected void computeInterpolatedStateAndDerivatives(final double theta, final double oneMinusThetaH)\n     throws DerivativeException {\n-      System.arraycopy(currentState,      0, interpolatedState,       0, currentState.length);\n+      System.arraycopy(currentDerivative, 0, interpolatedDerivatives, 0,\n+\t\t\t\tcurrentDerivative.length);\n+\tSystem.arraycopy(currentState,      0, interpolatedState,       0, currentState.length);\n       System.arraycopy(currentDerivative, 0, interpolatedDerivatives, 0, currentDerivative.length);\n   }\n \n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\t2018-12-01 06:00:01.507483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_1258/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\t2018-12-01 07:45:43.547033163 -0500\n@@ -150,7 +150,7 @@\n     if ((initialStepSize < minStep) || (initialStepSize > maxStep)) {\n       initialStep = -1.0;\n     } else {\n-      initialStep = initialStepSize;\n+      resetEvaluations();\n     }\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/sampling/DummyStepInterpolator.java", 
          "line": 107, 
          "faulty": "System.arraycopy(currentState,0,interpolatedState,0,currentState.length);", 
          "type": "InsertBefore", 
          "seed": "System.arraycopy(currentDerivative,0,interpolatedDerivatives,0,currentDerivative.length);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java", 
          "line": 153, 
          "faulty": "initialStep=initialStepSize;", 
          "type": "Replace", 
          "seed": "resetEvaluations();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java", 
          "line": 180, 
          "faulty": "loop=false;", 
          "type": "InsertBefore", 
          "seed": "for (int k=1; k < stages; ++k) {\n  for (int j=0; j < y0.length; ++j) {\n    double sum=a[k - 1][0] * yDotK[0][j];\n    for (int l=1; l < k; ++l) {\n      sum+=a[k - 1][l] * yDotK[l][j];\n    }\n    yTmp[j]=y[j] + stepSize * sum;\n  }\n  computeDerivatives(stepStart + c[k - 1] * stepSize,yTmp,yDotK[k]);\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_772/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 07:05:42.483364668 -0500\n@@ -208,7 +208,8 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    pendingEvent = true;\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/sampling/DummyStepInterpolator.java\t2018-12-01 06:00:01.511483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_772/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/sampling/DummyStepInterpolator.java\t2018-12-01 07:05:42.483364668 -0500\n@@ -105,7 +105,8 @@\n   protected void computeInterpolatedStateAndDerivatives(final double theta, final double oneMinusThetaH)\n     throws DerivativeException {\n       System.arraycopy(currentState,      0, interpolatedState,       0, currentState.length);\n-      System.arraycopy(currentDerivative, 0, interpolatedDerivatives, 0, currentDerivative.length);\n+      interpolatedTime = Double.NaN;\n+\tSystem.arraycopy(currentDerivative, 0, interpolatedDerivatives, 0, currentDerivative.length);\n   }\n \n   /** Write the instance to an output channel.\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/sampling/DummyStepInterpolator.java", 
          "line": 108, 
          "faulty": "System.arraycopy(currentDerivative,0,interpolatedDerivatives,0,currentDerivative.length);", 
          "type": "InsertBefore", 
          "seed": "interpolatedTime=Double.NaN;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "pendingEvent=true;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_51/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:06:24.337894755 -0500\n@@ -208,7 +208,11 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_675/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:57:31.872992506 -0500\n@@ -208,7 +208,11 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\t2018-12-01 06:00:01.507483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_675/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\t2018-12-01 06:57:31.872992506 -0500\n@@ -289,7 +289,6 @@\n       }\n \n       if (filteredH > maxStep) {\n-          filteredH = maxStep;\n       } else if (filteredH < -maxStep) {\n           filteredH = -maxStep;\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java", 
          "line": 292, 
          "faulty": "filteredH=maxStep;", 
          "type": "Delete", 
          "seed": "stepSize=filterStep(stepSize,forward,true);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\t2018-12-01 06:00:05.075483730 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_484/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\t2018-12-01 06:42:25.176560283 -0500\n@@ -172,12 +172,7 @@\n         if (manager.evaluateStep(interpolator)) {\n             final double dt = manager.getEventTime() - stepStart;\n             if (Math.abs(dt) <= Math.ulp(stepStart)) {\n-                // we cannot simply truncate the step, reject the current computation\n-                // and let the loop compute another state with the truncated step.\n-                // it is so small (much probably exactly 0 due to limited accuracy)\n-                // that the code above would fail handling it.\n-                // So we set up an artificial 0 size step by copying states\n-                loop     = false;\n+                sanityChecks(equations, t0, y0, t, y);\n             } else {\n                 // reject the step to match exactly the next switch time\n                 stepSize = dt;\n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_484/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:42:25.180560303 -0500\n@@ -208,7 +208,8 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    pendingEvent = true;\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java", 
          "line": 180, 
          "faulty": "loop=false;", 
          "type": "Replace", 
          "seed": "sanityChecks(equations,t0,y0,t,y);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "pendingEvent=true;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_398/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:35:18.174459408 -0500\n@@ -188,7 +188,11 @@\n                 if (g0Positive ^ (gb >= 0)) {\n                     // there is a sign change: an event is expected during this step\n \n-                    if (ga * gb > 0) {\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (ga * gb > 0) {\n                         // this is a corner case:\n                         // - there was an event near ta,\n                         // - there is another event between ta and tb\n@@ -208,7 +212,11 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 191, 
          "faulty": "if (ga * gb > 0) {\n  final double epsilon=(forward ? 0.25 : -0.25) * convergence;\n  for (int k=0; (k < 4) && (ga * gb > 0); ++k) {\n    ta+=epsilon;\n    interpolator.setInterpolatedTime(ta);\n    ga=handler.g(ta,interpolator.getInterpolatedState());\n  }\n  if (ga * gb > 0) {\n    throw MathRuntimeException.createInternalError(null);\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_1372/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 07:55:41.146029531 -0500\n@@ -208,7 +208,11 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\t2018-12-01 06:00:01.507483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_1372/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\t2018-12-01 07:55:41.146029531 -0500\n@@ -289,7 +289,10 @@\n       }\n \n       if (filteredH > maxStep) {\n-          filteredH = maxStep;\n+          if (initialStep > 0) {\n+\t\t\treturn forward ? initialStep : -initialStep;\n+\t\t}\n+\t\tfilteredH = maxStep;\n       } else if (filteredH < -maxStep) {\n           filteredH = -maxStep;\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java", 
          "line": 292, 
          "faulty": "filteredH=maxStep;", 
          "type": "InsertBefore", 
          "seed": "if (initialStep > 0) {\n  return forward ? initialStep : -initialStep;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/CombinedEventsManager.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_913/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/CombinedEventsManager.java\t2018-12-01 07:17:06.590648351 -0500\n@@ -151,7 +151,23 @@\n \n                 if (state.evaluateStep(interpolator)) {\n                     if (first == null) {\n-                        first = state;\n+                        if (state.evaluateStep(interpolator)) {\n+\t\t\t\t\t\t\tif (first == null) {\n+\t\t\t\t\t\t\t\tfirst = state;\n+\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\tif (interpolator.isForward()) {\n+\t\t\t\t\t\t\t\t\tif (state.getEventTime() < first\n+\t\t\t\t\t\t\t\t\t\t\t.getEventTime()) {\n+\t\t\t\t\t\t\t\t\t\tfirst = state;\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\tif (state.getEventTime() > first\n+\t\t\t\t\t\t\t\t\t\t\t.getEventTime()) {\n+\t\t\t\t\t\t\t\t\t\tfirst = state;\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n                     } else {\n                         if (interpolator.isForward()) {\n                             if (state.getEventTime() < first.getEventTime()) {\n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\t2018-12-01 06:00:01.507483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_913/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\t2018-12-01 07:17:06.594648371 -0500\n@@ -207,7 +207,8 @@\n       throws DerivativeException {\n \n     if (initialStep > 0) {\n-      // use the user provided value\n+      computeDerivatives(stepStart + stepSize, y1, yDot1);\n+\t// use the user provided value\n       return forward ? initialStep : -initialStep;\n     }\n \n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java", 
          "line": 211, 
          "faulty": "return forward ? initialStep : -initialStep;", 
          "type": "InsertBefore", 
          "seed": "computeDerivatives(stepStart + stepSize,y1,yDot1);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/CombinedEventsManager.java", 
          "line": 154, 
          "faulty": "first=state;", 
          "type": "Replace", 
          "seed": "if (state.evaluateStep(interpolator)) {\n  if (first == null) {\n    first=state;\n  }\n else {\n    if (interpolator.isForward()) {\n      if (state.getEventTime() < first.getEventTime()) {\n        first=state;\n      }\n    }\n else {\n      if (state.getEventTime() > first.getEventTime()) {\n        first=state;\n      }\n    }\n  }\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\t2018-12-01 06:00:05.075483730 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_672/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\t2018-12-01 06:57:21.328941814 -0500\n@@ -120,7 +120,10 @@\n       rki.reinitialize(this, yTmp, yDotK, forward);\n       interpolator = rki;\n     } else {\n-      interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);\n+      for (StepHandler handler : stepHandlers) {\n+\t\t\thandler.reset();\n+\t\t}\n+\tinterpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);\n     }\n     interpolator.storeTime(t0);\n \n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_672/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:57:21.328941814 -0500\n@@ -208,7 +208,11 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java", 
          "line": 123, 
          "faulty": "interpolator=new DummyStepInterpolator(yTmp,yDotK[stages - 1],forward);", 
          "type": "InsertBefore", 
          "seed": "for (StepHandler handler : stepHandlers) {\n  handler.reset();\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_628/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:53:51.219928654 -0500\n@@ -208,7 +208,11 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n@@ -335,8 +339,6 @@\n             handler.resetState(t, y);\n         }\n         pendingEvent      = false;\n-        pendingEventTime  = Double.NaN;\n-\n         return (nextAction == EventHandler.RESET_STATE) ||\n                (nextAction == EventHandler.RESET_DERIVATIVES);\n \n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\t2018-12-01 06:00:01.507483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_628/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\t2018-12-01 06:53:51.219928654 -0500\n@@ -207,7 +207,8 @@\n       throws DerivativeException {\n \n     if (initialStep > 0) {\n-      // use the user provided value\n+      stepSize = Math.sqrt(minStep * maxStep);\n+\t// use the user provided value\n       return forward ? initialStep : -initialStep;\n     }\n \n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java", 
          "line": 211, 
          "faulty": "return forward ? initialStep : -initialStep;", 
          "type": "InsertBefore", 
          "seed": "stepSize=Math.sqrt(minStep * maxStep);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 338, 
          "faulty": "pendingEventTime=Double.NaN;", 
          "type": "Delete", 
          "seed": "g0Positive=increasing;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_644/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:55:07.504297233 -0500\n@@ -208,7 +208,8 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    pendingEvent = true;\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n@@ -297,8 +298,7 @@\n         g0 = handler.g(t, y);\n \n         if (pendingEvent) {\n-            // force the sign to its value \"just after the event\"\n-            previousEventTime = t;\n+            t0 = t;\n             g0Positive        = increasing;\n             nextAction        = handler.eventOccurred(t, y, !(increasing ^ forward));\n         } else {\n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\t2018-12-01 06:00:05.075483730 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_644/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\t2018-12-01 06:55:07.508297252 -0500\n@@ -292,12 +292,7 @@\n           if (manager.evaluateStep(interpolator)) {\n               final double dt = manager.getEventTime() - stepStart;\n               if (Math.abs(dt) <= Math.ulp(stepStart)) {\n-                  // we cannot simply truncate the step, reject the current computation\n-                  // and let the loop compute another state with the truncated step.\n-                  // it is so small (much probably exactly 0 due to limited accuracy)\n-                  // that the code above would fail handling it.\n-                  // So we set up an artificial 0 size step by copying states\n-                  loop     = false;\n+                  super.sanityChecks(equations, t0, y0, t, y);\n               } else {\n                   // reject the step to match exactly the next switch time\n                   hNew = dt;\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java", 
          "line": 300, 
          "faulty": "loop=false;", 
          "type": "Replace", 
          "seed": "super.sanityChecks(equations,t0,y0,t,y);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "pendingEvent=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 301, 
          "faulty": "previousEventTime=t;", 
          "type": "Replace", 
          "seed": "t0=t;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_550/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:47:51.618168486 -0500\n@@ -208,7 +208,11 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n@@ -300,7 +304,8 @@\n             // force the sign to its value \"just after the event\"\n             previousEventTime = t;\n             g0Positive        = increasing;\n-            nextAction        = handler.eventOccurred(t, y, !(increasing ^ forward));\n+            g0 = handler.g(t, y);\n+\t\t\tnextAction        = handler.eventOccurred(t, y, !(increasing ^ forward));\n         } else {\n             g0Positive = g0 >= 0;\n             nextAction = EventHandler.CONTINUE;\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 303, 
          "faulty": "nextAction=handler.eventOccurred(t,y,!(increasing ^ forward));", 
          "type": "InsertBefore", 
          "seed": "g0=handler.g(t,y);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_1298/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 07:49:12.836078267 -0500\n@@ -208,7 +208,11 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n@@ -331,7 +335,8 @@\n             return false;\n         }\n \n-        if (nextAction == EventHandler.RESET_STATE) {\n+        pendingEvent = true;\n+\t\tif (nextAction == EventHandler.RESET_STATE) {\n             handler.resetState(t, y);\n         }\n         pendingEvent      = false;\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 334, 
          "faulty": "if (nextAction == EventHandler.RESET_STATE) {\n  handler.resetState(t,y);\n}", 
          "type": "InsertBefore", 
          "seed": "pendingEvent=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_310/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:27:46.152254055 -0500\n@@ -208,10 +208,68 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n-                    final UnivariateRealFunction f = new UnivariateRealFunction() {\n+                    if (g0Positive ^ (gb >= 0)) {\n+\t\t\t\t\t\tif (ga * gb > 0) {\n+\t\t\t\t\t\t\tfinal double epsilon = (forward ? 0.25 : -0.25)\n+\t\t\t\t\t\t\t\t\t* convergence;\n+\t\t\t\t\t\t\tfor (int k = 0; (k < 4) && (ga * gb > 0); ++k) {\n+\t\t\t\t\t\t\t\tta += epsilon;\n+\t\t\t\t\t\t\t\tinterpolator.setInterpolatedTime(ta);\n+\t\t\t\t\t\t\t\tga = handler.g(ta,\n+\t\t\t\t\t\t\t\t\t\tinterpolator.getInterpolatedState());\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tif (ga * gb > 0) {\n+\t\t\t\t\t\t\t\tthrow MathRuntimeException\n+\t\t\t\t\t\t\t\t\t\t.createInternalError(null);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tincreasing = gb >= ga;\n+\t\t\t\t\t\tfinal UnivariateRealFunction f = new UnivariateRealFunction() {\n+\t\t\t\t\t\t\tpublic double value(final double t)\n+\t\t\t\t\t\t\t\t\tthrows FunctionEvaluationException {\n+\t\t\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\t\t\tinterpolator.setInterpolatedTime(t);\n+\t\t\t\t\t\t\t\t\treturn handler\n+\t\t\t\t\t\t\t\t\t\t\t.g(t, interpolator\n+\t\t\t\t\t\t\t\t\t\t\t\t\t.getInterpolatedState());\n+\t\t\t\t\t\t\t\t} catch (DerivativeException e) {\n+\t\t\t\t\t\t\t\t\tthrow new FunctionEvaluationException(e, t);\n+\t\t\t\t\t\t\t\t} catch (EventException e) {\n+\t\t\t\t\t\t\t\t\tthrow new FunctionEvaluationException(e, t);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t};\n+\t\t\t\t\t\tfinal BrentSolver solver = new BrentSolver();\n+\t\t\t\t\t\tsolver.setAbsoluteAccuracy(convergence);\n+\t\t\t\t\t\tsolver.setMaximalIterationCount(maxIterationCount);\n+\t\t\t\t\t\tfinal double root = (ta <= tb) ? solver\n+\t\t\t\t\t\t\t\t.solve(f, ta, tb) : solver.solve(f, tb, ta);\n+\t\t\t\t\t\tif ((Math.abs(root - ta) <= convergence)\n+\t\t\t\t\t\t\t\t&& (Math.abs(root - previousEventTime) <= convergence)) {\n+\t\t\t\t\t\t\tta = tb;\n+\t\t\t\t\t\t\tga = gb;\n+\t\t\t\t\t\t} else if (Double.isNaN(previousEventTime)\n+\t\t\t\t\t\t\t\t|| (Math.abs(previousEventTime - root) > convergence)) {\n+\t\t\t\t\t\t\tpendingEventTime = root;\n+\t\t\t\t\t\t\tif (pendingEvent\n+\t\t\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\t\t\treturn false;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tpendingEvent = true;\n+\t\t\t\t\t\t\treturn true;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tta = tb;\n+\t\t\t\t\t\tga = gb;\n+\t\t\t\t\t}\n+\t\t\t\t\tfinal UnivariateRealFunction f = new UnivariateRealFunction() {\n                         public double value(final double t) throws FunctionEvaluationException {\n                             try {\n                                 interpolator.setInterpolatedTime(t);\n@@ -235,7 +293,8 @@\n                     } else if (Double.isNaN(previousEventTime) ||\n                                (Math.abs(previousEventTime - root) > convergence)) {\n                         pendingEventTime = root;\n-                        if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+                        interpolator.setInterpolatedTime(ta);\n+\t\t\t\t\t\tif (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n                             // we were already waiting for this event which was\n                             // found during a previous call for a step that was\n                             // rejected, this step must now be accepted since it\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 238, 
          "faulty": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}", 
          "type": "InsertBefore", 
          "seed": "interpolator.setInterpolatedTime(ta);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 214, 
          "faulty": "final UnivariateRealFunction f=new UnivariateRealFunction(){\n  public double value(  final double t) throws FunctionEvaluationException {\n    try {\n      interpolator.setInterpolatedTime(t);\n      return handler.g(t,interpolator.getInterpolatedState());\n    }\n catch (    DerivativeException e) {\n      throw new FunctionEvaluationException(e,t);\n    }\ncatch (    EventException e) {\n      throw new FunctionEvaluationException(e,t);\n    }\n  }\n}\n;", 
          "type": "InsertBefore", 
          "seed": "if (g0Positive ^ (gb >= 0)) {\n  if (ga * gb > 0) {\n    final double epsilon=(forward ? 0.25 : -0.25) * convergence;\n    for (int k=0; (k < 4) && (ga * gb > 0); ++k) {\n      ta+=epsilon;\n      interpolator.setInterpolatedTime(ta);\n      ga=handler.g(ta,interpolator.getInterpolatedState());\n    }\n    if (ga * gb > 0) {\n      throw MathRuntimeException.createInternalError(null);\n    }\n  }\n  increasing=gb >= ga;\n  final UnivariateRealFunction f=new UnivariateRealFunction(){\n    public double value(    final double t) throws FunctionEvaluationException {\n      try {\n        interpolator.setInterpolatedTime(t);\n        return handler.g(t,interpolator.getInterpolatedState());\n      }\n catch (      DerivativeException e) {\n        throw new FunctionEvaluationException(e,t);\n      }\ncatch (      EventException e) {\n        throw new FunctionEvaluationException(e,t);\n      }\n    }\n  }\n;\n  final BrentSolver solver=new BrentSolver();\n  solver.setAbsoluteAccuracy(convergence);\n  solver.setMaximalIterationCount(maxIterationCount);\n  final double root=(ta <= tb) ? solver.solve(f,ta,tb) : solver.solve(f,tb,ta);\n  if ((Math.abs(root - ta) <= convergence) && (Math.abs(root - previousEventTime) <= convergence)) {\n    ta=tb;\n    ga=gb;\n  }\n else   if (Double.isNaN(previousEventTime) || (Math.abs(previousEventTime - root) > convergence)) {\n    pendingEventTime=root;\n    if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n      return false;\n    }\n    pendingEvent=true;\n    return true;\n  }\n}\n else {\n  ta=tb;\n  ga=gb;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_1179/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 07:39:02.865035166 -0500\n@@ -208,7 +208,8 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    pendingEvent = true;\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\t2018-12-01 06:00:05.075483730 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_1179/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\t2018-12-01 07:39:02.865035166 -0500\n@@ -292,12 +292,7 @@\n           if (manager.evaluateStep(interpolator)) {\n               final double dt = manager.getEventTime() - stepStart;\n               if (Math.abs(dt) <= Math.ulp(stepStart)) {\n-                  // we cannot simply truncate the step, reject the current computation\n-                  // and let the loop compute another state with the truncated step.\n-                  // it is so small (much probably exactly 0 due to limited accuracy)\n-                  // that the code above would fail handling it.\n-                  // So we set up an artificial 0 size step by copying states\n-                  loop     = false;\n+                  super.sanityChecks(equations, t0, y0, t, y);\n               } else {\n                   // reject the step to match exactly the next switch time\n                   hNew = dt;\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java", 
          "line": 300, 
          "faulty": "loop=false;", 
          "type": "Replace", 
          "seed": "super.sanityChecks(equations,t0,y0,t,y);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "pendingEvent=true;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/CombinedEventsManager.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_1376/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/CombinedEventsManager.java\t2018-12-01 07:55:57.138109223 -0500\n@@ -106,7 +106,8 @@\n      * @return true if manager is empty\n      */\n     public boolean isEmpty() {\n-        return states.isEmpty();\n+        first = null;\n+\t\treturn states.isEmpty();\n     }\n \n     /** Evaluate the impact of the proposed step on all managed\n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_1376/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 07:55:57.138109223 -0500\n@@ -208,7 +208,11 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\t2018-12-01 06:00:01.507483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_1376/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\t2018-12-01 07:55:57.138109223 -0500\n@@ -150,7 +150,7 @@\n     if ((initialStepSize < minStep) || (initialStepSize > maxStep)) {\n       initialStep = -1.0;\n     } else {\n-      initialStep = initialStepSize;\n+      return;\n     }\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java", 
          "line": 153, 
          "faulty": "initialStep=initialStepSize;", 
          "type": "Replace", 
          "seed": "return;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/CombinedEventsManager.java", 
          "line": 109, 
          "faulty": "return states.isEmpty();", 
          "type": "InsertBefore", 
          "seed": "first=null;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_778/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 07:06:03.743467371 -0500\n@@ -208,7 +208,11 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n@@ -232,21 +236,32 @@\n                         // we have either found nothing or found (again ?) a past event, we simply ignore it\n                         ta = tb;\n                         ga = gb;\n-                    } else if (Double.isNaN(previousEventTime) ||\n-                               (Math.abs(previousEventTime - root) > convergence)) {\n-                        pendingEventTime = root;\n-                        if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n-                            // we were already waiting for this event which was\n-                            // found during a previous call for a step that was\n-                            // rejected, this step must now be accepted since it\n-                            // properly ends exactly at the event occurrence\n-                            return false;\n-                        }\n-                        // either we were not waiting for the event or it has\n-                        // moved in such a way the step cannot be accepted\n-                        pendingEvent = true;\n-                        return true;\n-                    }\n+                    } else {\n+\t\t\t\t\t\tif (ga * gb > 0) {\n+\t\t\t\t\t\t\tfinal double epsilon = (forward ? 0.25 : -0.25)\n+\t\t\t\t\t\t\t\t\t* convergence;\n+\t\t\t\t\t\t\tfor (int k = 0; (k < 4) && (ga * gb > 0); ++k) {\n+\t\t\t\t\t\t\t\tta += epsilon;\n+\t\t\t\t\t\t\t\tinterpolator.setInterpolatedTime(ta);\n+\t\t\t\t\t\t\t\tga = handler.g(ta,\n+\t\t\t\t\t\t\t\t\t\tinterpolator.getInterpolatedState());\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tif (ga * gb > 0) {\n+\t\t\t\t\t\t\t\tthrow MathRuntimeException\n+\t\t\t\t\t\t\t\t\t\t.createInternalError(null);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tif (Double.isNaN(previousEventTime)\n+\t\t\t\t\t\t\t\t|| (Math.abs(previousEventTime - root) > convergence)) {\n+\t\t\t\t\t\t\tpendingEventTime = root;\n+\t\t\t\t\t\t\tif (pendingEvent\n+\t\t\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\t\t\treturn false;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tpendingEvent = true;\n+\t\t\t\t\t\t\treturn true;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n \n                 } else {\n                     // no sign change: there is no event for now\n@@ -331,9 +346,7 @@\n             return false;\n         }\n \n-        if (nextAction == EventHandler.RESET_STATE) {\n-            handler.resetState(t, y);\n-        }\n+        handler.resetState(t, y);\n         pendingEvent      = false;\n         pendingEventTime  = Double.NaN;\n \n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 235, 
          "faulty": "if (Double.isNaN(previousEventTime) || (Math.abs(previousEventTime - root) > convergence)) {\n  pendingEventTime=root;\n  if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n    return false;\n  }\n  pendingEvent=true;\n  return true;\n}", 
          "type": "InsertBefore", 
          "seed": "if (ga * gb > 0) {\n  final double epsilon=(forward ? 0.25 : -0.25) * convergence;\n  for (int k=0; (k < 4) && (ga * gb > 0); ++k) {\n    ta+=epsilon;\n    interpolator.setInterpolatedTime(ta);\n    ga=handler.g(ta,interpolator.getInterpolatedState());\n  }\n  if (ga * gb > 0) {\n    throw MathRuntimeException.createInternalError(null);\n  }\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 334, 
          "faulty": "if (nextAction == EventHandler.RESET_STATE) {\n  handler.resetState(t,y);\n}", 
          "type": "Replace", 
          "seed": "handler.resetState(t,y);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_646/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:55:12.848323020 -0500\n@@ -208,7 +208,11 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n@@ -232,21 +236,32 @@\n                         // we have either found nothing or found (again ?) a past event, we simply ignore it\n                         ta = tb;\n                         ga = gb;\n-                    } else if (Double.isNaN(previousEventTime) ||\n-                               (Math.abs(previousEventTime - root) > convergence)) {\n-                        pendingEventTime = root;\n-                        if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n-                            // we were already waiting for this event which was\n-                            // found during a previous call for a step that was\n-                            // rejected, this step must now be accepted since it\n-                            // properly ends exactly at the event occurrence\n-                            return false;\n-                        }\n-                        // either we were not waiting for the event or it has\n-                        // moved in such a way the step cannot be accepted\n-                        pendingEvent = true;\n-                        return true;\n-                    }\n+                    } else {\n+\t\t\t\t\t\tif (ga * gb > 0) {\n+\t\t\t\t\t\t\tfinal double epsilon = (forward ? 0.25 : -0.25)\n+\t\t\t\t\t\t\t\t\t* convergence;\n+\t\t\t\t\t\t\tfor (int k = 0; (k < 4) && (ga * gb > 0); ++k) {\n+\t\t\t\t\t\t\t\tta += epsilon;\n+\t\t\t\t\t\t\t\tinterpolator.setInterpolatedTime(ta);\n+\t\t\t\t\t\t\t\tga = handler.g(ta,\n+\t\t\t\t\t\t\t\t\t\tinterpolator.getInterpolatedState());\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tif (ga * gb > 0) {\n+\t\t\t\t\t\t\t\tthrow MathRuntimeException\n+\t\t\t\t\t\t\t\t\t\t.createInternalError(null);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tif (Double.isNaN(previousEventTime)\n+\t\t\t\t\t\t\t\t|| (Math.abs(previousEventTime - root) > convergence)) {\n+\t\t\t\t\t\t\tpendingEventTime = root;\n+\t\t\t\t\t\t\tif (pendingEvent\n+\t\t\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\t\t\treturn false;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tpendingEvent = true;\n+\t\t\t\t\t\t\treturn true;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n \n                 } else {\n                     // no sign change: there is no event for now\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 247, 
          "faulty": "pendingEvent=true;", 
          "type": "Delete", 
          "seed": "if (Double.isNaN(previousEventTime) || (Math.abs(previousEventTime - root) > convergence)) {\n  pendingEventTime=root;\n  if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n    return false;\n  }\n  pendingEvent=true;\n  return true;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 235, 
          "faulty": "if (Double.isNaN(previousEventTime) || (Math.abs(previousEventTime - root) > convergence)) {\n  pendingEventTime=root;\n  if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n    return false;\n  }\n  pendingEvent=true;\n  return true;\n}", 
          "type": "InsertBefore", 
          "seed": "if (ga * gb > 0) {\n  final double epsilon=(forward ? 0.25 : -0.25) * convergence;\n  for (int k=0; (k < 4) && (ga * gb > 0); ++k) {\n    ta+=epsilon;\n    interpolator.setInterpolatedTime(ta);\n    ga=handler.g(ta,interpolator.getInterpolatedState());\n  }\n  if (ga * gb > 0) {\n    throw MathRuntimeException.createInternalError(null);\n  }\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\t2018-12-01 06:00:05.075483730 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_939/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\t2018-12-01 07:19:17.395289669 -0500\n@@ -172,7 +172,8 @@\n         if (manager.evaluateStep(interpolator)) {\n             final double dt = manager.getEventTime() - stepStart;\n             if (Math.abs(dt) <= Math.ulp(stepStart)) {\n-                // we cannot simply truncate the step, reject the current computation\n+                stepStart = Double.NaN;\n+\t\t\t\t// we cannot simply truncate the step, reject the current computation\n                 // and let the loop compute another state with the truncated step.\n                 // it is so small (much probably exactly 0 due to limited accuracy)\n                 // that the code above would fail handling it.\n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_939/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 07:19:17.395289669 -0500\n@@ -208,7 +208,11 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java", 
          "line": 180, 
          "faulty": "loop=false;", 
          "type": "InsertBefore", 
          "seed": "stepStart=Double.NaN;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_352/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:31:27.725338540 -0500\n@@ -208,7 +208,11 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 282, 
          "faulty": "return pendingEventTime;", 
          "type": "Replace", 
          "seed": "return pendingEventTime;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_235/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:22:00.154598249 -0500\n@@ -208,7 +208,11 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\t2018-12-01 06:00:05.075483730 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_235/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\t2018-12-01 06:22:00.154598249 -0500\n@@ -292,12 +292,6 @@\n           if (manager.evaluateStep(interpolator)) {\n               final double dt = manager.getEventTime() - stepStart;\n               if (Math.abs(dt) <= Math.ulp(stepStart)) {\n-                  // we cannot simply truncate the step, reject the current computation\n-                  // and let the loop compute another state with the truncated step.\n-                  // it is so small (much probably exactly 0 due to limited accuracy)\n-                  // that the code above would fail handling it.\n-                  // So we set up an artificial 0 size step by copying states\n-                  loop     = false;\n               } else {\n                   // reject the step to match exactly the next switch time\n                   hNew = dt;\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java", 
          "line": 300, 
          "faulty": "loop=false;", 
          "type": "Delete", 
          "seed": "setEquations(equations);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_905/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 07:16:35.390499222 -0500\n@@ -208,7 +208,11 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\t2018-12-01 06:00:05.075483730 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_905/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\t2018-12-01 07:16:35.390499222 -0500\n@@ -292,7 +292,8 @@\n           if (manager.evaluateStep(interpolator)) {\n               final double dt = manager.getEventTime() - stepStart;\n               if (Math.abs(dt) <= Math.ulp(stepStart)) {\n-                  // we cannot simply truncate the step, reject the current computation\n+                  stepStart = Double.NaN;\n+\t\t\t\t// we cannot simply truncate the step, reject the current computation\n                   // and let the loop compute another state with the truncated step.\n                   // it is so small (much probably exactly 0 due to limited accuracy)\n                   // that the code above would fail handling it.\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java", 
          "line": 300, 
          "faulty": "loop=false;", 
          "type": "InsertBefore", 
          "seed": "stepStart=Double.NaN;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_845/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 07:11:44.313105738 -0500\n@@ -208,10 +208,68 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n-                    final UnivariateRealFunction f = new UnivariateRealFunction() {\n+                    if (g0Positive ^ (gb >= 0)) {\n+\t\t\t\t\t\tif (ga * gb > 0) {\n+\t\t\t\t\t\t\tfinal double epsilon = (forward ? 0.25 : -0.25)\n+\t\t\t\t\t\t\t\t\t* convergence;\n+\t\t\t\t\t\t\tfor (int k = 0; (k < 4) && (ga * gb > 0); ++k) {\n+\t\t\t\t\t\t\t\tta += epsilon;\n+\t\t\t\t\t\t\t\tinterpolator.setInterpolatedTime(ta);\n+\t\t\t\t\t\t\t\tga = handler.g(ta,\n+\t\t\t\t\t\t\t\t\t\tinterpolator.getInterpolatedState());\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tif (ga * gb > 0) {\n+\t\t\t\t\t\t\t\tthrow MathRuntimeException\n+\t\t\t\t\t\t\t\t\t\t.createInternalError(null);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tincreasing = gb >= ga;\n+\t\t\t\t\t\tfinal UnivariateRealFunction f = new UnivariateRealFunction() {\n+\t\t\t\t\t\t\tpublic double value(final double t)\n+\t\t\t\t\t\t\t\t\tthrows FunctionEvaluationException {\n+\t\t\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\t\t\tinterpolator.setInterpolatedTime(t);\n+\t\t\t\t\t\t\t\t\treturn handler\n+\t\t\t\t\t\t\t\t\t\t\t.g(t, interpolator\n+\t\t\t\t\t\t\t\t\t\t\t\t\t.getInterpolatedState());\n+\t\t\t\t\t\t\t\t} catch (DerivativeException e) {\n+\t\t\t\t\t\t\t\t\tthrow new FunctionEvaluationException(e, t);\n+\t\t\t\t\t\t\t\t} catch (EventException e) {\n+\t\t\t\t\t\t\t\t\tthrow new FunctionEvaluationException(e, t);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t};\n+\t\t\t\t\t\tfinal BrentSolver solver = new BrentSolver();\n+\t\t\t\t\t\tsolver.setAbsoluteAccuracy(convergence);\n+\t\t\t\t\t\tsolver.setMaximalIterationCount(maxIterationCount);\n+\t\t\t\t\t\tfinal double root = (ta <= tb) ? solver\n+\t\t\t\t\t\t\t\t.solve(f, ta, tb) : solver.solve(f, tb, ta);\n+\t\t\t\t\t\tif ((Math.abs(root - ta) <= convergence)\n+\t\t\t\t\t\t\t\t&& (Math.abs(root - previousEventTime) <= convergence)) {\n+\t\t\t\t\t\t\tta = tb;\n+\t\t\t\t\t\t\tga = gb;\n+\t\t\t\t\t\t} else if (Double.isNaN(previousEventTime)\n+\t\t\t\t\t\t\t\t|| (Math.abs(previousEventTime - root) > convergence)) {\n+\t\t\t\t\t\t\tpendingEventTime = root;\n+\t\t\t\t\t\t\tif (pendingEvent\n+\t\t\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\t\t\treturn false;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tpendingEvent = true;\n+\t\t\t\t\t\t\treturn true;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tta = tb;\n+\t\t\t\t\t\tga = gb;\n+\t\t\t\t\t}\n+\t\t\t\t\tfinal UnivariateRealFunction f = new UnivariateRealFunction() {\n                         public double value(final double t) throws FunctionEvaluationException {\n                             try {\n                                 interpolator.setInterpolatedTime(t);\n@@ -224,7 +282,6 @@\n                         }\n                     };\n                     final BrentSolver solver = new BrentSolver();\n-                    solver.setAbsoluteAccuracy(convergence);\n                     solver.setMaximalIterationCount(maxIterationCount);\n                     final double root = (ta <= tb) ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta);\n                     if ((Math.abs(root - ta) <= convergence) &&\n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\t2018-12-01 06:00:05.075483730 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_845/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\t2018-12-01 07:11:44.313105738 -0500\n@@ -292,12 +292,7 @@\n           if (manager.evaluateStep(interpolator)) {\n               final double dt = manager.getEventTime() - stepStart;\n               if (Math.abs(dt) <= Math.ulp(stepStart)) {\n-                  // we cannot simply truncate the step, reject the current computation\n-                  // and let the loop compute another state with the truncated step.\n-                  // it is so small (much probably exactly 0 due to limited accuracy)\n-                  // that the code above would fail handling it.\n-                  // So we set up an artificial 0 size step by copying states\n-                  loop     = false;\n+                  super.sanityChecks(equations, t0, y0, t, y);\n               } else {\n                   // reject the step to match exactly the next switch time\n                   hNew = dt;\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java", 
          "line": 300, 
          "faulty": "loop=false;", 
          "type": "Replace", 
          "seed": "super.sanityChecks(equations,t0,y0,t,y);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 227, 
          "faulty": "solver.setAbsoluteAccuracy(convergence);", 
          "type": "Delete", 
          "seed": "solver.setMaximalIterationCount(maxIterationCount);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 214, 
          "faulty": "final UnivariateRealFunction f=new UnivariateRealFunction(){\n  public double value(  final double t) throws FunctionEvaluationException {\n    try {\n      interpolator.setInterpolatedTime(t);\n      return handler.g(t,interpolator.getInterpolatedState());\n    }\n catch (    DerivativeException e) {\n      throw new FunctionEvaluationException(e,t);\n    }\ncatch (    EventException e) {\n      throw new FunctionEvaluationException(e,t);\n    }\n  }\n}\n;", 
          "type": "InsertBefore", 
          "seed": "if (g0Positive ^ (gb >= 0)) {\n  if (ga * gb > 0) {\n    final double epsilon=(forward ? 0.25 : -0.25) * convergence;\n    for (int k=0; (k < 4) && (ga * gb > 0); ++k) {\n      ta+=epsilon;\n      interpolator.setInterpolatedTime(ta);\n      ga=handler.g(ta,interpolator.getInterpolatedState());\n    }\n    if (ga * gb > 0) {\n      throw MathRuntimeException.createInternalError(null);\n    }\n  }\n  increasing=gb >= ga;\n  final UnivariateRealFunction f=new UnivariateRealFunction(){\n    public double value(    final double t) throws FunctionEvaluationException {\n      try {\n        interpolator.setInterpolatedTime(t);\n        return handler.g(t,interpolator.getInterpolatedState());\n      }\n catch (      DerivativeException e) {\n        throw new FunctionEvaluationException(e,t);\n      }\ncatch (      EventException e) {\n        throw new FunctionEvaluationException(e,t);\n      }\n    }\n  }\n;\n  final BrentSolver solver=new BrentSolver();\n  solver.setAbsoluteAccuracy(convergence);\n  solver.setMaximalIterationCount(maxIterationCount);\n  final double root=(ta <= tb) ? solver.solve(f,ta,tb) : solver.solve(f,tb,ta);\n  if ((Math.abs(root - ta) <= convergence) && (Math.abs(root - previousEventTime) <= convergence)) {\n    ta=tb;\n    ga=gb;\n  }\n else   if (Double.isNaN(previousEventTime) || (Math.abs(previousEventTime - root) > convergence)) {\n    pendingEventTime=root;\n    if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n      return false;\n    }\n    pendingEvent=true;\n    return true;\n  }\n}\n else {\n  ta=tb;\n  ga=gb;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_192/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:18:34.149623962 -0500\n@@ -225,7 +225,11 @@\n                     };\n                     final BrentSolver solver = new BrentSolver();\n                     solver.setAbsoluteAccuracy(convergence);\n-                    solver.setMaximalIterationCount(maxIterationCount);\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\tsolver.setMaximalIterationCount(maxIterationCount);\n                     final double root = (ta <= tb) ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta);\n                     if ((Math.abs(root - ta) <= convergence) &&\n                          (Math.abs(root - previousEventTime) <= convergence)) {\n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\t2018-12-01 06:00:01.507483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_192/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\t2018-12-01 06:18:34.157624000 -0500\n@@ -147,11 +147,7 @@\n    * ignore the value and compute the initial step size by itself)\n    */\n   public void setInitialStepSize(final double initialStepSize) {\n-    if ((initialStepSize < minStep) || (initialStepSize > maxStep)) {\n-      initialStep = -1.0;\n-    } else {\n-      initialStep = initialStepSize;\n-    }\n+    this.initialStep = -1.0;\n   }\n \n   /** Perform some sanity checks on the integration parameters.\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 228, 
          "faulty": "solver.setMaximalIterationCount(maxIterationCount);", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java", 
          "line": 150, 
          "faulty": "if ((initialStepSize < minStep) || (initialStepSize > maxStep)) {\n  initialStep=-1.0;\n}\n else {\n  initialStep=initialStepSize;\n}", 
          "type": "Replace", 
          "seed": "this.initialStep=-1.0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/CombinedEventsManager.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_59/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/CombinedEventsManager.java\t2018-12-01 06:07:04.762104337 -0500\n@@ -151,7 +151,23 @@\n \n                 if (state.evaluateStep(interpolator)) {\n                     if (first == null) {\n-                        first = state;\n+                        if (state.evaluateStep(interpolator)) {\n+\t\t\t\t\t\t\tif (first == null) {\n+\t\t\t\t\t\t\t\tfirst = state;\n+\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\tif (interpolator.isForward()) {\n+\t\t\t\t\t\t\t\t\tif (state.getEventTime() < first\n+\t\t\t\t\t\t\t\t\t\t\t.getEventTime()) {\n+\t\t\t\t\t\t\t\t\t\tfirst = state;\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\tif (state.getEventTime() > first\n+\t\t\t\t\t\t\t\t\t\t\t.getEventTime()) {\n+\t\t\t\t\t\t\t\t\t\tfirst = state;\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n                     } else {\n                         if (interpolator.isForward()) {\n                             if (state.getEventTime() < first.getEventTime()) {\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/CombinedEventsManager.java", 
          "line": 154, 
          "faulty": "first=state;", 
          "type": "Replace", 
          "seed": "if (state.evaluateStep(interpolator)) {\n  if (first == null) {\n    first=state;\n  }\n else {\n    if (interpolator.isForward()) {\n      if (state.getEventTime() < first.getEventTime()) {\n        first=state;\n      }\n    }\n else {\n      if (state.getEventTime() > first.getEventTime()) {\n        first=state;\n      }\n    }\n  }\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_298/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:26:51.251992772 -0500\n@@ -225,7 +225,11 @@\n                     };\n                     final BrentSolver solver = new BrentSolver();\n                     solver.setAbsoluteAccuracy(convergence);\n-                    solver.setMaximalIterationCount(maxIterationCount);\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\tsolver.setMaximalIterationCount(maxIterationCount);\n                     final double root = (ta <= tb) ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta);\n                     if ((Math.abs(root - ta) <= convergence) &&\n                          (Math.abs(root - previousEventTime) <= convergence)) {\n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/sampling/DummyStepInterpolator.java\t2018-12-01 06:00:01.511483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_298/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/sampling/DummyStepInterpolator.java\t2018-12-01 06:26:51.255992791 -0500\n@@ -104,7 +104,8 @@\n   @Override\n   protected void computeInterpolatedStateAndDerivatives(final double theta, final double oneMinusThetaH)\n     throws DerivativeException {\n-      System.arraycopy(currentState,      0, interpolatedState,       0, currentState.length);\n+      interpolatedTime = Double.NaN;\n+\tSystem.arraycopy(currentState,      0, interpolatedState,       0, currentState.length);\n       System.arraycopy(currentDerivative, 0, interpolatedDerivatives, 0, currentDerivative.length);\n   }\n \n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\t2018-12-01 06:00:01.507483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_298/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\t2018-12-01 06:26:51.255992791 -0500\n@@ -147,11 +147,6 @@\n    * ignore the value and compute the initial step size by itself)\n    */\n   public void setInitialStepSize(final double initialStepSize) {\n-    if ((initialStepSize < minStep) || (initialStepSize > maxStep)) {\n-      initialStep = -1.0;\n-    } else {\n-      initialStep = initialStepSize;\n-    }\n   }\n \n   /** Perform some sanity checks on the integration parameters.\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 228, 
          "faulty": "solver.setMaximalIterationCount(maxIterationCount);", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java", 
          "line": 150, 
          "faulty": "if ((initialStepSize < minStep) || (initialStepSize > maxStep)) {\n  initialStep=-1.0;\n}\n else {\n  initialStep=initialStepSize;\n}", 
          "type": "Delete", 
          "seed": "if ((initialStepSize < minStep) || (initialStepSize > maxStep)) {\n  initialStep=-1.0;\n}\n else {\n  initialStep=initialStepSize;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/sampling/DummyStepInterpolator.java", 
          "line": 107, 
          "faulty": "System.arraycopy(currentState,0,interpolatedState,0,currentState.length);", 
          "type": "InsertBefore", 
          "seed": "interpolatedTime=Double.NaN;"
        }
      ]
    }, 
    {
      "diff": "\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_449/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:39:33.523707723 -0500\n@@ -208,7 +208,11 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/CombinedEventsManager.java", 
          "line": 109, 
          "faulty": "return states.isEmpty();", 
          "type": "Replace", 
          "seed": "return states.isEmpty();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_928/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 07:18:24.223028948 -0500\n@@ -208,7 +208,8 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    pendingEvent = true;\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n@@ -299,7 +300,8 @@\n         if (pendingEvent) {\n             // force the sign to its value \"just after the event\"\n             previousEventTime = t;\n-            g0Positive        = increasing;\n+            g0 = handler.g(t, y);\n+\t\t\tg0Positive        = increasing;\n             nextAction        = handler.eventOccurred(t, y, !(increasing ^ forward));\n         } else {\n             g0Positive = g0 >= 0;\n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\t2018-12-01 06:00:05.075483730 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_928/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\t2018-12-01 07:18:24.223028948 -0500\n@@ -292,12 +292,7 @@\n           if (manager.evaluateStep(interpolator)) {\n               final double dt = manager.getEventTime() - stepStart;\n               if (Math.abs(dt) <= Math.ulp(stepStart)) {\n-                  // we cannot simply truncate the step, reject the current computation\n-                  // and let the loop compute another state with the truncated step.\n-                  // it is so small (much probably exactly 0 due to limited accuracy)\n-                  // that the code above would fail handling it.\n-                  // So we set up an artificial 0 size step by copying states\n-                  loop     = false;\n+                  super.sanityChecks(equations, t0, y0, t, y);\n               } else {\n                   // reject the step to match exactly the next switch time\n                   hNew = dt;\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java", 
          "line": 300, 
          "faulty": "loop=false;", 
          "type": "Replace", 
          "seed": "super.sanityChecks(equations,t0,y0,t,y);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 302, 
          "faulty": "g0Positive=increasing;", 
          "type": "InsertBefore", 
          "seed": "g0=handler.g(t,y);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "pendingEvent=true;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_856/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 07:12:38.549365743 -0500\n@@ -208,7 +208,11 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n@@ -235,7 +239,17 @@\n                     } else if (Double.isNaN(previousEventTime) ||\n                                (Math.abs(previousEventTime - root) > convergence)) {\n                         pendingEventTime = root;\n-                        if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+                        if (Double.isNaN(previousEventTime)\n+\t\t\t\t\t\t\t\t|| (Math.abs(previousEventTime - root) > convergence)) {\n+\t\t\t\t\t\t\tpendingEventTime = root;\n+\t\t\t\t\t\t\tif (pendingEvent\n+\t\t\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\t\t\treturn false;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tpendingEvent = true;\n+\t\t\t\t\t\t\treturn true;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tif (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n                             // we were already waiting for this event which was\n                             // found during a previous call for a step that was\n                             // rejected, this step must now be accepted since it\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 238, 
          "faulty": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}", 
          "type": "InsertBefore", 
          "seed": "if (Double.isNaN(previousEventTime) || (Math.abs(previousEventTime - root) > convergence)) {\n  pendingEventTime=root;\n  if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n    return false;\n  }\n  pendingEvent=true;\n  return true;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_766/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 07:05:15.151232540 -0500\n@@ -208,7 +208,8 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    pendingEvent = true;\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n@@ -235,7 +236,8 @@\n                     } else if (Double.isNaN(previousEventTime) ||\n                                (Math.abs(previousEventTime - root) > convergence)) {\n                         pendingEventTime = root;\n-                        if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+                        interpolator.setInterpolatedTime(ta);\n+\t\t\t\t\t\tif (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n                             // we were already waiting for this event which was\n                             // found during a previous call for a step that was\n                             // rejected, this step must now be accepted since it\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "pendingEvent=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 238, 
          "faulty": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}", 
          "type": "InsertBefore", 
          "seed": "interpolator.setInterpolatedTime(ta);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/CombinedEventsManager.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_434/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/CombinedEventsManager.java\t2018-12-01 06:38:19.747349161 -0500\n@@ -106,7 +106,8 @@\n      * @return true if manager is empty\n      */\n     public boolean isEmpty() {\n-        return states.isEmpty();\n+        first = null;\n+\t\treturn states.isEmpty();\n     }\n \n     /** Evaluate the impact of the proposed step on all managed\n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_434/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:38:19.755349201 -0500\n@@ -188,30 +188,73 @@\n                 if (g0Positive ^ (gb >= 0)) {\n                     // there is a sign change: an event is expected during this step\n \n-                    if (ga * gb > 0) {\n-                        // this is a corner case:\n-                        // - there was an event near ta,\n-                        // - there is another event between ta and tb\n-                        // - when ta was computed, convergence was reached on the \"wrong side\" of the interval\n-                        // this implies that the real sign of ga is the same as gb, so we need to slightly\n-                        // shift ta to make sure ga and gb get opposite signs and the solver won't complain\n-                        // about bracketing\n-                        final double epsilon = (forward ? 0.25 : -0.25) * convergence;\n-                        for (int k = 0; (k < 4) && (ga * gb > 0); ++k) {\n-                            ta += epsilon;\n-                            interpolator.setInterpolatedTime(ta);\n-                            ga = handler.g(ta, interpolator.getInterpolatedState());\n-                        }\n-                        if (ga * gb > 0) {\n-                            // this should never happen\n-                            throw MathRuntimeException.createInternalError(null);\n-                        }\n-                    }\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n-                    final UnivariateRealFunction f = new UnivariateRealFunction() {\n+                    if (g0Positive ^ (gb >= 0)) {\n+\t\t\t\t\t\tif (ga * gb > 0) {\n+\t\t\t\t\t\t\tfinal double epsilon = (forward ? 0.25 : -0.25)\n+\t\t\t\t\t\t\t\t\t* convergence;\n+\t\t\t\t\t\t\tfor (int k = 0; (k < 4) && (ga * gb > 0); ++k) {\n+\t\t\t\t\t\t\t\tta += epsilon;\n+\t\t\t\t\t\t\t\tinterpolator.setInterpolatedTime(ta);\n+\t\t\t\t\t\t\t\tga = handler.g(ta,\n+\t\t\t\t\t\t\t\t\t\tinterpolator.getInterpolatedState());\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tif (ga * gb > 0) {\n+\t\t\t\t\t\t\t\tthrow MathRuntimeException\n+\t\t\t\t\t\t\t\t\t\t.createInternalError(null);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tincreasing = gb >= ga;\n+\t\t\t\t\t\tfinal UnivariateRealFunction f = new UnivariateRealFunction() {\n+\t\t\t\t\t\t\tpublic double value(final double t)\n+\t\t\t\t\t\t\t\t\tthrows FunctionEvaluationException {\n+\t\t\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\t\t\tinterpolator.setInterpolatedTime(t);\n+\t\t\t\t\t\t\t\t\treturn handler\n+\t\t\t\t\t\t\t\t\t\t\t.g(t, interpolator\n+\t\t\t\t\t\t\t\t\t\t\t\t\t.getInterpolatedState());\n+\t\t\t\t\t\t\t\t} catch (DerivativeException e) {\n+\t\t\t\t\t\t\t\t\tthrow new FunctionEvaluationException(e, t);\n+\t\t\t\t\t\t\t\t} catch (EventException e) {\n+\t\t\t\t\t\t\t\t\tthrow new FunctionEvaluationException(e, t);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t};\n+\t\t\t\t\t\tfinal BrentSolver solver = new BrentSolver();\n+\t\t\t\t\t\tsolver.setAbsoluteAccuracy(convergence);\n+\t\t\t\t\t\tsolver.setMaximalIterationCount(maxIterationCount);\n+\t\t\t\t\t\tfinal double root = (ta <= tb) ? solver\n+\t\t\t\t\t\t\t\t.solve(f, ta, tb) : solver.solve(f, tb, ta);\n+\t\t\t\t\t\tif ((Math.abs(root - ta) <= convergence)\n+\t\t\t\t\t\t\t\t&& (Math.abs(root - previousEventTime) <= convergence)) {\n+\t\t\t\t\t\t\tta = tb;\n+\t\t\t\t\t\t\tga = gb;\n+\t\t\t\t\t\t} else if (Double.isNaN(previousEventTime)\n+\t\t\t\t\t\t\t\t|| (Math.abs(previousEventTime - root) > convergence)) {\n+\t\t\t\t\t\t\tpendingEventTime = root;\n+\t\t\t\t\t\t\tif (pendingEvent\n+\t\t\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\t\t\treturn false;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tpendingEvent = true;\n+\t\t\t\t\t\t\treturn true;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tta = tb;\n+\t\t\t\t\t\tga = gb;\n+\t\t\t\t\t}\n+\t\t\t\t\tfinal UnivariateRealFunction f = new UnivariateRealFunction() {\n                         public double value(final double t) throws FunctionEvaluationException {\n                             try {\n                                 interpolator.setInterpolatedTime(t);\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 191, 
          "faulty": "if (ga * gb > 0) {\n  final double epsilon=(forward ? 0.25 : -0.25) * convergence;\n  for (int k=0; (k < 4) && (ga * gb > 0); ++k) {\n    ta+=epsilon;\n    interpolator.setInterpolatedTime(ta);\n    ga=handler.g(ta,interpolator.getInterpolatedState());\n  }\n  if (ga * gb > 0) {\n    throw MathRuntimeException.createInternalError(null);\n  }\n}", 
          "type": "Replace", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/CombinedEventsManager.java", 
          "line": 109, 
          "faulty": "return states.isEmpty();", 
          "type": "InsertBefore", 
          "seed": "first=null;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 214, 
          "faulty": "final UnivariateRealFunction f=new UnivariateRealFunction(){\n  public double value(  final double t) throws FunctionEvaluationException {\n    try {\n      interpolator.setInterpolatedTime(t);\n      return handler.g(t,interpolator.getInterpolatedState());\n    }\n catch (    DerivativeException e) {\n      throw new FunctionEvaluationException(e,t);\n    }\ncatch (    EventException e) {\n      throw new FunctionEvaluationException(e,t);\n    }\n  }\n}\n;", 
          "type": "InsertBefore", 
          "seed": "if (g0Positive ^ (gb >= 0)) {\n  if (ga * gb > 0) {\n    final double epsilon=(forward ? 0.25 : -0.25) * convergence;\n    for (int k=0; (k < 4) && (ga * gb > 0); ++k) {\n      ta+=epsilon;\n      interpolator.setInterpolatedTime(ta);\n      ga=handler.g(ta,interpolator.getInterpolatedState());\n    }\n    if (ga * gb > 0) {\n      throw MathRuntimeException.createInternalError(null);\n    }\n  }\n  increasing=gb >= ga;\n  final UnivariateRealFunction f=new UnivariateRealFunction(){\n    public double value(    final double t) throws FunctionEvaluationException {\n      try {\n        interpolator.setInterpolatedTime(t);\n        return handler.g(t,interpolator.getInterpolatedState());\n      }\n catch (      DerivativeException e) {\n        throw new FunctionEvaluationException(e,t);\n      }\ncatch (      EventException e) {\n        throw new FunctionEvaluationException(e,t);\n      }\n    }\n  }\n;\n  final BrentSolver solver=new BrentSolver();\n  solver.setAbsoluteAccuracy(convergence);\n  solver.setMaximalIterationCount(maxIterationCount);\n  final double root=(ta <= tb) ? solver.solve(f,ta,tb) : solver.solve(f,tb,ta);\n  if ((Math.abs(root - ta) <= convergence) && (Math.abs(root - previousEventTime) <= convergence)) {\n    ta=tb;\n    ga=gb;\n  }\n else   if (Double.isNaN(previousEventTime) || (Math.abs(previousEventTime - root) > convergence)) {\n    pendingEventTime=root;\n    if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n      return false;\n    }\n    pendingEvent=true;\n    return true;\n  }\n}\n else {\n  ta=tb;\n  ga=gb;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_400/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:35:23.422485295 -0500\n@@ -208,7 +208,8 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    pendingEvent = true;\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n@@ -223,7 +224,8 @@\n                             }\n                         }\n                     };\n-                    final BrentSolver solver = new BrentSolver();\n+                    forward = interpolator.isForward();\n+\t\t\t\t\tfinal BrentSolver solver = new BrentSolver();\n                     solver.setAbsoluteAccuracy(convergence);\n                     solver.setMaximalIterationCount(maxIterationCount);\n                     final double root = (ta <= tb) ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta);\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 226, 
          "faulty": "final BrentSolver solver=new BrentSolver();", 
          "type": "InsertBefore", 
          "seed": "forward=interpolator.isForward();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "pendingEvent=true;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_264/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:24:12.127229041 -0500\n@@ -208,7 +208,8 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    pendingEvent = true;\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "pendingEvent=true;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/CombinedEventsManager.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_1052/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/CombinedEventsManager.java\t2018-12-01 07:28:28.213972296 -0500\n@@ -151,6 +151,19 @@\n \n                 if (state.evaluateStep(interpolator)) {\n                     if (first == null) {\n+\t\t\t\t\t\tfirst = state;\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tif (interpolator.isForward()) {\n+\t\t\t\t\t\t\tif (state.getEventTime() < first.getEventTime()) {\n+\t\t\t\t\t\t\t\tfirst = state;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tif (state.getEventTime() > first.getEventTime()) {\n+\t\t\t\t\t\t\t\tfirst = state;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tif (first == null) {\n                         first = state;\n                     } else {\n                         if (interpolator.isForward()) {\n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_1052/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 07:28:28.213972296 -0500\n@@ -208,7 +208,11 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n@@ -335,7 +339,8 @@\n             handler.resetState(t, y);\n         }\n         pendingEvent      = false;\n-        pendingEventTime  = Double.NaN;\n+        g0Positive = increasing;\n+\t\tpendingEventTime  = Double.NaN;\n \n         return (nextAction == EventHandler.RESET_STATE) ||\n                (nextAction == EventHandler.RESET_DERIVATIVES);\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 338, 
          "faulty": "pendingEventTime=Double.NaN;", 
          "type": "InsertBefore", 
          "seed": "g0Positive=increasing;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/CombinedEventsManager.java", 
          "line": 153, 
          "faulty": "if (first == null) {\n  first=state;\n}\n else {\n  if (interpolator.isForward()) {\n    if (state.getEventTime() < first.getEventTime()) {\n      first=state;\n    }\n  }\n else {\n    if (state.getEventTime() > first.getEventTime()) {\n      first=state;\n    }\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "if (first == null) {\n  first=state;\n}\n else {\n  if (interpolator.isForward()) {\n    if (state.getEventTime() < first.getEventTime()) {\n      first=state;\n    }\n  }\n else {\n    if (state.getEventTime() > first.getEventTime()) {\n      first=state;\n    }\n  }\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_1023/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 07:26:13.133317053 -0500\n@@ -208,7 +208,8 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    pendingEvent = true;\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n@@ -299,7 +300,8 @@\n         if (pendingEvent) {\n             // force the sign to its value \"just after the event\"\n             previousEventTime = t;\n-            g0Positive        = increasing;\n+            t0 = t;\n+\t\t\tg0Positive        = increasing;\n             nextAction        = handler.eventOccurred(t, y, !(increasing ^ forward));\n         } else {\n             g0Positive = g0 >= 0;\n@@ -335,7 +337,8 @@\n             handler.resetState(t, y);\n         }\n         pendingEvent      = false;\n-        pendingEventTime  = Double.NaN;\n+        g0 = handler.g(t, y);\n+\t\tpendingEventTime  = Double.NaN;\n \n         return (nextAction == EventHandler.RESET_STATE) ||\n                (nextAction == EventHandler.RESET_DERIVATIVES);\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 338, 
          "faulty": "pendingEventTime=Double.NaN;", 
          "type": "InsertBefore", 
          "seed": "g0=handler.g(t,y);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 302, 
          "faulty": "g0Positive=increasing;", 
          "type": "InsertBefore", 
          "seed": "t0=t;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "pendingEvent=true;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_247/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:22:53.614849447 -0500\n@@ -208,7 +208,11 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/sampling/DummyStepInterpolator.java\t2018-12-01 06:00:01.511483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_247/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/sampling/DummyStepInterpolator.java\t2018-12-01 06:22:53.614849447 -0500\n@@ -104,7 +104,9 @@\n   @Override\n   protected void computeInterpolatedStateAndDerivatives(final double theta, final double oneMinusThetaH)\n     throws DerivativeException {\n-      System.arraycopy(currentState,      0, interpolatedState,       0, currentState.length);\n+      System.arraycopy(currentDerivative, 0, interpolatedDerivatives, 0,\n+\t\t\t\tcurrentDerivative.length);\n+\tSystem.arraycopy(currentState,      0, interpolatedState,       0, currentState.length);\n       System.arraycopy(currentDerivative, 0, interpolatedDerivatives, 0, currentDerivative.length);\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/sampling/DummyStepInterpolator.java", 
          "line": 107, 
          "faulty": "System.arraycopy(currentState,0,interpolatedState,0,currentState.length);", 
          "type": "InsertBefore", 
          "seed": "System.arraycopy(currentDerivative,0,interpolatedDerivatives,0,currentDerivative.length);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_282/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:25:34.499625798 -0500\n@@ -225,7 +225,11 @@\n                     };\n                     final BrentSolver solver = new BrentSolver();\n                     solver.setAbsoluteAccuracy(convergence);\n-                    solver.setMaximalIterationCount(maxIterationCount);\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\tsolver.setMaximalIterationCount(maxIterationCount);\n                     final double root = (ta <= tb) ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta);\n                     if ((Math.abs(root - ta) <= convergence) &&\n                          (Math.abs(root - previousEventTime) <= convergence)) {\n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\t2018-12-01 06:00:01.507483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_282/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\t2018-12-01 06:25:34.503625816 -0500\n@@ -147,11 +147,6 @@\n    * ignore the value and compute the initial step size by itself)\n    */\n   public void setInitialStepSize(final double initialStepSize) {\n-    if ((initialStepSize < minStep) || (initialStepSize > maxStep)) {\n-      initialStep = -1.0;\n-    } else {\n-      initialStep = initialStepSize;\n-    }\n   }\n \n   /** Perform some sanity checks on the integration parameters.\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 228, 
          "faulty": "solver.setMaximalIterationCount(maxIterationCount);", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java", 
          "line": 150, 
          "faulty": "if ((initialStepSize < minStep) || (initialStepSize > maxStep)) {\n  initialStep=-1.0;\n}\n else {\n  initialStep=initialStepSize;\n}", 
          "type": "Delete", 
          "seed": "initialStep=initialStepSize;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/CombinedEventsManager.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_822/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/CombinedEventsManager.java\t2018-12-01 07:09:50.060557324 -0500\n@@ -151,7 +151,19 @@\n \n                 if (state.evaluateStep(interpolator)) {\n                     if (first == null) {\n-                        first = state;\n+                        if (first == null) {\n+\t\t\t\t\t\t\tfirst = state;\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tif (interpolator.isForward()) {\n+\t\t\t\t\t\t\t\tif (state.getEventTime() < first.getEventTime()) {\n+\t\t\t\t\t\t\t\t\tfirst = state;\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\tif (state.getEventTime() > first.getEventTime()) {\n+\t\t\t\t\t\t\t\t\tfirst = state;\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n                     } else {\n                         if (interpolator.isForward()) {\n                             if (state.getEventTime() < first.getEventTime()) {\n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_822/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 07:09:50.060557324 -0500\n@@ -208,7 +208,8 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    pendingEvent = true;\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/CombinedEventsManager.java", 
          "line": 154, 
          "faulty": "first=state;", 
          "type": "Replace", 
          "seed": "if (first == null) {\n  first=state;\n}\n else {\n  if (interpolator.isForward()) {\n    if (state.getEventTime() < first.getEventTime()) {\n      first=state;\n    }\n  }\n else {\n    if (state.getEventTime() > first.getEventTime()) {\n      first=state;\n    }\n  }\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "pendingEvent=true;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\t2018-12-01 06:00:05.075483730 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_1157/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\t2018-12-01 07:37:14.676514508 -0500\n@@ -120,7 +120,10 @@\n       rki.reinitialize(this, yTmp, yDotK, forward);\n       interpolator = rki;\n     } else {\n-      interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);\n+      for (StepHandler handler : stepHandlers) {\n+\t\t\thandler.reset();\n+\t\t}\n+\tinterpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);\n     }\n     interpolator.storeTime(t0);\n \n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_1157/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 07:37:14.676514508 -0500\n@@ -208,7 +208,11 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n@@ -232,21 +236,32 @@\n                         // we have either found nothing or found (again ?) a past event, we simply ignore it\n                         ta = tb;\n                         ga = gb;\n-                    } else if (Double.isNaN(previousEventTime) ||\n-                               (Math.abs(previousEventTime - root) > convergence)) {\n-                        pendingEventTime = root;\n-                        if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n-                            // we were already waiting for this event which was\n-                            // found during a previous call for a step that was\n-                            // rejected, this step must now be accepted since it\n-                            // properly ends exactly at the event occurrence\n-                            return false;\n-                        }\n-                        // either we were not waiting for the event or it has\n-                        // moved in such a way the step cannot be accepted\n-                        pendingEvent = true;\n-                        return true;\n-                    }\n+                    } else {\n+\t\t\t\t\t\tif (ga * gb > 0) {\n+\t\t\t\t\t\t\tfinal double epsilon = (forward ? 0.25 : -0.25)\n+\t\t\t\t\t\t\t\t\t* convergence;\n+\t\t\t\t\t\t\tfor (int k = 0; (k < 4) && (ga * gb > 0); ++k) {\n+\t\t\t\t\t\t\t\tta += epsilon;\n+\t\t\t\t\t\t\t\tinterpolator.setInterpolatedTime(ta);\n+\t\t\t\t\t\t\t\tga = handler.g(ta,\n+\t\t\t\t\t\t\t\t\t\tinterpolator.getInterpolatedState());\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tif (ga * gb > 0) {\n+\t\t\t\t\t\t\t\tthrow MathRuntimeException\n+\t\t\t\t\t\t\t\t\t\t.createInternalError(null);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tif (Double.isNaN(previousEventTime)\n+\t\t\t\t\t\t\t\t|| (Math.abs(previousEventTime - root) > convergence)) {\n+\t\t\t\t\t\t\tpendingEventTime = root;\n+\t\t\t\t\t\t\tif (pendingEvent\n+\t\t\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\t\t\treturn false;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tpendingEvent = true;\n+\t\t\t\t\t\t\treturn true;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n \n                 } else {\n                     // no sign change: there is no event for now\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java", 
          "line": 123, 
          "faulty": "interpolator=new DummyStepInterpolator(yTmp,yDotK[stages - 1],forward);", 
          "type": "InsertBefore", 
          "seed": "for (StepHandler handler : stepHandlers) {\n  handler.reset();\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 235, 
          "faulty": "if (Double.isNaN(previousEventTime) || (Math.abs(previousEventTime - root) > convergence)) {\n  pendingEventTime=root;\n  if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n    return false;\n  }\n  pendingEvent=true;\n  return true;\n}", 
          "type": "InsertBefore", 
          "seed": "if (ga * gb > 0) {\n  final double epsilon=(forward ? 0.25 : -0.25) * convergence;\n  for (int k=0; (k < 4) && (ga * gb > 0); ++k) {\n    ta+=epsilon;\n    interpolator.setInterpolatedTime(ta);\n    ga=handler.g(ta,interpolator.getInterpolatedState());\n  }\n  if (ga * gb > 0) {\n    throw MathRuntimeException.createInternalError(null);\n  }\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_142/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:14:26.528430222 -0500\n@@ -208,7 +208,11 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\t2018-12-01 06:00:01.507483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_142/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\t2018-12-01 06:14:26.532430242 -0500\n@@ -147,7 +147,8 @@\n    * ignore the value and compute the initial step size by itself)\n    */\n   public void setInitialStepSize(final double initialStepSize) {\n-    if ((initialStepSize < minStep) || (initialStepSize > maxStep)) {\n+    initialStep = initialStepSize;\n+\tif ((initialStepSize < minStep) || (initialStepSize > maxStep)) {\n       initialStep = -1.0;\n     } else {\n       initialStep = initialStepSize;\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java", 
          "line": 150, 
          "faulty": "if ((initialStepSize < minStep) || (initialStepSize > maxStep)) {\n  initialStep=-1.0;\n}\n else {\n  initialStep=initialStepSize;\n}", 
          "type": "InsertBefore", 
          "seed": "initialStep=initialStepSize;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_860/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 07:12:54.861443906 -0500\n@@ -188,7 +188,8 @@\n                 if (g0Positive ^ (gb >= 0)) {\n                     // there is a sign change: an event is expected during this step\n \n-                    if (ga * gb > 0) {\n+                    pendingEventTime = Double.NaN;\n+\t\t\t\t\tif (ga * gb > 0) {\n                         // this is a corner case:\n                         // - there was an event near ta,\n                         // - there is another event between ta and tb\n@@ -208,7 +209,8 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    pendingEvent = true;\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 191, 
          "faulty": "if (ga * gb > 0) {\n  final double epsilon=(forward ? 0.25 : -0.25) * convergence;\n  for (int k=0; (k < 4) && (ga * gb > 0); ++k) {\n    ta+=epsilon;\n    interpolator.setInterpolatedTime(ta);\n    ga=handler.g(ta,interpolator.getInterpolatedState());\n  }\n  if (ga * gb > 0) {\n    throw MathRuntimeException.createInternalError(null);\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "pendingEventTime=Double.NaN;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "pendingEvent=true;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_268/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:24:28.839309829 -0500\n@@ -208,10 +208,63 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n-                    increasing = gb >= ga;\n+                    pendingEvent = true;\n \n-                    final UnivariateRealFunction f = new UnivariateRealFunction() {\n+                    if (g0Positive ^ (gb >= 0)) {\n+\t\t\t\t\t\tif (ga * gb > 0) {\n+\t\t\t\t\t\t\tfinal double epsilon = (forward ? 0.25 : -0.25)\n+\t\t\t\t\t\t\t\t\t* convergence;\n+\t\t\t\t\t\t\tfor (int k = 0; (k < 4) && (ga * gb > 0); ++k) {\n+\t\t\t\t\t\t\t\tta += epsilon;\n+\t\t\t\t\t\t\t\tinterpolator.setInterpolatedTime(ta);\n+\t\t\t\t\t\t\t\tga = handler.g(ta,\n+\t\t\t\t\t\t\t\t\t\tinterpolator.getInterpolatedState());\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tif (ga * gb > 0) {\n+\t\t\t\t\t\t\t\tthrow MathRuntimeException\n+\t\t\t\t\t\t\t\t\t\t.createInternalError(null);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tincreasing = gb >= ga;\n+\t\t\t\t\t\tfinal UnivariateRealFunction f = new UnivariateRealFunction() {\n+\t\t\t\t\t\t\tpublic double value(final double t)\n+\t\t\t\t\t\t\t\t\tthrows FunctionEvaluationException {\n+\t\t\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\t\t\tinterpolator.setInterpolatedTime(t);\n+\t\t\t\t\t\t\t\t\treturn handler\n+\t\t\t\t\t\t\t\t\t\t\t.g(t, interpolator\n+\t\t\t\t\t\t\t\t\t\t\t\t\t.getInterpolatedState());\n+\t\t\t\t\t\t\t\t} catch (DerivativeException e) {\n+\t\t\t\t\t\t\t\t\tthrow new FunctionEvaluationException(e, t);\n+\t\t\t\t\t\t\t\t} catch (EventException e) {\n+\t\t\t\t\t\t\t\t\tthrow new FunctionEvaluationException(e, t);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t};\n+\t\t\t\t\t\tfinal BrentSolver solver = new BrentSolver();\n+\t\t\t\t\t\tsolver.setAbsoluteAccuracy(convergence);\n+\t\t\t\t\t\tsolver.setMaximalIterationCount(maxIterationCount);\n+\t\t\t\t\t\tfinal double root = (ta <= tb) ? solver\n+\t\t\t\t\t\t\t\t.solve(f, ta, tb) : solver.solve(f, tb, ta);\n+\t\t\t\t\t\tif ((Math.abs(root - ta) <= convergence)\n+\t\t\t\t\t\t\t\t&& (Math.abs(root - previousEventTime) <= convergence)) {\n+\t\t\t\t\t\t\tta = tb;\n+\t\t\t\t\t\t\tga = gb;\n+\t\t\t\t\t\t} else if (Double.isNaN(previousEventTime)\n+\t\t\t\t\t\t\t\t|| (Math.abs(previousEventTime - root) > convergence)) {\n+\t\t\t\t\t\t\tpendingEventTime = root;\n+\t\t\t\t\t\t\tif (pendingEvent\n+\t\t\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\t\t\treturn false;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tpendingEvent = true;\n+\t\t\t\t\t\t\treturn true;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tta = tb;\n+\t\t\t\t\t\tga = gb;\n+\t\t\t\t\t}\n+\t\t\t\t\tfinal UnivariateRealFunction f = new UnivariateRealFunction() {\n                         public double value(final double t) throws FunctionEvaluationException {\n                             try {\n                                 interpolator.setInterpolatedTime(t);\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "Replace", 
          "seed": "pendingEvent=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 214, 
          "faulty": "final UnivariateRealFunction f=new UnivariateRealFunction(){\n  public double value(  final double t) throws FunctionEvaluationException {\n    try {\n      interpolator.setInterpolatedTime(t);\n      return handler.g(t,interpolator.getInterpolatedState());\n    }\n catch (    DerivativeException e) {\n      throw new FunctionEvaluationException(e,t);\n    }\ncatch (    EventException e) {\n      throw new FunctionEvaluationException(e,t);\n    }\n  }\n}\n;", 
          "type": "InsertBefore", 
          "seed": "if (g0Positive ^ (gb >= 0)) {\n  if (ga * gb > 0) {\n    final double epsilon=(forward ? 0.25 : -0.25) * convergence;\n    for (int k=0; (k < 4) && (ga * gb > 0); ++k) {\n      ta+=epsilon;\n      interpolator.setInterpolatedTime(ta);\n      ga=handler.g(ta,interpolator.getInterpolatedState());\n    }\n    if (ga * gb > 0) {\n      throw MathRuntimeException.createInternalError(null);\n    }\n  }\n  increasing=gb >= ga;\n  final UnivariateRealFunction f=new UnivariateRealFunction(){\n    public double value(    final double t) throws FunctionEvaluationException {\n      try {\n        interpolator.setInterpolatedTime(t);\n        return handler.g(t,interpolator.getInterpolatedState());\n      }\n catch (      DerivativeException e) {\n        throw new FunctionEvaluationException(e,t);\n      }\ncatch (      EventException e) {\n        throw new FunctionEvaluationException(e,t);\n      }\n    }\n  }\n;\n  final BrentSolver solver=new BrentSolver();\n  solver.setAbsoluteAccuracy(convergence);\n  solver.setMaximalIterationCount(maxIterationCount);\n  final double root=(ta <= tb) ? solver.solve(f,ta,tb) : solver.solve(f,tb,ta);\n  if ((Math.abs(root - ta) <= convergence) && (Math.abs(root - previousEventTime) <= convergence)) {\n    ta=tb;\n    ga=gb;\n  }\n else   if (Double.isNaN(previousEventTime) || (Math.abs(previousEventTime - root) > convergence)) {\n    pendingEventTime=root;\n    if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n      return false;\n    }\n    pendingEvent=true;\n    return true;\n  }\n}\n else {\n  ta=tb;\n  ga=gb;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_202/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:19:19.649840270 -0500\n@@ -208,7 +208,8 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    pendingEvent = true;\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n@@ -337,7 +338,8 @@\n         pendingEvent      = false;\n         pendingEventTime  = Double.NaN;\n \n-        return (nextAction == EventHandler.RESET_STATE) ||\n+        g0 = Double.NaN;\n+\t\treturn (nextAction == EventHandler.RESET_STATE) ||\n                (nextAction == EventHandler.RESET_DERIVATIVES);\n \n     }\n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\t2018-12-01 06:00:01.507483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_202/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\t2018-12-01 06:19:19.653840289 -0500\n@@ -147,11 +147,6 @@\n    * ignore the value and compute the initial step size by itself)\n    */\n   public void setInitialStepSize(final double initialStepSize) {\n-    if ((initialStepSize < minStep) || (initialStepSize > maxStep)) {\n-      initialStep = -1.0;\n-    } else {\n-      initialStep = initialStepSize;\n-    }\n   }\n \n   /** Perform some sanity checks on the integration parameters.\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java", 
          "line": 150, 
          "faulty": "if ((initialStepSize < minStep) || (initialStepSize > maxStep)) {\n  initialStep=-1.0;\n}\n else {\n  initialStep=initialStepSize;\n}", 
          "type": "Delete", 
          "seed": "if ((initialStepSize < minStep) || (initialStepSize > maxStep)) {\n  initialStep=-1.0;\n}\n else {\n  initialStep=initialStepSize;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java", 
          "line": 153, 
          "faulty": "initialStep=initialStepSize;", 
          "type": "Replace", 
          "seed": "this.maxStep=maxStep;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 340, 
          "faulty": "return (nextAction == EventHandler.RESET_STATE) || (nextAction == EventHandler.RESET_DERIVATIVES);", 
          "type": "InsertBefore", 
          "seed": "g0=Double.NaN;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "pendingEvent=true;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_775/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 07:05:52.627413679 -0500\n@@ -208,7 +208,8 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    pendingEvent = true;\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\t2018-12-01 06:00:01.507483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_775/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\t2018-12-01 07:05:52.627413679 -0500\n@@ -150,7 +150,7 @@\n     if ((initialStepSize < minStep) || (initialStepSize > maxStep)) {\n       initialStep = -1.0;\n     } else {\n-      initialStep = initialStepSize;\n+      resetEvaluations();\n     }\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java", 
          "line": 153, 
          "faulty": "initialStep=initialStepSize;", 
          "type": "Replace", 
          "seed": "resetEvaluations();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "pendingEvent=true;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_197/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:18:57.849736712 -0500\n@@ -208,7 +208,8 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    pendingEvent = true;\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n@@ -223,7 +224,8 @@\n                             }\n                         }\n                     };\n-                    final BrentSolver solver = new BrentSolver();\n+                    forward = interpolator.isForward();\n+\t\t\t\t\tfinal BrentSolver solver = new BrentSolver();\n                     solver.setAbsoluteAccuracy(convergence);\n                     solver.setMaximalIterationCount(maxIterationCount);\n                     final double root = (ta <= tb) ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta);\n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\t2018-12-01 06:00:01.507483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_197/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\t2018-12-01 06:18:57.849736712 -0500\n@@ -147,11 +147,6 @@\n    * ignore the value and compute the initial step size by itself)\n    */\n   public void setInitialStepSize(final double initialStepSize) {\n-    if ((initialStepSize < minStep) || (initialStepSize > maxStep)) {\n-      initialStep = -1.0;\n-    } else {\n-      initialStep = initialStepSize;\n-    }\n   }\n \n   /** Perform some sanity checks on the integration parameters.\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java", 
          "line": 150, 
          "faulty": "if ((initialStepSize < minStep) || (initialStepSize > maxStep)) {\n  initialStep=-1.0;\n}\n else {\n  initialStep=initialStepSize;\n}", 
          "type": "Delete", 
          "seed": "if ((initialStepSize < minStep) || (initialStepSize > maxStep)) {\n  initialStep=-1.0;\n}\n else {\n  initialStep=initialStepSize;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 226, 
          "faulty": "final BrentSolver solver=new BrentSolver();", 
          "type": "InsertBefore", 
          "seed": "forward=interpolator.isForward();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "pendingEvent=true;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/CombinedEventsManager.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_1090/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/CombinedEventsManager.java\t2018-12-01 07:31:28.094842771 -0500\n@@ -150,7 +150,8 @@\n             for (EventState state : states) {\n \n                 if (state.evaluateStep(interpolator)) {\n-                    if (first == null) {\n+                    initialized = true;\n+\t\t\t\t\tif (first == null) {\n                         first = state;\n                     } else {\n                         if (interpolator.isForward()) {\n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_1090/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 07:31:28.098842790 -0500\n@@ -208,7 +208,11 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_1090/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java\t2018-12-01 07:31:28.098842790 -0500\n@@ -125,7 +125,8 @@\n                 return true;\n             }\n         }\n-        return false;\n+        stepSize = Double.NaN;\n+\t\treturn false;\n     }\n \n     /** {@inheritDoc} */\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java", 
          "line": 128, 
          "faulty": "return false;", 
          "type": "InsertBefore", 
          "seed": "stepSize=Double.NaN;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/CombinedEventsManager.java", 
          "line": 153, 
          "faulty": "if (first == null) {\n  first=state;\n}\n else {\n  if (interpolator.isForward()) {\n    if (state.getEventTime() < first.getEventTime()) {\n      first=state;\n    }\n  }\n else {\n    if (state.getEventTime() > first.getEventTime()) {\n      first=state;\n    }\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "initialized=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_482/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:42:19.968534555 -0500\n@@ -208,7 +208,11 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n@@ -335,8 +339,6 @@\n             handler.resetState(t, y);\n         }\n         pendingEvent      = false;\n-        pendingEventTime  = Double.NaN;\n-\n         return (nextAction == EventHandler.RESET_STATE) ||\n                (nextAction == EventHandler.RESET_DERIVATIVES);\n \n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 338, 
          "faulty": "pendingEventTime=Double.NaN;", 
          "type": "Delete", 
          "seed": "g0=handler.g(t,y);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_178/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:17:21.181275544 -0500\n@@ -208,7 +208,11 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\t2018-12-01 06:00:01.507483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_178/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\t2018-12-01 06:17:21.181275544 -0500\n@@ -150,7 +150,7 @@\n     if ((initialStepSize < minStep) || (initialStepSize > maxStep)) {\n       initialStep = -1.0;\n     } else {\n-      initialStep = initialStepSize;\n+      resetEvaluations();\n     }\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java", 
          "line": 153, 
          "faulty": "initialStep=initialStepSize;", 
          "type": "Replace", 
          "seed": "resetEvaluations();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_422/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:37:18.223048941 -0500\n@@ -208,7 +208,11 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n@@ -337,7 +341,8 @@\n         pendingEvent      = false;\n         pendingEventTime  = Double.NaN;\n \n-        return (nextAction == EventHandler.RESET_STATE) ||\n+        g0 = Double.NaN;\n+\t\treturn (nextAction == EventHandler.RESET_STATE) ||\n                (nextAction == EventHandler.RESET_DERIVATIVES);\n \n     }\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 340, 
          "faulty": "return (nextAction == EventHandler.RESET_STATE) || (nextAction == EventHandler.RESET_DERIVATIVES);", 
          "type": "InsertBefore", 
          "seed": "g0=Double.NaN;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_1384/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 07:56:29.206268888 -0500\n@@ -208,7 +208,11 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n@@ -334,7 +338,8 @@\n         if (nextAction == EventHandler.RESET_STATE) {\n             handler.resetState(t, y);\n         }\n-        pendingEvent      = false;\n+        pendingEventTime = Double.NaN;\n+\t\tpendingEvent      = false;\n         pendingEventTime  = Double.NaN;\n \n         return (nextAction == EventHandler.RESET_STATE) ||\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 337, 
          "faulty": "pendingEvent=false;", 
          "type": "InsertBefore", 
          "seed": "pendingEventTime=Double.NaN;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_1252/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 07:45:15.590894710 -0500\n@@ -208,7 +208,11 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\t2018-12-01 06:00:01.507483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_1252/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\t2018-12-01 07:45:15.590894710 -0500\n@@ -147,11 +147,7 @@\n    * ignore the value and compute the initial step size by itself)\n    */\n   public void setInitialStepSize(final double initialStepSize) {\n-    if ((initialStepSize < minStep) || (initialStepSize > maxStep)) {\n-      initialStep = -1.0;\n-    } else {\n-      initialStep = initialStepSize;\n-    }\n+    initialStep = initialStepSize;\n   }\n \n   /** Perform some sanity checks on the integration parameters.\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java", 
          "line": 150, 
          "faulty": "if ((initialStepSize < minStep) || (initialStepSize > maxStep)) {\n  initialStep=-1.0;\n}\n else {\n  initialStep=initialStepSize;\n}", 
          "type": "Replace", 
          "seed": "initialStep=initialStepSize;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_910/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 07:16:56.306599200 -0500\n@@ -208,7 +208,8 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    pendingEvent = true;\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:01.483483648 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_910/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 07:16:56.306599200 -0500\n@@ -332,7 +332,13 @@\n             if (Math.abs(delta) > tolerance) {\n                 x1 = x1 + delta;\n             } else if (dx > 0.0) {\n-                x1 = x1 + 0.5 * tolerance;\n+                if ((y1 > 0) == (y2 > 0)) {\n+\t\t\t\t\tx2 = x0;\n+\t\t\t\t\ty2 = y0;\n+\t\t\t\t\tdelta = x1 - x0;\n+\t\t\t\t\toldDelta = delta;\n+\t\t\t\t}\n+\t\t\t\tx1 = x1 + 0.5 * tolerance;\n             } else if (dx <= 0.0) {\n                 x1 = x1 - 0.5 * tolerance;\n             }\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 335, 
          "faulty": "x1=x1 + 0.5 * tolerance;", 
          "type": "InsertBefore", 
          "seed": "if ((y1 > 0) == (y2 > 0)) {\n  x2=x0;\n  y2=y0;\n  delta=x1 - x0;\n  oldDelta=delta;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "pendingEvent=true;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/CombinedEventsManager.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_1038/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/CombinedEventsManager.java\t2018-12-01 07:27:29.237686395 -0500\n@@ -151,6 +151,19 @@\n \n                 if (state.evaluateStep(interpolator)) {\n                     if (first == null) {\n+\t\t\t\t\t\tfirst = state;\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tif (interpolator.isForward()) {\n+\t\t\t\t\t\t\tif (state.getEventTime() < first.getEventTime()) {\n+\t\t\t\t\t\t\t\tfirst = state;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tif (state.getEventTime() > first.getEventTime()) {\n+\t\t\t\t\t\t\t\tfirst = state;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tif (first == null) {\n                         first = state;\n                     } else {\n                         if (interpolator.isForward()) {\n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_1038/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 07:27:29.237686395 -0500\n@@ -208,7 +208,11 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/CombinedEventsManager.java", 
          "line": 153, 
          "faulty": "if (first == null) {\n  first=state;\n}\n else {\n  if (interpolator.isForward()) {\n    if (state.getEventTime() < first.getEventTime()) {\n      first=state;\n    }\n  }\n else {\n    if (state.getEventTime() > first.getEventTime()) {\n      first=state;\n    }\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "if (first == null) {\n  first=state;\n}\n else {\n  if (interpolator.isForward()) {\n    if (state.getEventTime() < first.getEventTime()) {\n      first=state;\n    }\n  }\n else {\n    if (state.getEventTime() > first.getEventTime()) {\n      first=state;\n    }\n  }\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_437/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:38:30.543401726 -0500\n@@ -208,10 +208,65 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    pendingEvent = true;\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n-                    final UnivariateRealFunction f = new UnivariateRealFunction() {\n+                    if (g0Positive ^ (gb >= 0)) {\n+\t\t\t\t\t\tif (ga * gb > 0) {\n+\t\t\t\t\t\t\tfinal double epsilon = (forward ? 0.25 : -0.25)\n+\t\t\t\t\t\t\t\t\t* convergence;\n+\t\t\t\t\t\t\tfor (int k = 0; (k < 4) && (ga * gb > 0); ++k) {\n+\t\t\t\t\t\t\t\tta += epsilon;\n+\t\t\t\t\t\t\t\tinterpolator.setInterpolatedTime(ta);\n+\t\t\t\t\t\t\t\tga = handler.g(ta,\n+\t\t\t\t\t\t\t\t\t\tinterpolator.getInterpolatedState());\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tif (ga * gb > 0) {\n+\t\t\t\t\t\t\t\tthrow MathRuntimeException\n+\t\t\t\t\t\t\t\t\t\t.createInternalError(null);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tincreasing = gb >= ga;\n+\t\t\t\t\t\tfinal UnivariateRealFunction f = new UnivariateRealFunction() {\n+\t\t\t\t\t\t\tpublic double value(final double t)\n+\t\t\t\t\t\t\t\t\tthrows FunctionEvaluationException {\n+\t\t\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\t\t\tinterpolator.setInterpolatedTime(t);\n+\t\t\t\t\t\t\t\t\treturn handler\n+\t\t\t\t\t\t\t\t\t\t\t.g(t, interpolator\n+\t\t\t\t\t\t\t\t\t\t\t\t\t.getInterpolatedState());\n+\t\t\t\t\t\t\t\t} catch (DerivativeException e) {\n+\t\t\t\t\t\t\t\t\tthrow new FunctionEvaluationException(e, t);\n+\t\t\t\t\t\t\t\t} catch (EventException e) {\n+\t\t\t\t\t\t\t\t\tthrow new FunctionEvaluationException(e, t);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t};\n+\t\t\t\t\t\tfinal BrentSolver solver = new BrentSolver();\n+\t\t\t\t\t\tsolver.setAbsoluteAccuracy(convergence);\n+\t\t\t\t\t\tsolver.setMaximalIterationCount(maxIterationCount);\n+\t\t\t\t\t\tfinal double root = (ta <= tb) ? solver\n+\t\t\t\t\t\t\t\t.solve(f, ta, tb) : solver.solve(f, tb, ta);\n+\t\t\t\t\t\tif ((Math.abs(root - ta) <= convergence)\n+\t\t\t\t\t\t\t\t&& (Math.abs(root - previousEventTime) <= convergence)) {\n+\t\t\t\t\t\t\tta = tb;\n+\t\t\t\t\t\t\tga = gb;\n+\t\t\t\t\t\t} else if (Double.isNaN(previousEventTime)\n+\t\t\t\t\t\t\t\t|| (Math.abs(previousEventTime - root) > convergence)) {\n+\t\t\t\t\t\t\tpendingEventTime = root;\n+\t\t\t\t\t\t\tif (pendingEvent\n+\t\t\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\t\t\treturn false;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tpendingEvent = true;\n+\t\t\t\t\t\t\treturn true;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tta = tb;\n+\t\t\t\t\t\tga = gb;\n+\t\t\t\t\t}\n+\t\t\t\t\tfinal UnivariateRealFunction f = new UnivariateRealFunction() {\n                         public double value(final double t) throws FunctionEvaluationException {\n                             try {\n                                 interpolator.setInterpolatedTime(t);\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "pendingEvent=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 214, 
          "faulty": "final UnivariateRealFunction f=new UnivariateRealFunction(){\n  public double value(  final double t) throws FunctionEvaluationException {\n    try {\n      interpolator.setInterpolatedTime(t);\n      return handler.g(t,interpolator.getInterpolatedState());\n    }\n catch (    DerivativeException e) {\n      throw new FunctionEvaluationException(e,t);\n    }\ncatch (    EventException e) {\n      throw new FunctionEvaluationException(e,t);\n    }\n  }\n}\n;", 
          "type": "InsertBefore", 
          "seed": "if (g0Positive ^ (gb >= 0)) {\n  if (ga * gb > 0) {\n    final double epsilon=(forward ? 0.25 : -0.25) * convergence;\n    for (int k=0; (k < 4) && (ga * gb > 0); ++k) {\n      ta+=epsilon;\n      interpolator.setInterpolatedTime(ta);\n      ga=handler.g(ta,interpolator.getInterpolatedState());\n    }\n    if (ga * gb > 0) {\n      throw MathRuntimeException.createInternalError(null);\n    }\n  }\n  increasing=gb >= ga;\n  final UnivariateRealFunction f=new UnivariateRealFunction(){\n    public double value(    final double t) throws FunctionEvaluationException {\n      try {\n        interpolator.setInterpolatedTime(t);\n        return handler.g(t,interpolator.getInterpolatedState());\n      }\n catch (      DerivativeException e) {\n        throw new FunctionEvaluationException(e,t);\n      }\ncatch (      EventException e) {\n        throw new FunctionEvaluationException(e,t);\n      }\n    }\n  }\n;\n  final BrentSolver solver=new BrentSolver();\n  solver.setAbsoluteAccuracy(convergence);\n  solver.setMaximalIterationCount(maxIterationCount);\n  final double root=(ta <= tb) ? solver.solve(f,ta,tb) : solver.solve(f,tb,ta);\n  if ((Math.abs(root - ta) <= convergence) && (Math.abs(root - previousEventTime) <= convergence)) {\n    ta=tb;\n    ga=gb;\n  }\n else   if (Double.isNaN(previousEventTime) || (Math.abs(previousEventTime - root) > convergence)) {\n    pendingEventTime=root;\n    if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n      return false;\n    }\n    pendingEvent=true;\n    return true;\n  }\n}\n else {\n  ta=tb;\n  ga=gb;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_997/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 07:24:08.216709735 -0500\n@@ -208,7 +208,8 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    pendingEvent = true;\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n@@ -331,9 +332,7 @@\n             return false;\n         }\n \n-        if (nextAction == EventHandler.RESET_STATE) {\n-            handler.resetState(t, y);\n-        }\n+        handler.resetState(t, y);\n         pendingEvent      = false;\n         pendingEventTime  = Double.NaN;\n \n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 334, 
          "faulty": "if (nextAction == EventHandler.RESET_STATE) {\n  handler.resetState(t,y);\n}", 
          "type": "Replace", 
          "seed": "handler.resetState(t,y);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "pendingEvent=true;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_717/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 07:01:09.110037341 -0500\n@@ -208,7 +208,11 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n@@ -337,8 +341,7 @@\n         pendingEvent      = false;\n         pendingEventTime  = Double.NaN;\n \n-        return (nextAction == EventHandler.RESET_STATE) ||\n-               (nextAction == EventHandler.RESET_DERIVATIVES);\n+        return true;\n \n     }\n \n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 340, 
          "faulty": "return (nextAction == EventHandler.RESET_STATE) || (nextAction == EventHandler.RESET_DERIVATIVES);", 
          "type": "Replace", 
          "seed": "return true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_759/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 07:04:40.755066105 -0500\n@@ -208,7 +208,11 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n@@ -232,21 +236,19 @@\n                         // we have either found nothing or found (again ?) a past event, we simply ignore it\n                         ta = tb;\n                         ga = gb;\n-                    } else if (Double.isNaN(previousEventTime) ||\n-                               (Math.abs(previousEventTime - root) > convergence)) {\n-                        pendingEventTime = root;\n-                        if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n-                            // we were already waiting for this event which was\n-                            // found during a previous call for a step that was\n-                            // rejected, this step must now be accepted since it\n-                            // properly ends exactly at the event occurrence\n-                            return false;\n-                        }\n-                        // either we were not waiting for the event or it has\n-                        // moved in such a way the step cannot be accepted\n-                        pendingEvent = true;\n-                        return true;\n-                    }\n+                    } else {\n+\t\t\t\t\t\tga = handler.g(ta, interpolator.getInterpolatedState());\n+\t\t\t\t\t\tif (Double.isNaN(previousEventTime)\n+\t\t\t\t\t\t\t\t|| (Math.abs(previousEventTime - root) > convergence)) {\n+\t\t\t\t\t\t\tpendingEventTime = root;\n+\t\t\t\t\t\t\tif (pendingEvent\n+\t\t\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\t\t\treturn false;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tpendingEvent = true;\n+\t\t\t\t\t\t\treturn true;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n \n                 } else {\n                     // no sign change: there is no event for now\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 235, 
          "faulty": "if (Double.isNaN(previousEventTime) || (Math.abs(previousEventTime - root) > convergence)) {\n  pendingEventTime=root;\n  if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n    return false;\n  }\n  pendingEvent=true;\n  return true;\n}", 
          "type": "InsertBefore", 
          "seed": "ga=handler.g(ta,interpolator.getInterpolatedState());"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_615/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:52:51.195637940 -0500\n@@ -208,7 +208,11 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n@@ -232,21 +236,32 @@\n                         // we have either found nothing or found (again ?) a past event, we simply ignore it\n                         ta = tb;\n                         ga = gb;\n-                    } else if (Double.isNaN(previousEventTime) ||\n-                               (Math.abs(previousEventTime - root) > convergence)) {\n-                        pendingEventTime = root;\n-                        if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n-                            // we were already waiting for this event which was\n-                            // found during a previous call for a step that was\n-                            // rejected, this step must now be accepted since it\n-                            // properly ends exactly at the event occurrence\n-                            return false;\n-                        }\n-                        // either we were not waiting for the event or it has\n-                        // moved in such a way the step cannot be accepted\n-                        pendingEvent = true;\n-                        return true;\n-                    }\n+                    } else {\n+\t\t\t\t\t\tif (ga * gb > 0) {\n+\t\t\t\t\t\t\tfinal double epsilon = (forward ? 0.25 : -0.25)\n+\t\t\t\t\t\t\t\t\t* convergence;\n+\t\t\t\t\t\t\tfor (int k = 0; (k < 4) && (ga * gb > 0); ++k) {\n+\t\t\t\t\t\t\t\tta += epsilon;\n+\t\t\t\t\t\t\t\tinterpolator.setInterpolatedTime(ta);\n+\t\t\t\t\t\t\t\tga = handler.g(ta,\n+\t\t\t\t\t\t\t\t\t\tinterpolator.getInterpolatedState());\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tif (ga * gb > 0) {\n+\t\t\t\t\t\t\t\tthrow MathRuntimeException\n+\t\t\t\t\t\t\t\t\t\t.createInternalError(null);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tif (Double.isNaN(previousEventTime)\n+\t\t\t\t\t\t\t\t|| (Math.abs(previousEventTime - root) > convergence)) {\n+\t\t\t\t\t\t\tpendingEventTime = root;\n+\t\t\t\t\t\t\tif (pendingEvent\n+\t\t\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\t\t\treturn false;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tpendingEvent = true;\n+\t\t\t\t\t\t\treturn true;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n \n                 } else {\n                     // no sign change: there is no event for now\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 248, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "g0Positive=increasing;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 235, 
          "faulty": "if (Double.isNaN(previousEventTime) || (Math.abs(previousEventTime - root) > convergence)) {\n  pendingEventTime=root;\n  if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n    return false;\n  }\n  pendingEvent=true;\n  return true;\n}", 
          "type": "InsertBefore", 
          "seed": "if (ga * gb > 0) {\n  final double epsilon=(forward ? 0.25 : -0.25) * convergence;\n  for (int k=0; (k < 4) && (ga * gb > 0); ++k) {\n    ta+=epsilon;\n    interpolator.setInterpolatedTime(ta);\n    ga=handler.g(ta,interpolator.getInterpolatedState());\n  }\n  if (ga * gb > 0) {\n    throw MathRuntimeException.createInternalError(null);\n  }\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 237, 
          "faulty": "pendingEventTime=root;", 
          "type": "Delete", 
          "seed": "ta=tb;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_287/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:25:57.035733784 -0500\n@@ -208,7 +208,11 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n@@ -335,7 +339,7 @@\n             handler.resetState(t, y);\n         }\n         pendingEvent      = false;\n-        pendingEventTime  = Double.NaN;\n+        g0 = handler.g(t, y);\n \n         return (nextAction == EventHandler.RESET_STATE) ||\n                (nextAction == EventHandler.RESET_DERIVATIVES);\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 338, 
          "faulty": "pendingEventTime=Double.NaN;", 
          "type": "Replace", 
          "seed": "g0=handler.g(t,y);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_589/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:50:58.499090168 -0500\n@@ -208,7 +208,11 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n@@ -235,7 +239,17 @@\n                     } else if (Double.isNaN(previousEventTime) ||\n                                (Math.abs(previousEventTime - root) > convergence)) {\n                         pendingEventTime = root;\n-                        if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+                        if (Double.isNaN(previousEventTime)\n+\t\t\t\t\t\t\t\t|| (Math.abs(previousEventTime - root) > convergence)) {\n+\t\t\t\t\t\t\tpendingEventTime = root;\n+\t\t\t\t\t\t\tif (pendingEvent\n+\t\t\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\t\t\treturn false;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tpendingEvent = true;\n+\t\t\t\t\t\t\treturn true;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tif (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n                             // we were already waiting for this event which was\n                             // found during a previous call for a step that was\n                             // rejected, this step must now be accepted since it\n@@ -245,7 +259,7 @@\n                         // either we were not waiting for the event or it has\n                         // moved in such a way the step cannot be accepted\n                         pendingEvent = true;\n-                        return true;\n+                        g0Positive = increasing;\n                     }\n \n                 } else {\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 248, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "g0Positive=increasing;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 238, 
          "faulty": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}", 
          "type": "InsertBefore", 
          "seed": "if (Double.isNaN(previousEventTime) || (Math.abs(previousEventTime - root) > convergence)) {\n  pendingEventTime=root;\n  if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n    return false;\n  }\n  pendingEvent=true;\n  return true;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\t2018-12-01 06:00:05.075483730 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_902/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\t2018-12-01 07:16:26.946458855 -0500\n@@ -120,7 +120,10 @@\n       rki.reinitialize(this, yTmp, yDotK, forward);\n       interpolator = rki;\n     } else {\n-      interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);\n+      for (StepHandler handler : stepHandlers) {\n+\t\t\thandler.reset();\n+\t\t}\n+\tinterpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);\n     }\n     interpolator.storeTime(t0);\n \n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_902/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 07:16:26.946458855 -0500\n@@ -208,7 +208,11 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n@@ -331,9 +335,7 @@\n             return false;\n         }\n \n-        if (nextAction == EventHandler.RESET_STATE) {\n-            handler.resetState(t, y);\n-        }\n+        handler.resetState(t, y);\n         pendingEvent      = false;\n         pendingEventTime  = Double.NaN;\n \n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java", 
          "line": 123, 
          "faulty": "interpolator=new DummyStepInterpolator(yTmp,yDotK[stages - 1],forward);", 
          "type": "InsertBefore", 
          "seed": "for (StepHandler handler : stepHandlers) {\n  handler.reset();\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 334, 
          "faulty": "if (nextAction == EventHandler.RESET_STATE) {\n  handler.resetState(t,y);\n}", 
          "type": "Replace", 
          "seed": "handler.resetState(t,y);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_107/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:11:27.051518734 -0500\n@@ -208,10 +208,68 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n-                    final UnivariateRealFunction f = new UnivariateRealFunction() {\n+                    if (g0Positive ^ (gb >= 0)) {\n+\t\t\t\t\t\tif (ga * gb > 0) {\n+\t\t\t\t\t\t\tfinal double epsilon = (forward ? 0.25 : -0.25)\n+\t\t\t\t\t\t\t\t\t* convergence;\n+\t\t\t\t\t\t\tfor (int k = 0; (k < 4) && (ga * gb > 0); ++k) {\n+\t\t\t\t\t\t\t\tta += epsilon;\n+\t\t\t\t\t\t\t\tinterpolator.setInterpolatedTime(ta);\n+\t\t\t\t\t\t\t\tga = handler.g(ta,\n+\t\t\t\t\t\t\t\t\t\tinterpolator.getInterpolatedState());\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tif (ga * gb > 0) {\n+\t\t\t\t\t\t\t\tthrow MathRuntimeException\n+\t\t\t\t\t\t\t\t\t\t.createInternalError(null);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tincreasing = gb >= ga;\n+\t\t\t\t\t\tfinal UnivariateRealFunction f = new UnivariateRealFunction() {\n+\t\t\t\t\t\t\tpublic double value(final double t)\n+\t\t\t\t\t\t\t\t\tthrows FunctionEvaluationException {\n+\t\t\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\t\t\tinterpolator.setInterpolatedTime(t);\n+\t\t\t\t\t\t\t\t\treturn handler\n+\t\t\t\t\t\t\t\t\t\t\t.g(t, interpolator\n+\t\t\t\t\t\t\t\t\t\t\t\t\t.getInterpolatedState());\n+\t\t\t\t\t\t\t\t} catch (DerivativeException e) {\n+\t\t\t\t\t\t\t\t\tthrow new FunctionEvaluationException(e, t);\n+\t\t\t\t\t\t\t\t} catch (EventException e) {\n+\t\t\t\t\t\t\t\t\tthrow new FunctionEvaluationException(e, t);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t};\n+\t\t\t\t\t\tfinal BrentSolver solver = new BrentSolver();\n+\t\t\t\t\t\tsolver.setAbsoluteAccuracy(convergence);\n+\t\t\t\t\t\tsolver.setMaximalIterationCount(maxIterationCount);\n+\t\t\t\t\t\tfinal double root = (ta <= tb) ? solver\n+\t\t\t\t\t\t\t\t.solve(f, ta, tb) : solver.solve(f, tb, ta);\n+\t\t\t\t\t\tif ((Math.abs(root - ta) <= convergence)\n+\t\t\t\t\t\t\t\t&& (Math.abs(root - previousEventTime) <= convergence)) {\n+\t\t\t\t\t\t\tta = tb;\n+\t\t\t\t\t\t\tga = gb;\n+\t\t\t\t\t\t} else if (Double.isNaN(previousEventTime)\n+\t\t\t\t\t\t\t\t|| (Math.abs(previousEventTime - root) > convergence)) {\n+\t\t\t\t\t\t\tpendingEventTime = root;\n+\t\t\t\t\t\t\tif (pendingEvent\n+\t\t\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\t\t\treturn false;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tpendingEvent = true;\n+\t\t\t\t\t\t\treturn true;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tta = tb;\n+\t\t\t\t\t\tga = gb;\n+\t\t\t\t\t}\n+\t\t\t\t\tfinal UnivariateRealFunction f = new UnivariateRealFunction() {\n                         public double value(final double t) throws FunctionEvaluationException {\n                             try {\n                                 interpolator.setInterpolatedTime(t);\n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/sampling/DummyStepInterpolator.java\t2018-12-01 06:00:01.511483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_107/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/sampling/DummyStepInterpolator.java\t2018-12-01 06:11:27.055518758 -0500\n@@ -104,7 +104,9 @@\n   @Override\n   protected void computeInterpolatedStateAndDerivatives(final double theta, final double oneMinusThetaH)\n     throws DerivativeException {\n-      System.arraycopy(currentState,      0, interpolatedState,       0, currentState.length);\n+      System.arraycopy(currentDerivative, 0, interpolatedDerivatives, 0,\n+\t\t\t\tcurrentDerivative.length);\n+\tSystem.arraycopy(currentState,      0, interpolatedState,       0, currentState.length);\n       System.arraycopy(currentDerivative, 0, interpolatedDerivatives, 0, currentDerivative.length);\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/sampling/DummyStepInterpolator.java", 
          "line": 107, 
          "faulty": "System.arraycopy(currentState,0,interpolatedState,0,currentState.length);", 
          "type": "InsertBefore", 
          "seed": "System.arraycopy(currentDerivative,0,interpolatedDerivatives,0,currentDerivative.length);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 214, 
          "faulty": "final UnivariateRealFunction f=new UnivariateRealFunction(){\n  public double value(  final double t) throws FunctionEvaluationException {\n    try {\n      interpolator.setInterpolatedTime(t);\n      return handler.g(t,interpolator.getInterpolatedState());\n    }\n catch (    DerivativeException e) {\n      throw new FunctionEvaluationException(e,t);\n    }\ncatch (    EventException e) {\n      throw new FunctionEvaluationException(e,t);\n    }\n  }\n}\n;", 
          "type": "InsertBefore", 
          "seed": "if (g0Positive ^ (gb >= 0)) {\n  if (ga * gb > 0) {\n    final double epsilon=(forward ? 0.25 : -0.25) * convergence;\n    for (int k=0; (k < 4) && (ga * gb > 0); ++k) {\n      ta+=epsilon;\n      interpolator.setInterpolatedTime(ta);\n      ga=handler.g(ta,interpolator.getInterpolatedState());\n    }\n    if (ga * gb > 0) {\n      throw MathRuntimeException.createInternalError(null);\n    }\n  }\n  increasing=gb >= ga;\n  final UnivariateRealFunction f=new UnivariateRealFunction(){\n    public double value(    final double t) throws FunctionEvaluationException {\n      try {\n        interpolator.setInterpolatedTime(t);\n        return handler.g(t,interpolator.getInterpolatedState());\n      }\n catch (      DerivativeException e) {\n        throw new FunctionEvaluationException(e,t);\n      }\ncatch (      EventException e) {\n        throw new FunctionEvaluationException(e,t);\n      }\n    }\n  }\n;\n  final BrentSolver solver=new BrentSolver();\n  solver.setAbsoluteAccuracy(convergence);\n  solver.setMaximalIterationCount(maxIterationCount);\n  final double root=(ta <= tb) ? solver.solve(f,ta,tb) : solver.solve(f,tb,ta);\n  if ((Math.abs(root - ta) <= convergence) && (Math.abs(root - previousEventTime) <= convergence)) {\n    ta=tb;\n    ga=gb;\n  }\n else   if (Double.isNaN(previousEventTime) || (Math.abs(previousEventTime - root) > convergence)) {\n    pendingEventTime=root;\n    if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n      return false;\n    }\n    pendingEvent=true;\n    return true;\n  }\n}\n else {\n  ta=tb;\n  ga=gb;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_242/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:22:32.050748149 -0500\n@@ -208,7 +208,11 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\t2018-12-01 06:00:01.507483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_242/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\t2018-12-01 06:22:32.050748149 -0500\n@@ -147,11 +147,6 @@\n    * ignore the value and compute the initial step size by itself)\n    */\n   public void setInitialStepSize(final double initialStepSize) {\n-    if ((initialStepSize < minStep) || (initialStepSize > maxStep)) {\n-      initialStep = -1.0;\n-    } else {\n-      initialStep = initialStepSize;\n-    }\n   }\n \n   /** Perform some sanity checks on the integration parameters.\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java", 
          "line": 150, 
          "faulty": "if ((initialStepSize < minStep) || (initialStepSize > maxStep)) {\n  initialStep=-1.0;\n}\n else {\n  initialStep=initialStepSize;\n}", 
          "type": "Delete", 
          "seed": "if ((initialStepSize < minStep) || (initialStepSize > maxStep)) {\n  initialStep=-1.0;\n}\n else {\n  initialStep=initialStepSize;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_1390/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 07:56:58.058412387 -0500\n@@ -208,7 +208,11 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n@@ -232,21 +236,32 @@\n                         // we have either found nothing or found (again ?) a past event, we simply ignore it\n                         ta = tb;\n                         ga = gb;\n-                    } else if (Double.isNaN(previousEventTime) ||\n-                               (Math.abs(previousEventTime - root) > convergence)) {\n-                        pendingEventTime = root;\n-                        if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n-                            // we were already waiting for this event which was\n-                            // found during a previous call for a step that was\n-                            // rejected, this step must now be accepted since it\n-                            // properly ends exactly at the event occurrence\n-                            return false;\n-                        }\n-                        // either we were not waiting for the event or it has\n-                        // moved in such a way the step cannot be accepted\n-                        pendingEvent = true;\n-                        return true;\n-                    }\n+                    } else {\n+\t\t\t\t\t\tif (ga * gb > 0) {\n+\t\t\t\t\t\t\tfinal double epsilon = (forward ? 0.25 : -0.25)\n+\t\t\t\t\t\t\t\t\t* convergence;\n+\t\t\t\t\t\t\tfor (int k = 0; (k < 4) && (ga * gb > 0); ++k) {\n+\t\t\t\t\t\t\t\tta += epsilon;\n+\t\t\t\t\t\t\t\tinterpolator.setInterpolatedTime(ta);\n+\t\t\t\t\t\t\t\tga = handler.g(ta,\n+\t\t\t\t\t\t\t\t\t\tinterpolator.getInterpolatedState());\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tif (ga * gb > 0) {\n+\t\t\t\t\t\t\t\tthrow MathRuntimeException\n+\t\t\t\t\t\t\t\t\t\t.createInternalError(null);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tif (Double.isNaN(previousEventTime)\n+\t\t\t\t\t\t\t\t|| (Math.abs(previousEventTime - root) > convergence)) {\n+\t\t\t\t\t\t\tpendingEventTime = root;\n+\t\t\t\t\t\t\tif (pendingEvent\n+\t\t\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\t\t\treturn false;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tpendingEvent = true;\n+\t\t\t\t\t\t\treturn true;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n \n                 } else {\n                     // no sign change: there is no event for now\n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\t2018-12-01 06:00:05.075483730 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_1390/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\t2018-12-01 07:56:58.058412387 -0500\n@@ -172,7 +172,18 @@\n         if (manager.evaluateStep(interpolator)) {\n             final double dt = manager.getEventTime() - stepStart;\n             if (Math.abs(dt) <= Math.ulp(stepStart)) {\n-                // we cannot simply truncate the step, reject the current computation\n+                for (int k = 1; k < stages; ++k) {\n+\t\t\t\t\tfor (int j = 0; j < y0.length; ++j) {\n+\t\t\t\t\t\tdouble sum = a[k - 1][0] * yDotK[0][j];\n+\t\t\t\t\t\tfor (int l = 1; l < k; ++l) {\n+\t\t\t\t\t\t\tsum += a[k - 1][l] * yDotK[l][j];\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tyTmp[j] = y[j] + stepSize * sum;\n+\t\t\t\t\t}\n+\t\t\t\t\tcomputeDerivatives(stepStart + c[k - 1] * stepSize, yTmp,\n+\t\t\t\t\t\t\tyDotK[k]);\n+\t\t\t\t}\n+\t\t\t\t// we cannot simply truncate the step, reject the current computation\n                 // and let the loop compute another state with the truncated step.\n                 // it is so small (much probably exactly 0 due to limited accuracy)\n                 // that the code above would fail handling it.\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 235, 
          "faulty": "if (Double.isNaN(previousEventTime) || (Math.abs(previousEventTime - root) > convergence)) {\n  pendingEventTime=root;\n  if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n    return false;\n  }\n  pendingEvent=true;\n  return true;\n}", 
          "type": "InsertBefore", 
          "seed": "if (ga * gb > 0) {\n  final double epsilon=(forward ? 0.25 : -0.25) * convergence;\n  for (int k=0; (k < 4) && (ga * gb > 0); ++k) {\n    ta+=epsilon;\n    interpolator.setInterpolatedTime(ta);\n    ga=handler.g(ta,interpolator.getInterpolatedState());\n  }\n  if (ga * gb > 0) {\n    throw MathRuntimeException.createInternalError(null);\n  }\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java", 
          "line": 180, 
          "faulty": "loop=false;", 
          "type": "InsertBefore", 
          "seed": "for (int k=1; k < stages; ++k) {\n  for (int j=0; j < y0.length; ++j) {\n    double sum=a[k - 1][0] * yDotK[0][j];\n    for (int l=1; l < k; ++l) {\n      sum+=a[k - 1][l] * yDotK[l][j];\n    }\n    yTmp[j]=y[j] + stepSize * sum;\n  }\n  computeDerivatives(stepStart + c[k - 1] * stepSize,yTmp,yDotK[k]);\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_604/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:51:56.427372076 -0500\n@@ -208,7 +208,11 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\t2018-12-01 06:00:01.507483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_604/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\t2018-12-01 06:51:56.431372096 -0500\n@@ -289,7 +289,8 @@\n       }\n \n       if (filteredH > maxStep) {\n-          filteredH = maxStep;\n+          stepSize = filterStep(stepSize, forward, true);\n+\t\tfilteredH = maxStep;\n       } else if (filteredH < -maxStep) {\n           filteredH = -maxStep;\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java", 
          "line": 292, 
          "faulty": "filteredH=maxStep;", 
          "type": "InsertBefore", 
          "seed": "stepSize=filterStep(stepSize,forward,true);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_381/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:33:52.098037760 -0500\n@@ -208,7 +208,11 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n@@ -242,9 +246,16 @@\n                             // properly ends exactly at the event occurrence\n                             return false;\n                         }\n-                        // either we were not waiting for the event or it has\n-                        // moved in such a way the step cannot be accepted\n-                        pendingEvent = true;\n+                        if (Double.isNaN(previousEventTime)\n+\t\t\t\t\t\t\t\t|| (Math.abs(previousEventTime - root) > convergence)) {\n+\t\t\t\t\t\t\tpendingEventTime = root;\n+\t\t\t\t\t\t\tif (pendingEvent\n+\t\t\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\t\t\treturn false;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tpendingEvent = true;\n+\t\t\t\t\t\t\treturn true;\n+\t\t\t\t\t\t}\n                         return true;\n                     }\n \n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 247, 
          "faulty": "pendingEvent=true;", 
          "type": "Replace", 
          "seed": "if (Double.isNaN(previousEventTime) || (Math.abs(previousEventTime - root) > convergence)) {\n  pendingEventTime=root;\n  if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n    return false;\n  }\n  pendingEvent=true;\n  return true;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_153/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:15:17.888680934 -0500\n@@ -208,7 +208,8 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    pendingEvent = true;\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\t2018-12-01 06:00:01.507483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_153/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\t2018-12-01 06:15:17.892680953 -0500\n@@ -148,6 +148,11 @@\n    */\n   public void setInitialStepSize(final double initialStepSize) {\n     if ((initialStepSize < minStep) || (initialStepSize > maxStep)) {\n+\t\tinitialStep = -1.0;\n+\t} else {\n+\t\tinitialStep = initialStepSize;\n+\t}\n+\tif ((initialStepSize < minStep) || (initialStepSize > maxStep)) {\n       initialStep = -1.0;\n     } else {\n       initialStep = initialStepSize;\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java", 
          "line": 150, 
          "faulty": "if ((initialStepSize < minStep) || (initialStepSize > maxStep)) {\n  initialStep=-1.0;\n}\n else {\n  initialStep=initialStepSize;\n}", 
          "type": "InsertBefore", 
          "seed": "if ((initialStepSize < minStep) || (initialStepSize > maxStep)) {\n  initialStep=-1.0;\n}\n else {\n  initialStep=initialStepSize;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "pendingEvent=true;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_1168/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 07:38:07.924770827 -0500\n@@ -208,7 +208,8 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    pendingEvent = true;\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n@@ -242,9 +243,7 @@\n                             // properly ends exactly at the event occurrence\n                             return false;\n                         }\n-                        // either we were not waiting for the event or it has\n-                        // moved in such a way the step cannot be accepted\n-                        pendingEvent = true;\n+                        solver.setAbsoluteAccuracy(convergence);\n                         return true;\n                     }\n \n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 247, 
          "faulty": "pendingEvent=true;", 
          "type": "Replace", 
          "seed": "solver.setAbsoluteAccuracy(convergence);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "pendingEvent=true;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_112/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:11:45.535623173 -0500\n@@ -208,7 +208,8 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    pendingEvent = true;\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\t2018-12-01 06:00:01.507483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_112/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\t2018-12-01 06:11:45.535623173 -0500\n@@ -147,11 +147,6 @@\n    * ignore the value and compute the initial step size by itself)\n    */\n   public void setInitialStepSize(final double initialStepSize) {\n-    if ((initialStepSize < minStep) || (initialStepSize > maxStep)) {\n-      initialStep = -1.0;\n-    } else {\n-      initialStep = initialStepSize;\n-    }\n   }\n \n   /** Perform some sanity checks on the integration parameters.\n@@ -207,8 +202,7 @@\n       throws DerivativeException {\n \n     if (initialStep > 0) {\n-      // use the user provided value\n-      return forward ? initialStep : -initialStep;\n+      stepStart = t0;\n     }\n \n     // very rough first guess : h = 0.01 * ||y/scale|| / ||y'/scale||\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java", 
          "line": 211, 
          "faulty": "return forward ? initialStep : -initialStep;", 
          "type": "Replace", 
          "seed": "stepStart=t0;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java", 
          "line": 150, 
          "faulty": "if ((initialStepSize < minStep) || (initialStepSize > maxStep)) {\n  initialStep=-1.0;\n}\n else {\n  initialStep=initialStepSize;\n}", 
          "type": "Delete", 
          "seed": "if ((initialStepSize < minStep) || (initialStepSize > maxStep)) {\n  initialStep=-1.0;\n}\n else {\n  initialStep=initialStepSize;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "pendingEvent=true;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/CombinedEventsManager.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_168/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/CombinedEventsManager.java\t2018-12-01 06:16:31.389036448 -0500\n@@ -151,7 +151,23 @@\n \n                 if (state.evaluateStep(interpolator)) {\n                     if (first == null) {\n-                        first = state;\n+                        if (state.evaluateStep(interpolator)) {\n+\t\t\t\t\t\t\tif (first == null) {\n+\t\t\t\t\t\t\t\tfirst = state;\n+\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\tif (interpolator.isForward()) {\n+\t\t\t\t\t\t\t\t\tif (state.getEventTime() < first\n+\t\t\t\t\t\t\t\t\t\t\t.getEventTime()) {\n+\t\t\t\t\t\t\t\t\t\tfirst = state;\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\tif (state.getEventTime() > first\n+\t\t\t\t\t\t\t\t\t\t\t.getEventTime()) {\n+\t\t\t\t\t\t\t\t\t\tfirst = state;\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n                     } else {\n                         if (interpolator.isForward()) {\n                             if (state.getEventTime() < first.getEventTime()) {\n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_168/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:16:31.389036448 -0500\n@@ -208,7 +208,10 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (ga * gb > 0) {\n+\t\t\t\t\t\tthrow MathRuntimeException.createInternalError(null);\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/CombinedEventsManager.java", 
          "line": 154, 
          "faulty": "first=state;", 
          "type": "Replace", 
          "seed": "if (state.evaluateStep(interpolator)) {\n  if (first == null) {\n    first=state;\n  }\n else {\n    if (interpolator.isForward()) {\n      if (state.getEventTime() < first.getEventTime()) {\n        first=state;\n      }\n    }\n else {\n      if (state.getEventTime() > first.getEventTime()) {\n        first=state;\n      }\n    }\n  }\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (ga * gb > 0) {\n  throw MathRuntimeException.createInternalError(null);\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_995/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 07:24:03.188685259 -0500\n@@ -208,10 +208,65 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    pendingEvent = true;\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n-                    final UnivariateRealFunction f = new UnivariateRealFunction() {\n+                    if (g0Positive ^ (gb >= 0)) {\n+\t\t\t\t\t\tif (ga * gb > 0) {\n+\t\t\t\t\t\t\tfinal double epsilon = (forward ? 0.25 : -0.25)\n+\t\t\t\t\t\t\t\t\t* convergence;\n+\t\t\t\t\t\t\tfor (int k = 0; (k < 4) && (ga * gb > 0); ++k) {\n+\t\t\t\t\t\t\t\tta += epsilon;\n+\t\t\t\t\t\t\t\tinterpolator.setInterpolatedTime(ta);\n+\t\t\t\t\t\t\t\tga = handler.g(ta,\n+\t\t\t\t\t\t\t\t\t\tinterpolator.getInterpolatedState());\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tif (ga * gb > 0) {\n+\t\t\t\t\t\t\t\tthrow MathRuntimeException\n+\t\t\t\t\t\t\t\t\t\t.createInternalError(null);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tincreasing = gb >= ga;\n+\t\t\t\t\t\tfinal UnivariateRealFunction f = new UnivariateRealFunction() {\n+\t\t\t\t\t\t\tpublic double value(final double t)\n+\t\t\t\t\t\t\t\t\tthrows FunctionEvaluationException {\n+\t\t\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\t\t\tinterpolator.setInterpolatedTime(t);\n+\t\t\t\t\t\t\t\t\treturn handler\n+\t\t\t\t\t\t\t\t\t\t\t.g(t, interpolator\n+\t\t\t\t\t\t\t\t\t\t\t\t\t.getInterpolatedState());\n+\t\t\t\t\t\t\t\t} catch (DerivativeException e) {\n+\t\t\t\t\t\t\t\t\tthrow new FunctionEvaluationException(e, t);\n+\t\t\t\t\t\t\t\t} catch (EventException e) {\n+\t\t\t\t\t\t\t\t\tthrow new FunctionEvaluationException(e, t);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t};\n+\t\t\t\t\t\tfinal BrentSolver solver = new BrentSolver();\n+\t\t\t\t\t\tsolver.setAbsoluteAccuracy(convergence);\n+\t\t\t\t\t\tsolver.setMaximalIterationCount(maxIterationCount);\n+\t\t\t\t\t\tfinal double root = (ta <= tb) ? solver\n+\t\t\t\t\t\t\t\t.solve(f, ta, tb) : solver.solve(f, tb, ta);\n+\t\t\t\t\t\tif ((Math.abs(root - ta) <= convergence)\n+\t\t\t\t\t\t\t\t&& (Math.abs(root - previousEventTime) <= convergence)) {\n+\t\t\t\t\t\t\tta = tb;\n+\t\t\t\t\t\t\tga = gb;\n+\t\t\t\t\t\t} else if (Double.isNaN(previousEventTime)\n+\t\t\t\t\t\t\t\t|| (Math.abs(previousEventTime - root) > convergence)) {\n+\t\t\t\t\t\t\tpendingEventTime = root;\n+\t\t\t\t\t\t\tif (pendingEvent\n+\t\t\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\t\t\treturn false;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tpendingEvent = true;\n+\t\t\t\t\t\t\treturn true;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tta = tb;\n+\t\t\t\t\t\tga = gb;\n+\t\t\t\t\t}\n+\t\t\t\t\tfinal UnivariateRealFunction f = new UnivariateRealFunction() {\n                         public double value(final double t) throws FunctionEvaluationException {\n                             try {\n                                 interpolator.setInterpolatedTime(t);\n@@ -234,7 +289,6 @@\n                         ga = gb;\n                     } else if (Double.isNaN(previousEventTime) ||\n                                (Math.abs(previousEventTime - root) > convergence)) {\n-                        pendingEventTime = root;\n                         if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n                             // we were already waiting for this event which was\n                             // found during a previous call for a step that was\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "pendingEvent=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 237, 
          "faulty": "pendingEventTime=root;", 
          "type": "Delete", 
          "seed": "for (int i=0; i < n; ++i) {\n  tb+=h;\n  interpolator.setInterpolatedTime(tb);\n  final double gb=handler.g(tb,interpolator.getInterpolatedState());\n  if (g0Positive ^ (gb >= 0)) {\n    if (ga * gb > 0) {\n      final double epsilon=(forward ? 0.25 : -0.25) * convergence;\n      for (int k=0; (k < 4) && (ga * gb > 0); ++k) {\n        ta+=epsilon;\n        interpolator.setInterpolatedTime(ta);\n        ga=handler.g(ta,interpolator.getInterpolatedState());\n      }\n      if (ga * gb > 0) {\n        throw MathRuntimeException.createInternalError(null);\n      }\n    }\n    increasing=gb >= ga;\n    final UnivariateRealFunction f=new UnivariateRealFunction(){\n      public double value(      final double t) throws FunctionEvaluationException {\n        try {\n          interpolator.setInterpolatedTime(t);\n          return handler.g(t,interpolator.getInterpolatedState());\n        }\n catch (        DerivativeException e) {\n          throw new FunctionEvaluationException(e,t);\n        }\ncatch (        EventException e) {\n          throw new FunctionEvaluationException(e,t);\n        }\n      }\n    }\n;\n    final BrentSolver solver=new BrentSolver();\n    solver.setAbsoluteAccuracy(convergence);\n    solver.setMaximalIterationCount(maxIterationCount);\n    final double root=(ta <= tb) ? solver.solve(f,ta,tb) : solver.solve(f,tb,ta);\n    if ((Math.abs(root - ta) <= convergence) && (Math.abs(root - previousEventTime) <= convergence)) {\n      ta=tb;\n      ga=gb;\n    }\n else     if (Double.isNaN(previousEventTime) || (Math.abs(previousEventTime - root) > convergence)) {\n      pendingEventTime=root;\n      if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n        return false;\n      }\n      pendingEvent=true;\n      return true;\n    }\n  }\n else {\n    ta=tb;\n    ga=gb;\n  }\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 214, 
          "faulty": "final UnivariateRealFunction f=new UnivariateRealFunction(){\n  public double value(  final double t) throws FunctionEvaluationException {\n    try {\n      interpolator.setInterpolatedTime(t);\n      return handler.g(t,interpolator.getInterpolatedState());\n    }\n catch (    DerivativeException e) {\n      throw new FunctionEvaluationException(e,t);\n    }\ncatch (    EventException e) {\n      throw new FunctionEvaluationException(e,t);\n    }\n  }\n}\n;", 
          "type": "InsertBefore", 
          "seed": "if (g0Positive ^ (gb >= 0)) {\n  if (ga * gb > 0) {\n    final double epsilon=(forward ? 0.25 : -0.25) * convergence;\n    for (int k=0; (k < 4) && (ga * gb > 0); ++k) {\n      ta+=epsilon;\n      interpolator.setInterpolatedTime(ta);\n      ga=handler.g(ta,interpolator.getInterpolatedState());\n    }\n    if (ga * gb > 0) {\n      throw MathRuntimeException.createInternalError(null);\n    }\n  }\n  increasing=gb >= ga;\n  final UnivariateRealFunction f=new UnivariateRealFunction(){\n    public double value(    final double t) throws FunctionEvaluationException {\n      try {\n        interpolator.setInterpolatedTime(t);\n        return handler.g(t,interpolator.getInterpolatedState());\n      }\n catch (      DerivativeException e) {\n        throw new FunctionEvaluationException(e,t);\n      }\ncatch (      EventException e) {\n        throw new FunctionEvaluationException(e,t);\n      }\n    }\n  }\n;\n  final BrentSolver solver=new BrentSolver();\n  solver.setAbsoluteAccuracy(convergence);\n  solver.setMaximalIterationCount(maxIterationCount);\n  final double root=(ta <= tb) ? solver.solve(f,ta,tb) : solver.solve(f,tb,ta);\n  if ((Math.abs(root - ta) <= convergence) && (Math.abs(root - previousEventTime) <= convergence)) {\n    ta=tb;\n    ga=gb;\n  }\n else   if (Double.isNaN(previousEventTime) || (Math.abs(previousEventTime - root) > convergence)) {\n    pendingEventTime=root;\n    if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n      return false;\n    }\n    pendingEvent=true;\n    return true;\n  }\n}\n else {\n  ta=tb;\n  ga=gb;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\t2018-12-01 06:00:05.075483730 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_362/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\t2018-12-01 06:32:18.265584562 -0500\n@@ -120,7 +120,10 @@\n       rki.reinitialize(this, yTmp, yDotK, forward);\n       interpolator = rki;\n     } else {\n-      interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);\n+      for (StepHandler handler : stepHandlers) {\n+\t\t\thandler.reset();\n+\t\t}\n+\tinterpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);\n     }\n     interpolator.storeTime(t0);\n \n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_362/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:32:18.269584582 -0500\n@@ -208,7 +208,11 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\t2018-12-01 06:00:01.507483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_362/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\t2018-12-01 06:32:18.269584582 -0500\n@@ -150,7 +150,7 @@\n     if ((initialStepSize < minStep) || (initialStepSize > maxStep)) {\n       initialStep = -1.0;\n     } else {\n-      initialStep = initialStepSize;\n+      resetEvaluations();\n     }\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java", 
          "line": 153, 
          "faulty": "initialStep=initialStepSize;", 
          "type": "Replace", 
          "seed": "resetEvaluations();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java", 
          "line": 123, 
          "faulty": "interpolator=new DummyStepInterpolator(yTmp,yDotK[stages - 1],forward);", 
          "type": "InsertBefore", 
          "seed": "for (StepHandler handler : stepHandlers) {\n  handler.reset();\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_151/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:15:12.212653329 -0500\n@@ -208,7 +208,11 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_151/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java\t2018-12-01 06:15:12.212653329 -0500\n@@ -125,7 +125,8 @@\n                 return true;\n             }\n         }\n-        return false;\n+        stepSize = Double.NaN;\n+\t\treturn false;\n     }\n \n     /** {@inheritDoc} */\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java", 
          "line": 128, 
          "faulty": "return false;", 
          "type": "InsertBefore", 
          "seed": "stepSize=Double.NaN;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_217/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:20:31.266179579 -0500\n@@ -208,7 +208,11 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\t2018-12-01 06:00:01.507483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_217/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\t2018-12-01 06:20:31.270179598 -0500\n@@ -148,6 +148,11 @@\n    */\n   public void setInitialStepSize(final double initialStepSize) {\n     if ((initialStepSize < minStep) || (initialStepSize > maxStep)) {\n+\t\tinitialStep = -1.0;\n+\t} else {\n+\t\tinitialStep = initialStepSize;\n+\t}\n+\tif ((initialStepSize < minStep) || (initialStepSize > maxStep)) {\n       initialStep = -1.0;\n     } else {\n       initialStep = initialStepSize;\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java", 
          "line": 150, 
          "faulty": "if ((initialStepSize < minStep) || (initialStepSize > maxStep)) {\n  initialStep=-1.0;\n}\n else {\n  initialStep=initialStepSize;\n}", 
          "type": "InsertBefore", 
          "seed": "if ((initialStepSize < minStep) || (initialStepSize > maxStep)) {\n  initialStep=-1.0;\n}\n else {\n  initialStep=initialStepSize;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }
      ]
    }, 
    {
      "diff": "\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_1246/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 07:44:47.734756625 -0500\n@@ -208,7 +208,8 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    pendingEvent = true;\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/CombinedEventsManager.java", 
          "line": 187, 
          "faulty": "return (first == null) ? Double.NaN : first.getEventTime();", 
          "type": "Replace", 
          "seed": "return (first == null) ? Double.NaN : first.getEventTime();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "pendingEvent=true;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_837/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 07:11:06.236923083 -0500\n@@ -208,7 +208,11 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_837/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java\t2018-12-01 07:11:06.236923083 -0500\n@@ -125,7 +125,8 @@\n                 return true;\n             }\n         }\n-        return false;\n+        setMaxEvaluations(-1);\n+\t\treturn false;\n     }\n \n     /** {@inheritDoc} */\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java", 
          "line": 128, 
          "faulty": "return false;", 
          "type": "InsertBefore", 
          "seed": "setMaxEvaluations(-1);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_880/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 07:14:38.133938401 -0500\n@@ -208,10 +208,68 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n-                    final UnivariateRealFunction f = new UnivariateRealFunction() {\n+                    if (g0Positive ^ (gb >= 0)) {\n+\t\t\t\t\t\tif (ga * gb > 0) {\n+\t\t\t\t\t\t\tfinal double epsilon = (forward ? 0.25 : -0.25)\n+\t\t\t\t\t\t\t\t\t* convergence;\n+\t\t\t\t\t\t\tfor (int k = 0; (k < 4) && (ga * gb > 0); ++k) {\n+\t\t\t\t\t\t\t\tta += epsilon;\n+\t\t\t\t\t\t\t\tinterpolator.setInterpolatedTime(ta);\n+\t\t\t\t\t\t\t\tga = handler.g(ta,\n+\t\t\t\t\t\t\t\t\t\tinterpolator.getInterpolatedState());\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tif (ga * gb > 0) {\n+\t\t\t\t\t\t\t\tthrow MathRuntimeException\n+\t\t\t\t\t\t\t\t\t\t.createInternalError(null);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tincreasing = gb >= ga;\n+\t\t\t\t\t\tfinal UnivariateRealFunction f = new UnivariateRealFunction() {\n+\t\t\t\t\t\t\tpublic double value(final double t)\n+\t\t\t\t\t\t\t\t\tthrows FunctionEvaluationException {\n+\t\t\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\t\t\tinterpolator.setInterpolatedTime(t);\n+\t\t\t\t\t\t\t\t\treturn handler\n+\t\t\t\t\t\t\t\t\t\t\t.g(t, interpolator\n+\t\t\t\t\t\t\t\t\t\t\t\t\t.getInterpolatedState());\n+\t\t\t\t\t\t\t\t} catch (DerivativeException e) {\n+\t\t\t\t\t\t\t\t\tthrow new FunctionEvaluationException(e, t);\n+\t\t\t\t\t\t\t\t} catch (EventException e) {\n+\t\t\t\t\t\t\t\t\tthrow new FunctionEvaluationException(e, t);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t};\n+\t\t\t\t\t\tfinal BrentSolver solver = new BrentSolver();\n+\t\t\t\t\t\tsolver.setAbsoluteAccuracy(convergence);\n+\t\t\t\t\t\tsolver.setMaximalIterationCount(maxIterationCount);\n+\t\t\t\t\t\tfinal double root = (ta <= tb) ? solver\n+\t\t\t\t\t\t\t\t.solve(f, ta, tb) : solver.solve(f, tb, ta);\n+\t\t\t\t\t\tif ((Math.abs(root - ta) <= convergence)\n+\t\t\t\t\t\t\t\t&& (Math.abs(root - previousEventTime) <= convergence)) {\n+\t\t\t\t\t\t\tta = tb;\n+\t\t\t\t\t\t\tga = gb;\n+\t\t\t\t\t\t} else if (Double.isNaN(previousEventTime)\n+\t\t\t\t\t\t\t\t|| (Math.abs(previousEventTime - root) > convergence)) {\n+\t\t\t\t\t\t\tpendingEventTime = root;\n+\t\t\t\t\t\t\tif (pendingEvent\n+\t\t\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\t\t\treturn false;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tpendingEvent = true;\n+\t\t\t\t\t\t\treturn true;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tta = tb;\n+\t\t\t\t\t\tga = gb;\n+\t\t\t\t\t}\n+\t\t\t\t\tfinal UnivariateRealFunction f = new UnivariateRealFunction() {\n                         public double value(final double t) throws FunctionEvaluationException {\n                             try {\n                                 interpolator.setInterpolatedTime(t);\n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:01.483483648 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_880/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 07:14:38.133938401 -0500\n@@ -332,7 +332,13 @@\n             if (Math.abs(delta) > tolerance) {\n                 x1 = x1 + delta;\n             } else if (dx > 0.0) {\n-                x1 = x1 + 0.5 * tolerance;\n+                if ((y1 > 0) == (y2 > 0)) {\n+\t\t\t\t\tx2 = x0;\n+\t\t\t\t\ty2 = y0;\n+\t\t\t\t\tdelta = x1 - x0;\n+\t\t\t\t\toldDelta = delta;\n+\t\t\t\t}\n+\t\t\t\tx1 = x1 + 0.5 * tolerance;\n             } else if (dx <= 0.0) {\n                 x1 = x1 - 0.5 * tolerance;\n             }\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 335, 
          "faulty": "x1=x1 + 0.5 * tolerance;", 
          "type": "InsertBefore", 
          "seed": "if ((y1 > 0) == (y2 > 0)) {\n  x2=x0;\n  y2=y0;\n  delta=x1 - x0;\n  oldDelta=delta;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 214, 
          "faulty": "final UnivariateRealFunction f=new UnivariateRealFunction(){\n  public double value(  final double t) throws FunctionEvaluationException {\n    try {\n      interpolator.setInterpolatedTime(t);\n      return handler.g(t,interpolator.getInterpolatedState());\n    }\n catch (    DerivativeException e) {\n      throw new FunctionEvaluationException(e,t);\n    }\ncatch (    EventException e) {\n      throw new FunctionEvaluationException(e,t);\n    }\n  }\n}\n;", 
          "type": "InsertBefore", 
          "seed": "if (g0Positive ^ (gb >= 0)) {\n  if (ga * gb > 0) {\n    final double epsilon=(forward ? 0.25 : -0.25) * convergence;\n    for (int k=0; (k < 4) && (ga * gb > 0); ++k) {\n      ta+=epsilon;\n      interpolator.setInterpolatedTime(ta);\n      ga=handler.g(ta,interpolator.getInterpolatedState());\n    }\n    if (ga * gb > 0) {\n      throw MathRuntimeException.createInternalError(null);\n    }\n  }\n  increasing=gb >= ga;\n  final UnivariateRealFunction f=new UnivariateRealFunction(){\n    public double value(    final double t) throws FunctionEvaluationException {\n      try {\n        interpolator.setInterpolatedTime(t);\n        return handler.g(t,interpolator.getInterpolatedState());\n      }\n catch (      DerivativeException e) {\n        throw new FunctionEvaluationException(e,t);\n      }\ncatch (      EventException e) {\n        throw new FunctionEvaluationException(e,t);\n      }\n    }\n  }\n;\n  final BrentSolver solver=new BrentSolver();\n  solver.setAbsoluteAccuracy(convergence);\n  solver.setMaximalIterationCount(maxIterationCount);\n  final double root=(ta <= tb) ? solver.solve(f,ta,tb) : solver.solve(f,tb,ta);\n  if ((Math.abs(root - ta) <= convergence) && (Math.abs(root - previousEventTime) <= convergence)) {\n    ta=tb;\n    ga=gb;\n  }\n else   if (Double.isNaN(previousEventTime) || (Math.abs(previousEventTime - root) > convergence)) {\n    pendingEventTime=root;\n    if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n      return false;\n    }\n    pendingEvent=true;\n    return true;\n  }\n}\n else {\n  ta=tb;\n  ga=gb;\n}"
        }
      ]
    }, 
    {
      "diff": "\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_20/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:03:50.508895158 -0500\n@@ -208,7 +208,11 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/CombinedEventsManager.java", 
          "line": 187, 
          "faulty": "return (first == null) ? Double.NaN : first.getEventTime();", 
          "type": "Replace", 
          "seed": "return (first == null) ? Double.NaN : first.getEventTime();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_1206/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 07:41:22.917737113 -0500\n@@ -208,7 +208,11 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n@@ -232,21 +236,32 @@\n                         // we have either found nothing or found (again ?) a past event, we simply ignore it\n                         ta = tb;\n                         ga = gb;\n-                    } else if (Double.isNaN(previousEventTime) ||\n-                               (Math.abs(previousEventTime - root) > convergence)) {\n-                        pendingEventTime = root;\n-                        if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n-                            // we were already waiting for this event which was\n-                            // found during a previous call for a step that was\n-                            // rejected, this step must now be accepted since it\n-                            // properly ends exactly at the event occurrence\n-                            return false;\n-                        }\n-                        // either we were not waiting for the event or it has\n-                        // moved in such a way the step cannot be accepted\n-                        pendingEvent = true;\n-                        return true;\n-                    }\n+                    } else {\n+\t\t\t\t\t\tif (ga * gb > 0) {\n+\t\t\t\t\t\t\tfinal double epsilon = (forward ? 0.25 : -0.25)\n+\t\t\t\t\t\t\t\t\t* convergence;\n+\t\t\t\t\t\t\tfor (int k = 0; (k < 4) && (ga * gb > 0); ++k) {\n+\t\t\t\t\t\t\t\tta += epsilon;\n+\t\t\t\t\t\t\t\tinterpolator.setInterpolatedTime(ta);\n+\t\t\t\t\t\t\t\tga = handler.g(ta,\n+\t\t\t\t\t\t\t\t\t\tinterpolator.getInterpolatedState());\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tif (ga * gb > 0) {\n+\t\t\t\t\t\t\t\tthrow MathRuntimeException\n+\t\t\t\t\t\t\t\t\t\t.createInternalError(null);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tif (Double.isNaN(previousEventTime)\n+\t\t\t\t\t\t\t\t|| (Math.abs(previousEventTime - root) > convergence)) {\n+\t\t\t\t\t\t\tpendingEventTime = root;\n+\t\t\t\t\t\t\tif (pendingEvent\n+\t\t\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\t\t\treturn false;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tpendingEvent = true;\n+\t\t\t\t\t\t\treturn true;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n \n                 } else {\n                     // no sign change: there is no event for now\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 248, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "g0Positive=increasing;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 235, 
          "faulty": "if (Double.isNaN(previousEventTime) || (Math.abs(previousEventTime - root) > convergence)) {\n  pendingEventTime=root;\n  if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n    return false;\n  }\n  pendingEvent=true;\n  return true;\n}", 
          "type": "InsertBefore", 
          "seed": "if (ga * gb > 0) {\n  final double epsilon=(forward ? 0.25 : -0.25) * convergence;\n  for (int k=0; (k < 4) && (ga * gb > 0); ++k) {\n    ta+=epsilon;\n    interpolator.setInterpolatedTime(ta);\n    ga=handler.g(ta,interpolator.getInterpolatedState());\n  }\n  if (ga * gb > 0) {\n    throw MathRuntimeException.createInternalError(null);\n  }\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_965/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 07:21:28.643931716 -0500\n@@ -208,7 +208,11 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n@@ -335,7 +339,8 @@\n             handler.resetState(t, y);\n         }\n         pendingEvent      = false;\n-        pendingEventTime  = Double.NaN;\n+        g0Positive = increasing;\n+\t\tpendingEventTime  = Double.NaN;\n \n         return (nextAction == EventHandler.RESET_STATE) ||\n                (nextAction == EventHandler.RESET_DERIVATIVES);\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 338, 
          "faulty": "pendingEventTime=Double.NaN;", 
          "type": "InsertBefore", 
          "seed": "g0Positive=increasing;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/CombinedEventsManager.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_568/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/CombinedEventsManager.java\t2018-12-01 06:49:12.686571450 -0500\n@@ -150,7 +150,8 @@\n             for (EventState state : states) {\n \n                 if (state.evaluateStep(interpolator)) {\n-                    if (first == null) {\n+                    initialized = true;\n+\t\t\t\t\tif (first == null) {\n                         first = state;\n                     } else {\n                         if (interpolator.isForward()) {\n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_568/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:49:12.690571470 -0500\n@@ -208,7 +208,11 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/CombinedEventsManager.java", 
          "line": 153, 
          "faulty": "if (first == null) {\n  first=state;\n}\n else {\n  if (interpolator.isForward()) {\n    if (state.getEventTime() < first.getEventTime()) {\n      first=state;\n    }\n  }\n else {\n    if (state.getEventTime() > first.getEventTime()) {\n      first=state;\n    }\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "initialized=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_974/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 07:22:13.032148406 -0500\n@@ -208,7 +208,8 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    pendingEvent = true;\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n@@ -334,7 +335,7 @@\n         if (nextAction == EventHandler.RESET_STATE) {\n             handler.resetState(t, y);\n         }\n-        pendingEvent      = false;\n+        pendingEventTime = Double.NaN;\n         pendingEventTime  = Double.NaN;\n \n         return (nextAction == EventHandler.RESET_STATE) ||\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 337, 
          "faulty": "pendingEvent=false;", 
          "type": "Replace", 
          "seed": "pendingEventTime=Double.NaN;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "pendingEvent=true;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/CombinedEventsManager.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_812/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/CombinedEventsManager.java\t2018-12-01 07:09:06.432347622 -0500\n@@ -151,7 +151,23 @@\n \n                 if (state.evaluateStep(interpolator)) {\n                     if (first == null) {\n-                        first = state;\n+                        if (state.evaluateStep(interpolator)) {\n+\t\t\t\t\t\t\tif (first == null) {\n+\t\t\t\t\t\t\t\tfirst = state;\n+\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\tif (interpolator.isForward()) {\n+\t\t\t\t\t\t\t\t\tif (state.getEventTime() < first\n+\t\t\t\t\t\t\t\t\t\t\t.getEventTime()) {\n+\t\t\t\t\t\t\t\t\t\tfirst = state;\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\tif (state.getEventTime() > first\n+\t\t\t\t\t\t\t\t\t\t\t.getEventTime()) {\n+\t\t\t\t\t\t\t\t\t\tfirst = state;\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n                     } else {\n                         if (interpolator.isForward()) {\n                             if (state.getEventTime() < first.getEventTime()) {\n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_812/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 07:09:06.432347622 -0500\n@@ -227,7 +227,8 @@\n                     solver.setAbsoluteAccuracy(convergence);\n                     solver.setMaximalIterationCount(maxIterationCount);\n                     final double root = (ta <= tb) ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta);\n-                    if ((Math.abs(root - ta) <= convergence) &&\n+                    pendingEventTime = Double.NaN;\n+\t\t\t\t\tif ((Math.abs(root - ta) <= convergence) &&\n                          (Math.abs(root - previousEventTime) <= convergence)) {\n                         // we have either found nothing or found (again ?) a past event, we simply ignore it\n                         ta = tb;\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 230, 
          "faulty": "if ((Math.abs(root - ta) <= convergence) && (Math.abs(root - previousEventTime) <= convergence)) {\n  ta=tb;\n  ga=gb;\n}\n else if (Double.isNaN(previousEventTime) || (Math.abs(previousEventTime - root) > convergence)) {\n  pendingEventTime=root;\n  if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n    return false;\n  }\n  pendingEvent=true;\n  return true;\n}", 
          "type": "InsertBefore", 
          "seed": "pendingEventTime=Double.NaN;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/CombinedEventsManager.java", 
          "line": 154, 
          "faulty": "first=state;", 
          "type": "Replace", 
          "seed": "if (state.evaluateStep(interpolator)) {\n  if (first == null) {\n    first=state;\n  }\n else {\n    if (interpolator.isForward()) {\n      if (state.getEventTime() < first.getEventTime()) {\n        first=state;\n      }\n    }\n else {\n      if (state.getEventTime() > first.getEventTime()) {\n        first=state;\n      }\n    }\n  }\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_1060/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 07:29:05.866154688 -0500\n@@ -208,10 +208,65 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    pendingEvent = true;\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n-                    final UnivariateRealFunction f = new UnivariateRealFunction() {\n+                    if (g0Positive ^ (gb >= 0)) {\n+\t\t\t\t\t\tif (ga * gb > 0) {\n+\t\t\t\t\t\t\tfinal double epsilon = (forward ? 0.25 : -0.25)\n+\t\t\t\t\t\t\t\t\t* convergence;\n+\t\t\t\t\t\t\tfor (int k = 0; (k < 4) && (ga * gb > 0); ++k) {\n+\t\t\t\t\t\t\t\tta += epsilon;\n+\t\t\t\t\t\t\t\tinterpolator.setInterpolatedTime(ta);\n+\t\t\t\t\t\t\t\tga = handler.g(ta,\n+\t\t\t\t\t\t\t\t\t\tinterpolator.getInterpolatedState());\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tif (ga * gb > 0) {\n+\t\t\t\t\t\t\t\tthrow MathRuntimeException\n+\t\t\t\t\t\t\t\t\t\t.createInternalError(null);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tincreasing = gb >= ga;\n+\t\t\t\t\t\tfinal UnivariateRealFunction f = new UnivariateRealFunction() {\n+\t\t\t\t\t\t\tpublic double value(final double t)\n+\t\t\t\t\t\t\t\t\tthrows FunctionEvaluationException {\n+\t\t\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\t\t\tinterpolator.setInterpolatedTime(t);\n+\t\t\t\t\t\t\t\t\treturn handler\n+\t\t\t\t\t\t\t\t\t\t\t.g(t, interpolator\n+\t\t\t\t\t\t\t\t\t\t\t\t\t.getInterpolatedState());\n+\t\t\t\t\t\t\t\t} catch (DerivativeException e) {\n+\t\t\t\t\t\t\t\t\tthrow new FunctionEvaluationException(e, t);\n+\t\t\t\t\t\t\t\t} catch (EventException e) {\n+\t\t\t\t\t\t\t\t\tthrow new FunctionEvaluationException(e, t);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t};\n+\t\t\t\t\t\tfinal BrentSolver solver = new BrentSolver();\n+\t\t\t\t\t\tsolver.setAbsoluteAccuracy(convergence);\n+\t\t\t\t\t\tsolver.setMaximalIterationCount(maxIterationCount);\n+\t\t\t\t\t\tfinal double root = (ta <= tb) ? solver\n+\t\t\t\t\t\t\t\t.solve(f, ta, tb) : solver.solve(f, tb, ta);\n+\t\t\t\t\t\tif ((Math.abs(root - ta) <= convergence)\n+\t\t\t\t\t\t\t\t&& (Math.abs(root - previousEventTime) <= convergence)) {\n+\t\t\t\t\t\t\tta = tb;\n+\t\t\t\t\t\t\tga = gb;\n+\t\t\t\t\t\t} else if (Double.isNaN(previousEventTime)\n+\t\t\t\t\t\t\t\t|| (Math.abs(previousEventTime - root) > convergence)) {\n+\t\t\t\t\t\t\tpendingEventTime = root;\n+\t\t\t\t\t\t\tif (pendingEvent\n+\t\t\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\t\t\treturn false;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tpendingEvent = true;\n+\t\t\t\t\t\t\treturn true;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tta = tb;\n+\t\t\t\t\t\tga = gb;\n+\t\t\t\t\t}\n+\t\t\t\t\tfinal UnivariateRealFunction f = new UnivariateRealFunction() {\n                         public double value(final double t) throws FunctionEvaluationException {\n                             try {\n                                 interpolator.setInterpolatedTime(t);\n@@ -245,7 +300,7 @@\n                         // either we were not waiting for the event or it has\n                         // moved in such a way the step cannot be accepted\n                         pendingEvent = true;\n-                        return true;\n+                        g0Positive = increasing;\n                     }\n \n                 } else {\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 248, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "g0Positive=increasing;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "pendingEvent=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 214, 
          "faulty": "final UnivariateRealFunction f=new UnivariateRealFunction(){\n  public double value(  final double t) throws FunctionEvaluationException {\n    try {\n      interpolator.setInterpolatedTime(t);\n      return handler.g(t,interpolator.getInterpolatedState());\n    }\n catch (    DerivativeException e) {\n      throw new FunctionEvaluationException(e,t);\n    }\ncatch (    EventException e) {\n      throw new FunctionEvaluationException(e,t);\n    }\n  }\n}\n;", 
          "type": "InsertBefore", 
          "seed": "if (g0Positive ^ (gb >= 0)) {\n  if (ga * gb > 0) {\n    final double epsilon=(forward ? 0.25 : -0.25) * convergence;\n    for (int k=0; (k < 4) && (ga * gb > 0); ++k) {\n      ta+=epsilon;\n      interpolator.setInterpolatedTime(ta);\n      ga=handler.g(ta,interpolator.getInterpolatedState());\n    }\n    if (ga * gb > 0) {\n      throw MathRuntimeException.createInternalError(null);\n    }\n  }\n  increasing=gb >= ga;\n  final UnivariateRealFunction f=new UnivariateRealFunction(){\n    public double value(    final double t) throws FunctionEvaluationException {\n      try {\n        interpolator.setInterpolatedTime(t);\n        return handler.g(t,interpolator.getInterpolatedState());\n      }\n catch (      DerivativeException e) {\n        throw new FunctionEvaluationException(e,t);\n      }\ncatch (      EventException e) {\n        throw new FunctionEvaluationException(e,t);\n      }\n    }\n  }\n;\n  final BrentSolver solver=new BrentSolver();\n  solver.setAbsoluteAccuracy(convergence);\n  solver.setMaximalIterationCount(maxIterationCount);\n  final double root=(ta <= tb) ? solver.solve(f,ta,tb) : solver.solve(f,tb,ta);\n  if ((Math.abs(root - ta) <= convergence) && (Math.abs(root - previousEventTime) <= convergence)) {\n    ta=tb;\n    ga=gb;\n  }\n else   if (Double.isNaN(previousEventTime) || (Math.abs(previousEventTime - root) > convergence)) {\n    pendingEventTime=root;\n    if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n      return false;\n    }\n    pendingEvent=true;\n    return true;\n  }\n}\n else {\n  ta=tb;\n  ga=gb;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_270/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:24:34.279336092 -0500\n@@ -208,7 +208,11 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/sampling/DummyStepInterpolator.java\t2018-12-01 06:00:01.511483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_270/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/sampling/DummyStepInterpolator.java\t2018-12-01 06:24:34.283336111 -0500\n@@ -104,7 +104,9 @@\n   @Override\n   protected void computeInterpolatedStateAndDerivatives(final double theta, final double oneMinusThetaH)\n     throws DerivativeException {\n-      System.arraycopy(currentState,      0, interpolatedState,       0, currentState.length);\n+      System.arraycopy(currentDerivative, 0, interpolatedDerivatives, 0,\n+\t\t\t\tcurrentDerivative.length);\n+\tSystem.arraycopy(currentState,      0, interpolatedState,       0, currentState.length);\n       System.arraycopy(currentDerivative, 0, interpolatedDerivatives, 0, currentDerivative.length);\n   }\n \n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\t2018-12-01 06:00:01.507483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_270/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\t2018-12-01 06:24:34.283336111 -0500\n@@ -147,7 +147,8 @@\n    * ignore the value and compute the initial step size by itself)\n    */\n   public void setInitialStepSize(final double initialStepSize) {\n-    if ((initialStepSize < minStep) || (initialStepSize > maxStep)) {\n+    initialStep = initialStepSize;\n+\tif ((initialStepSize < minStep) || (initialStepSize > maxStep)) {\n       initialStep = -1.0;\n     } else {\n       initialStep = initialStepSize;\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java", 
          "line": 150, 
          "faulty": "if ((initialStepSize < minStep) || (initialStepSize > maxStep)) {\n  initialStep=-1.0;\n}\n else {\n  initialStep=initialStepSize;\n}", 
          "type": "InsertBefore", 
          "seed": "initialStep=initialStepSize;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/sampling/DummyStepInterpolator.java", 
          "line": 107, 
          "faulty": "System.arraycopy(currentState,0,interpolatedState,0,currentState.length);", 
          "type": "InsertBefore", 
          "seed": "System.arraycopy(currentDerivative,0,interpolatedDerivatives,0,currentDerivative.length);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_1187/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 07:39:41.689230167 -0500\n@@ -208,7 +208,11 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\t2018-12-01 06:00:05.075483730 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_1187/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\t2018-12-01 07:39:41.693230187 -0500\n@@ -292,12 +292,7 @@\n           if (manager.evaluateStep(interpolator)) {\n               final double dt = manager.getEventTime() - stepStart;\n               if (Math.abs(dt) <= Math.ulp(stepStart)) {\n-                  // we cannot simply truncate the step, reject the current computation\n-                  // and let the loop compute another state with the truncated step.\n-                  // it is so small (much probably exactly 0 due to limited accuracy)\n-                  // that the code above would fail handling it.\n-                  // So we set up an artificial 0 size step by copying states\n-                  loop     = false;\n+                  super.sanityChecks(equations, t0, y0, t, y);\n               } else {\n                   // reject the step to match exactly the next switch time\n                   hNew = dt;\n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\t2018-12-01 06:00:01.507483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_1187/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\t2018-12-01 07:39:41.693230187 -0500\n@@ -289,7 +289,8 @@\n       }\n \n       if (filteredH > maxStep) {\n-          filteredH = maxStep;\n+          stepSize = filterStep(stepSize, forward, true);\n+\t\tfilteredH = maxStep;\n       } else if (filteredH < -maxStep) {\n           filteredH = -maxStep;\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java", 
          "line": 300, 
          "faulty": "loop=false;", 
          "type": "Replace", 
          "seed": "super.sanityChecks(equations,t0,y0,t,y);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java", 
          "line": 292, 
          "faulty": "filteredH=maxStep;", 
          "type": "InsertBefore", 
          "seed": "stepSize=filterStep(stepSize,forward,true);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_626/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:53:46.051903649 -0500\n@@ -208,7 +208,11 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:01.483483648 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_626/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:53:46.051903649 -0500\n@@ -332,7 +332,13 @@\n             if (Math.abs(delta) > tolerance) {\n                 x1 = x1 + delta;\n             } else if (dx > 0.0) {\n-                x1 = x1 + 0.5 * tolerance;\n+                if ((y1 > 0) == (y2 > 0)) {\n+\t\t\t\t\tx2 = x0;\n+\t\t\t\t\ty2 = y0;\n+\t\t\t\t\tdelta = x1 - x0;\n+\t\t\t\t\toldDelta = delta;\n+\t\t\t\t}\n+\t\t\t\tx1 = x1 + 0.5 * tolerance;\n             } else if (dx <= 0.0) {\n                 x1 = x1 - 0.5 * tolerance;\n             }\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 335, 
          "faulty": "x1=x1 + 0.5 * tolerance;", 
          "type": "InsertBefore", 
          "seed": "if ((y1 > 0) == (y2 > 0)) {\n  x2=x0;\n  y2=y0;\n  delta=x1 - x0;\n  oldDelta=delta;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\t2018-12-01 06:00:05.075483730 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_473/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\t2018-12-01 06:41:37.972326668 -0500\n@@ -172,7 +172,18 @@\n         if (manager.evaluateStep(interpolator)) {\n             final double dt = manager.getEventTime() - stepStart;\n             if (Math.abs(dt) <= Math.ulp(stepStart)) {\n-                // we cannot simply truncate the step, reject the current computation\n+                for (int k = 1; k < stages; ++k) {\n+\t\t\t\t\tfor (int j = 0; j < y0.length; ++j) {\n+\t\t\t\t\t\tdouble sum = a[k - 1][0] * yDotK[0][j];\n+\t\t\t\t\t\tfor (int l = 1; l < k; ++l) {\n+\t\t\t\t\t\t\tsum += a[k - 1][l] * yDotK[l][j];\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tyTmp[j] = y[j] + stepSize * sum;\n+\t\t\t\t\t}\n+\t\t\t\t\tcomputeDerivatives(stepStart + c[k - 1] * stepSize, yTmp,\n+\t\t\t\t\t\t\tyDotK[k]);\n+\t\t\t\t}\n+\t\t\t\t// we cannot simply truncate the step, reject the current computation\n                 // and let the loop compute another state with the truncated step.\n                 // it is so small (much probably exactly 0 due to limited accuracy)\n                 // that the code above would fail handling it.\n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_473/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:41:37.976326688 -0500\n@@ -208,7 +208,11 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n@@ -331,9 +335,7 @@\n             return false;\n         }\n \n-        if (nextAction == EventHandler.RESET_STATE) {\n-            handler.resetState(t, y);\n-        }\n+        handler.resetState(t, y);\n         pendingEvent      = false;\n         pendingEventTime  = Double.NaN;\n \n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java", 
          "line": 180, 
          "faulty": "loop=false;", 
          "type": "InsertBefore", 
          "seed": "for (int k=1; k < stages; ++k) {\n  for (int j=0; j < y0.length; ++j) {\n    double sum=a[k - 1][0] * yDotK[0][j];\n    for (int l=1; l < k; ++l) {\n      sum+=a[k - 1][l] * yDotK[l][j];\n    }\n    yTmp[j]=y[j] + stepSize * sum;\n  }\n  computeDerivatives(stepStart + c[k - 1] * stepSize,yTmp,yDotK[k]);\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 334, 
          "faulty": "if (nextAction == EventHandler.RESET_STATE) {\n  handler.resetState(t,y);\n}", 
          "type": "Replace", 
          "seed": "handler.resetState(t,y);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_635/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:54:23.656085488 -0500\n@@ -208,7 +208,11 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\t2018-12-01 06:00:01.507483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_635/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\t2018-12-01 06:54:23.656085488 -0500\n@@ -150,7 +150,7 @@\n     if ((initialStepSize < minStep) || (initialStepSize > maxStep)) {\n       initialStep = -1.0;\n     } else {\n-      initialStep = initialStepSize;\n+      return;\n     }\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java", 
          "line": 153, 
          "faulty": "initialStep=initialStepSize;", 
          "type": "Replace", 
          "seed": "return;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_690/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:58:44.265340222 -0500\n@@ -188,7 +188,11 @@\n                 if (g0Positive ^ (gb >= 0)) {\n                     // there is a sign change: an event is expected during this step\n \n-                    if (ga * gb > 0) {\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (ga * gb > 0) {\n                         // this is a corner case:\n                         // - there was an event near ta,\n                         // - there is another event between ta and tb\n@@ -208,7 +212,8 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    pendingEvent = true;\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n@@ -235,7 +240,8 @@\n                     } else if (Double.isNaN(previousEventTime) ||\n                                (Math.abs(previousEventTime - root) > convergence)) {\n                         pendingEventTime = root;\n-                        if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+                        interpolator.setInterpolatedTime(ta);\n+\t\t\t\t\t\tif (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n                             // we were already waiting for this event which was\n                             // found during a previous call for a step that was\n                             // rejected, this step must now be accepted since it\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 191, 
          "faulty": "if (ga * gb > 0) {\n  final double epsilon=(forward ? 0.25 : -0.25) * convergence;\n  for (int k=0; (k < 4) && (ga * gb > 0); ++k) {\n    ta+=epsilon;\n    interpolator.setInterpolatedTime(ta);\n    ga=handler.g(ta,interpolator.getInterpolatedState());\n  }\n  if (ga * gb > 0) {\n    throw MathRuntimeException.createInternalError(null);\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "pendingEvent=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 238, 
          "faulty": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}", 
          "type": "InsertBefore", 
          "seed": "interpolator.setInterpolatedTime(ta);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_891/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 07:15:32.202197077 -0500\n@@ -225,7 +225,11 @@\n                     };\n                     final BrentSolver solver = new BrentSolver();\n                     solver.setAbsoluteAccuracy(convergence);\n-                    solver.setMaximalIterationCount(maxIterationCount);\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\tsolver.setMaximalIterationCount(maxIterationCount);\n                     final double root = (ta <= tb) ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta);\n                     if ((Math.abs(root - ta) <= convergence) &&\n                          (Math.abs(root - previousEventTime) <= convergence)) {\n@@ -235,7 +239,8 @@\n                     } else if (Double.isNaN(previousEventTime) ||\n                                (Math.abs(previousEventTime - root) > convergence)) {\n                         pendingEventTime = root;\n-                        if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+                        interpolator.setInterpolatedTime(ta);\n+\t\t\t\t\t\tif (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n                             // we were already waiting for this event which was\n                             // found during a previous call for a step that was\n                             // rejected, this step must now be accepted since it\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 228, 
          "faulty": "solver.setMaximalIterationCount(maxIterationCount);", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 238, 
          "faulty": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}", 
          "type": "InsertBefore", 
          "seed": "interpolator.setInterpolatedTime(ta);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_222/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:20:53.826286223 -0500\n@@ -208,10 +208,68 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n-                    final UnivariateRealFunction f = new UnivariateRealFunction() {\n+                    if (g0Positive ^ (gb >= 0)) {\n+\t\t\t\t\t\tif (ga * gb > 0) {\n+\t\t\t\t\t\t\tfinal double epsilon = (forward ? 0.25 : -0.25)\n+\t\t\t\t\t\t\t\t\t* convergence;\n+\t\t\t\t\t\t\tfor (int k = 0; (k < 4) && (ga * gb > 0); ++k) {\n+\t\t\t\t\t\t\t\tta += epsilon;\n+\t\t\t\t\t\t\t\tinterpolator.setInterpolatedTime(ta);\n+\t\t\t\t\t\t\t\tga = handler.g(ta,\n+\t\t\t\t\t\t\t\t\t\tinterpolator.getInterpolatedState());\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tif (ga * gb > 0) {\n+\t\t\t\t\t\t\t\tthrow MathRuntimeException\n+\t\t\t\t\t\t\t\t\t\t.createInternalError(null);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tincreasing = gb >= ga;\n+\t\t\t\t\t\tfinal UnivariateRealFunction f = new UnivariateRealFunction() {\n+\t\t\t\t\t\t\tpublic double value(final double t)\n+\t\t\t\t\t\t\t\t\tthrows FunctionEvaluationException {\n+\t\t\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\t\t\tinterpolator.setInterpolatedTime(t);\n+\t\t\t\t\t\t\t\t\treturn handler\n+\t\t\t\t\t\t\t\t\t\t\t.g(t, interpolator\n+\t\t\t\t\t\t\t\t\t\t\t\t\t.getInterpolatedState());\n+\t\t\t\t\t\t\t\t} catch (DerivativeException e) {\n+\t\t\t\t\t\t\t\t\tthrow new FunctionEvaluationException(e, t);\n+\t\t\t\t\t\t\t\t} catch (EventException e) {\n+\t\t\t\t\t\t\t\t\tthrow new FunctionEvaluationException(e, t);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t};\n+\t\t\t\t\t\tfinal BrentSolver solver = new BrentSolver();\n+\t\t\t\t\t\tsolver.setAbsoluteAccuracy(convergence);\n+\t\t\t\t\t\tsolver.setMaximalIterationCount(maxIterationCount);\n+\t\t\t\t\t\tfinal double root = (ta <= tb) ? solver\n+\t\t\t\t\t\t\t\t.solve(f, ta, tb) : solver.solve(f, tb, ta);\n+\t\t\t\t\t\tif ((Math.abs(root - ta) <= convergence)\n+\t\t\t\t\t\t\t\t&& (Math.abs(root - previousEventTime) <= convergence)) {\n+\t\t\t\t\t\t\tta = tb;\n+\t\t\t\t\t\t\tga = gb;\n+\t\t\t\t\t\t} else if (Double.isNaN(previousEventTime)\n+\t\t\t\t\t\t\t\t|| (Math.abs(previousEventTime - root) > convergence)) {\n+\t\t\t\t\t\t\tpendingEventTime = root;\n+\t\t\t\t\t\t\tif (pendingEvent\n+\t\t\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\t\t\treturn false;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tpendingEvent = true;\n+\t\t\t\t\t\t\treturn true;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tta = tb;\n+\t\t\t\t\t\tga = gb;\n+\t\t\t\t\t}\n+\t\t\t\t\tfinal UnivariateRealFunction f = new UnivariateRealFunction() {\n                         public double value(final double t) throws FunctionEvaluationException {\n                             try {\n                                 interpolator.setInterpolatedTime(t);\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 214, 
          "faulty": "final UnivariateRealFunction f=new UnivariateRealFunction(){\n  public double value(  final double t) throws FunctionEvaluationException {\n    try {\n      interpolator.setInterpolatedTime(t);\n      return handler.g(t,interpolator.getInterpolatedState());\n    }\n catch (    DerivativeException e) {\n      throw new FunctionEvaluationException(e,t);\n    }\ncatch (    EventException e) {\n      throw new FunctionEvaluationException(e,t);\n    }\n  }\n}\n;", 
          "type": "InsertBefore", 
          "seed": "if (g0Positive ^ (gb >= 0)) {\n  if (ga * gb > 0) {\n    final double epsilon=(forward ? 0.25 : -0.25) * convergence;\n    for (int k=0; (k < 4) && (ga * gb > 0); ++k) {\n      ta+=epsilon;\n      interpolator.setInterpolatedTime(ta);\n      ga=handler.g(ta,interpolator.getInterpolatedState());\n    }\n    if (ga * gb > 0) {\n      throw MathRuntimeException.createInternalError(null);\n    }\n  }\n  increasing=gb >= ga;\n  final UnivariateRealFunction f=new UnivariateRealFunction(){\n    public double value(    final double t) throws FunctionEvaluationException {\n      try {\n        interpolator.setInterpolatedTime(t);\n        return handler.g(t,interpolator.getInterpolatedState());\n      }\n catch (      DerivativeException e) {\n        throw new FunctionEvaluationException(e,t);\n      }\ncatch (      EventException e) {\n        throw new FunctionEvaluationException(e,t);\n      }\n    }\n  }\n;\n  final BrentSolver solver=new BrentSolver();\n  solver.setAbsoluteAccuracy(convergence);\n  solver.setMaximalIterationCount(maxIterationCount);\n  final double root=(ta <= tb) ? solver.solve(f,ta,tb) : solver.solve(f,tb,ta);\n  if ((Math.abs(root - ta) <= convergence) && (Math.abs(root - previousEventTime) <= convergence)) {\n    ta=tb;\n    ga=gb;\n  }\n else   if (Double.isNaN(previousEventTime) || (Math.abs(previousEventTime - root) > convergence)) {\n    pendingEventTime=root;\n    if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n      return false;\n    }\n    pendingEvent=true;\n    return true;\n  }\n}\n else {\n  ta=tb;\n  ga=gb;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_819/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 07:09:38.480501680 -0500\n@@ -208,7 +208,11 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/sampling/DummyStepInterpolator.java\t2018-12-01 06:00:01.511483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_819/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/sampling/DummyStepInterpolator.java\t2018-12-01 07:09:38.484501699 -0500\n@@ -105,7 +105,8 @@\n   protected void computeInterpolatedStateAndDerivatives(final double theta, final double oneMinusThetaH)\n     throws DerivativeException {\n       System.arraycopy(currentState,      0, interpolatedState,       0, currentState.length);\n-      System.arraycopy(currentDerivative, 0, interpolatedDerivatives, 0, currentDerivative.length);\n+      interpolatedTime = Double.NaN;\n+\tSystem.arraycopy(currentDerivative, 0, interpolatedDerivatives, 0, currentDerivative.length);\n   }\n \n   /** Write the instance to an output channel.\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/sampling/DummyStepInterpolator.java", 
          "line": 108, 
          "faulty": "System.arraycopy(currentDerivative,0,interpolatedDerivatives,0,currentDerivative.length);", 
          "type": "InsertBefore", 
          "seed": "interpolatedTime=Double.NaN;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_564/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:48:55.982488651 -0500\n@@ -208,7 +208,11 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_564/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java\t2018-12-01 06:48:55.982488651 -0500\n@@ -125,7 +125,8 @@\n                 return true;\n             }\n         }\n-        return false;\n+        this.equations = equations;\n+\t\treturn false;\n     }\n \n     /** {@inheritDoc} */\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java", 
          "line": 128, 
          "faulty": "return false;", 
          "type": "InsertBefore", 
          "seed": "this.equations=equations;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_1382/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 07:56:23.826242114 -0500\n@@ -208,7 +208,11 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/sampling/DummyStepInterpolator.java\t2018-12-01 06:00:01.511483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_1382/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/sampling/DummyStepInterpolator.java\t2018-12-01 07:56:23.826242114 -0500\n@@ -105,7 +105,8 @@\n   protected void computeInterpolatedStateAndDerivatives(final double theta, final double oneMinusThetaH)\n     throws DerivativeException {\n       System.arraycopy(currentState,      0, interpolatedState,       0, currentState.length);\n-      System.arraycopy(currentDerivative, 0, interpolatedDerivatives, 0, currentDerivative.length);\n+      interpolatedTime = Double.NaN;\n+\tSystem.arraycopy(currentDerivative, 0, interpolatedDerivatives, 0, currentDerivative.length);\n   }\n \n   /** Write the instance to an output channel.\n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\t2018-12-01 06:00:05.075483730 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_1382/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\t2018-12-01 07:56:23.830242134 -0500\n@@ -292,12 +292,7 @@\n           if (manager.evaluateStep(interpolator)) {\n               final double dt = manager.getEventTime() - stepStart;\n               if (Math.abs(dt) <= Math.ulp(stepStart)) {\n-                  // we cannot simply truncate the step, reject the current computation\n-                  // and let the loop compute another state with the truncated step.\n-                  // it is so small (much probably exactly 0 due to limited accuracy)\n-                  // that the code above would fail handling it.\n-                  // So we set up an artificial 0 size step by copying states\n-                  loop     = false;\n+                  super.sanityChecks(equations, t0, y0, t, y);\n               } else {\n                   // reject the step to match exactly the next switch time\n                   hNew = dt;\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java", 
          "line": 300, 
          "faulty": "loop=false;", 
          "type": "Replace", 
          "seed": "super.sanityChecks(equations,t0,y0,t,y);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/sampling/DummyStepInterpolator.java", 
          "line": 108, 
          "faulty": "System.arraycopy(currentDerivative,0,interpolatedDerivatives,0,currentDerivative.length);", 
          "type": "InsertBefore", 
          "seed": "interpolatedTime=Double.NaN;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_593/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:51:09.059141616 -0500\n@@ -208,7 +208,11 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n@@ -331,9 +335,7 @@\n             return false;\n         }\n \n-        if (nextAction == EventHandler.RESET_STATE) {\n-            handler.resetState(t, y);\n-        }\n+        handler.resetState(t, y);\n         pendingEvent      = false;\n         pendingEventTime  = Double.NaN;\n \n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 334, 
          "faulty": "if (nextAction == EventHandler.RESET_STATE) {\n  handler.resetState(t,y);\n}", 
          "type": "Replace", 
          "seed": "handler.resetState(t,y);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/CombinedEventsManager.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_1043/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/CombinedEventsManager.java\t2018-12-01 07:27:45.001762841 -0500\n@@ -150,7 +150,8 @@\n             for (EventState state : states) {\n \n                 if (state.evaluateStep(interpolator)) {\n-                    if (first == null) {\n+                    initialized = true;\n+\t\t\t\t\tif (first == null) {\n                         first = state;\n                     } else {\n                         if (interpolator.isForward()) {\n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_1043/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 07:27:45.001762841 -0500\n@@ -208,7 +208,8 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    pendingEvent = true;\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/CombinedEventsManager.java", 
          "line": 153, 
          "faulty": "if (first == null) {\n  first=state;\n}\n else {\n  if (interpolator.isForward()) {\n    if (state.getEventTime() < first.getEventTime()) {\n      first=state;\n    }\n  }\n else {\n    if (state.getEventTime() > first.getEventTime()) {\n      first=state;\n    }\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "initialized=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "pendingEvent=true;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_532/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:46:21.349717067 -0500\n@@ -208,7 +208,11 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n@@ -232,21 +236,32 @@\n                         // we have either found nothing or found (again ?) a past event, we simply ignore it\n                         ta = tb;\n                         ga = gb;\n-                    } else if (Double.isNaN(previousEventTime) ||\n-                               (Math.abs(previousEventTime - root) > convergence)) {\n-                        pendingEventTime = root;\n-                        if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n-                            // we were already waiting for this event which was\n-                            // found during a previous call for a step that was\n-                            // rejected, this step must now be accepted since it\n-                            // properly ends exactly at the event occurrence\n-                            return false;\n-                        }\n-                        // either we were not waiting for the event or it has\n-                        // moved in such a way the step cannot be accepted\n-                        pendingEvent = true;\n-                        return true;\n-                    }\n+                    } else {\n+\t\t\t\t\t\tif (ga * gb > 0) {\n+\t\t\t\t\t\t\tfinal double epsilon = (forward ? 0.25 : -0.25)\n+\t\t\t\t\t\t\t\t\t* convergence;\n+\t\t\t\t\t\t\tfor (int k = 0; (k < 4) && (ga * gb > 0); ++k) {\n+\t\t\t\t\t\t\t\tta += epsilon;\n+\t\t\t\t\t\t\t\tinterpolator.setInterpolatedTime(ta);\n+\t\t\t\t\t\t\t\tga = handler.g(ta,\n+\t\t\t\t\t\t\t\t\t\tinterpolator.getInterpolatedState());\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tif (ga * gb > 0) {\n+\t\t\t\t\t\t\t\tthrow MathRuntimeException\n+\t\t\t\t\t\t\t\t\t\t.createInternalError(null);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tif (Double.isNaN(previousEventTime)\n+\t\t\t\t\t\t\t\t|| (Math.abs(previousEventTime - root) > convergence)) {\n+\t\t\t\t\t\t\tpendingEventTime = root;\n+\t\t\t\t\t\t\tif (pendingEvent\n+\t\t\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\t\t\treturn false;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tpendingEvent = true;\n+\t\t\t\t\t\t\treturn true;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n \n                 } else {\n                     // no sign change: there is no event for now\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 235, 
          "faulty": "if (Double.isNaN(previousEventTime) || (Math.abs(previousEventTime - root) > convergence)) {\n  pendingEventTime=root;\n  if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n    return false;\n  }\n  pendingEvent=true;\n  return true;\n}", 
          "type": "InsertBefore", 
          "seed": "if (ga * gb > 0) {\n  final double epsilon=(forward ? 0.25 : -0.25) * convergence;\n  for (int k=0; (k < 4) && (ga * gb > 0); ++k) {\n    ta+=epsilon;\n    interpolator.setInterpolatedTime(ta);\n    ga=handler.g(ta,interpolator.getInterpolatedState());\n  }\n  if (ga * gb > 0) {\n    throw MathRuntimeException.createInternalError(null);\n  }\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_258/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:23:44.647095829 -0500\n@@ -208,7 +208,11 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n@@ -223,7 +227,8 @@\n                             }\n                         }\n                     };\n-                    final BrentSolver solver = new BrentSolver();\n+                    forward = interpolator.isForward();\n+\t\t\t\t\tfinal BrentSolver solver = new BrentSolver();\n                     solver.setAbsoluteAccuracy(convergence);\n                     solver.setMaximalIterationCount(maxIterationCount);\n                     final double root = (ta <= tb) ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta);\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 226, 
          "faulty": "final BrentSolver solver=new BrentSolver();", 
          "type": "InsertBefore", 
          "seed": "forward=interpolator.isForward();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_1335/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 07:52:30.693076665 -0500\n@@ -208,10 +208,68 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n-                    final UnivariateRealFunction f = new UnivariateRealFunction() {\n+                    if (g0Positive ^ (gb >= 0)) {\n+\t\t\t\t\t\tif (ga * gb > 0) {\n+\t\t\t\t\t\t\tfinal double epsilon = (forward ? 0.25 : -0.25)\n+\t\t\t\t\t\t\t\t\t* convergence;\n+\t\t\t\t\t\t\tfor (int k = 0; (k < 4) && (ga * gb > 0); ++k) {\n+\t\t\t\t\t\t\t\tta += epsilon;\n+\t\t\t\t\t\t\t\tinterpolator.setInterpolatedTime(ta);\n+\t\t\t\t\t\t\t\tga = handler.g(ta,\n+\t\t\t\t\t\t\t\t\t\tinterpolator.getInterpolatedState());\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tif (ga * gb > 0) {\n+\t\t\t\t\t\t\t\tthrow MathRuntimeException\n+\t\t\t\t\t\t\t\t\t\t.createInternalError(null);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tincreasing = gb >= ga;\n+\t\t\t\t\t\tfinal UnivariateRealFunction f = new UnivariateRealFunction() {\n+\t\t\t\t\t\t\tpublic double value(final double t)\n+\t\t\t\t\t\t\t\t\tthrows FunctionEvaluationException {\n+\t\t\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\t\t\tinterpolator.setInterpolatedTime(t);\n+\t\t\t\t\t\t\t\t\treturn handler\n+\t\t\t\t\t\t\t\t\t\t\t.g(t, interpolator\n+\t\t\t\t\t\t\t\t\t\t\t\t\t.getInterpolatedState());\n+\t\t\t\t\t\t\t\t} catch (DerivativeException e) {\n+\t\t\t\t\t\t\t\t\tthrow new FunctionEvaluationException(e, t);\n+\t\t\t\t\t\t\t\t} catch (EventException e) {\n+\t\t\t\t\t\t\t\t\tthrow new FunctionEvaluationException(e, t);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t};\n+\t\t\t\t\t\tfinal BrentSolver solver = new BrentSolver();\n+\t\t\t\t\t\tsolver.setAbsoluteAccuracy(convergence);\n+\t\t\t\t\t\tsolver.setMaximalIterationCount(maxIterationCount);\n+\t\t\t\t\t\tfinal double root = (ta <= tb) ? solver\n+\t\t\t\t\t\t\t\t.solve(f, ta, tb) : solver.solve(f, tb, ta);\n+\t\t\t\t\t\tif ((Math.abs(root - ta) <= convergence)\n+\t\t\t\t\t\t\t\t&& (Math.abs(root - previousEventTime) <= convergence)) {\n+\t\t\t\t\t\t\tta = tb;\n+\t\t\t\t\t\t\tga = gb;\n+\t\t\t\t\t\t} else if (Double.isNaN(previousEventTime)\n+\t\t\t\t\t\t\t\t|| (Math.abs(previousEventTime - root) > convergence)) {\n+\t\t\t\t\t\t\tpendingEventTime = root;\n+\t\t\t\t\t\t\tif (pendingEvent\n+\t\t\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\t\t\treturn false;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tpendingEvent = true;\n+\t\t\t\t\t\t\treturn true;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tta = tb;\n+\t\t\t\t\t\tga = gb;\n+\t\t\t\t\t}\n+\t\t\t\t\tfinal UnivariateRealFunction f = new UnivariateRealFunction() {\n                         public double value(final double t) throws FunctionEvaluationException {\n                             try {\n                                 interpolator.setInterpolatedTime(t);\n@@ -242,9 +300,7 @@\n                             // properly ends exactly at the event occurrence\n                             return false;\n                         }\n-                        // either we were not waiting for the event or it has\n-                        // moved in such a way the step cannot be accepted\n-                        pendingEvent = true;\n+                        solver.setAbsoluteAccuracy(convergence);\n                         return true;\n                     }\n \n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 247, 
          "faulty": "pendingEvent=true;", 
          "type": "Replace", 
          "seed": "solver.setAbsoluteAccuracy(convergence);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 214, 
          "faulty": "final UnivariateRealFunction f=new UnivariateRealFunction(){\n  public double value(  final double t) throws FunctionEvaluationException {\n    try {\n      interpolator.setInterpolatedTime(t);\n      return handler.g(t,interpolator.getInterpolatedState());\n    }\n catch (    DerivativeException e) {\n      throw new FunctionEvaluationException(e,t);\n    }\ncatch (    EventException e) {\n      throw new FunctionEvaluationException(e,t);\n    }\n  }\n}\n;", 
          "type": "InsertBefore", 
          "seed": "if (g0Positive ^ (gb >= 0)) {\n  if (ga * gb > 0) {\n    final double epsilon=(forward ? 0.25 : -0.25) * convergence;\n    for (int k=0; (k < 4) && (ga * gb > 0); ++k) {\n      ta+=epsilon;\n      interpolator.setInterpolatedTime(ta);\n      ga=handler.g(ta,interpolator.getInterpolatedState());\n    }\n    if (ga * gb > 0) {\n      throw MathRuntimeException.createInternalError(null);\n    }\n  }\n  increasing=gb >= ga;\n  final UnivariateRealFunction f=new UnivariateRealFunction(){\n    public double value(    final double t) throws FunctionEvaluationException {\n      try {\n        interpolator.setInterpolatedTime(t);\n        return handler.g(t,interpolator.getInterpolatedState());\n      }\n catch (      DerivativeException e) {\n        throw new FunctionEvaluationException(e,t);\n      }\ncatch (      EventException e) {\n        throw new FunctionEvaluationException(e,t);\n      }\n    }\n  }\n;\n  final BrentSolver solver=new BrentSolver();\n  solver.setAbsoluteAccuracy(convergence);\n  solver.setMaximalIterationCount(maxIterationCount);\n  final double root=(ta <= tb) ? solver.solve(f,ta,tb) : solver.solve(f,tb,ta);\n  if ((Math.abs(root - ta) <= convergence) && (Math.abs(root - previousEventTime) <= convergence)) {\n    ta=tb;\n    ga=gb;\n  }\n else   if (Double.isNaN(previousEventTime) || (Math.abs(previousEventTime - root) > convergence)) {\n    pendingEventTime=root;\n    if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n      return false;\n    }\n    pendingEvent=true;\n    return true;\n  }\n}\n else {\n  ta=tb;\n  ga=gb;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_523/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:45:41.929525173 -0500\n@@ -208,7 +208,11 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:01.483483648 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_523/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:45:41.929525173 -0500\n@@ -333,9 +333,12 @@\n                 x1 = x1 + delta;\n             } else if (dx > 0.0) {\n                 x1 = x1 + 0.5 * tolerance;\n-            } else if (dx <= 0.0) {\n-                x1 = x1 - 0.5 * tolerance;\n-            }\n+            } else {\n+\t\t\t\tx0 = x1;\n+\t\t\t\tif (dx <= 0.0) {\n+\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t}\n+\t\t\t}\n             y1 = f.value(x1);\n             if ((y1 > 0) == (y2 > 0)) {\n                 x2 = x0;\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 336, 
          "faulty": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}", 
          "type": "InsertBefore", 
          "seed": "x0=x1;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_1021/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 07:26:08.273293451 -0500\n@@ -208,7 +208,11 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n@@ -337,7 +341,8 @@\n         pendingEvent      = false;\n         pendingEventTime  = Double.NaN;\n \n-        return (nextAction == EventHandler.RESET_STATE) ||\n+        pendingEventTime = Double.NaN;\n+\t\treturn (nextAction == EventHandler.RESET_STATE) ||\n                (nextAction == EventHandler.RESET_DERIVATIVES);\n \n     }\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 340, 
          "faulty": "return (nextAction == EventHandler.RESET_STATE) || (nextAction == EventHandler.RESET_DERIVATIVES);", 
          "type": "InsertBefore", 
          "seed": "pendingEventTime=Double.NaN;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_1016/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 07:25:46.173186096 -0500\n@@ -208,7 +208,11 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n@@ -337,7 +341,8 @@\n         pendingEvent      = false;\n         pendingEventTime  = Double.NaN;\n \n-        return (nextAction == EventHandler.RESET_STATE) ||\n+        pendingEvent = false;\n+\t\treturn (nextAction == EventHandler.RESET_STATE) ||\n                (nextAction == EventHandler.RESET_DERIVATIVES);\n \n     }\n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/sampling/DummyStepInterpolator.java\t2018-12-01 06:00:01.511483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_1016/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/sampling/DummyStepInterpolator.java\t2018-12-01 07:25:46.177186116 -0500\n@@ -104,7 +104,9 @@\n   @Override\n   protected void computeInterpolatedStateAndDerivatives(final double theta, final double oneMinusThetaH)\n     throws DerivativeException {\n-      System.arraycopy(currentState,      0, interpolatedState,       0, currentState.length);\n+      System.arraycopy(currentDerivative, 0, interpolatedDerivatives, 0,\n+\t\t\t\tcurrentDerivative.length);\n+\tSystem.arraycopy(currentState,      0, interpolatedState,       0, currentState.length);\n       System.arraycopy(currentDerivative, 0, interpolatedDerivatives, 0, currentDerivative.length);\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/sampling/DummyStepInterpolator.java", 
          "line": 107, 
          "faulty": "System.arraycopy(currentState,0,interpolatedState,0,currentState.length);", 
          "type": "InsertBefore", 
          "seed": "System.arraycopy(currentDerivative,0,interpolatedDerivatives,0,currentDerivative.length);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 340, 
          "faulty": "return (nextAction == EventHandler.RESET_STATE) || (nextAction == EventHandler.RESET_DERIVATIVES);", 
          "type": "InsertBefore", 
          "seed": "pendingEvent=false;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/CombinedEventsManager.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_204/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/CombinedEventsManager.java\t2018-12-01 06:19:25.257866887 -0500\n@@ -214,7 +214,9 @@\n     public boolean stop() {\n         for (EventState state : states) {\n             if (state.stop()) {\n-                return true;\n+                if (state.stop()) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n             }\n         }\n         return false;\n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_204/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:19:25.257866887 -0500\n@@ -208,7 +208,11 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/sampling/DummyStepInterpolator.java\t2018-12-01 06:00:01.511483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_204/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/sampling/DummyStepInterpolator.java\t2018-12-01 06:19:25.257866887 -0500\n@@ -104,7 +104,9 @@\n   @Override\n   protected void computeInterpolatedStateAndDerivatives(final double theta, final double oneMinusThetaH)\n     throws DerivativeException {\n-      System.arraycopy(currentState,      0, interpolatedState,       0, currentState.length);\n+      System.arraycopy(currentDerivative, 0, interpolatedDerivatives, 0,\n+\t\t\t\tcurrentDerivative.length);\n+\tSystem.arraycopy(currentState,      0, interpolatedState,       0, currentState.length);\n       System.arraycopy(currentDerivative, 0, interpolatedDerivatives, 0, currentDerivative.length);\n   }\n \n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\t2018-12-01 06:00:01.507483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_204/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\t2018-12-01 06:19:25.261866907 -0500\n@@ -147,11 +147,6 @@\n    * ignore the value and compute the initial step size by itself)\n    */\n   public void setInitialStepSize(final double initialStepSize) {\n-    if ((initialStepSize < minStep) || (initialStepSize > maxStep)) {\n-      initialStep = -1.0;\n-    } else {\n-      initialStep = initialStepSize;\n-    }\n   }\n \n   /** Perform some sanity checks on the integration parameters.\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/CombinedEventsManager.java", 
          "line": 217, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "if (state.stop()) {\n  return true;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java", 
          "line": 150, 
          "faulty": "if ((initialStepSize < minStep) || (initialStepSize > maxStep)) {\n  initialStep=-1.0;\n}\n else {\n  initialStep=initialStepSize;\n}", 
          "type": "Delete", 
          "seed": "if ((initialStepSize < minStep) || (initialStepSize > maxStep)) {\n  initialStep=-1.0;\n}\n else {\n  initialStep=initialStepSize;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/sampling/DummyStepInterpolator.java", 
          "line": 107, 
          "faulty": "System.arraycopy(currentState,0,interpolatedState,0,currentState.length);", 
          "type": "InsertBefore", 
          "seed": "System.arraycopy(currentDerivative,0,interpolatedDerivatives,0,currentDerivative.length);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }
      ]
    }, 
    {
      "diff": "\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_1279/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 07:47:34.167579835 -0500\n@@ -208,7 +208,11 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n@@ -297,7 +301,8 @@\n         g0 = handler.g(t, y);\n \n         if (pendingEvent) {\n-            // force the sign to its value \"just after the event\"\n+            t0 = t;\n+\t\t\t// force the sign to its value \"just after the event\"\n             previousEventTime = t;\n             g0Positive        = increasing;\n             nextAction        = handler.eventOccurred(t, y, !(increasing ^ forward));\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/CombinedEventsManager.java", 
          "line": 187, 
          "faulty": "return (first == null) ? Double.NaN : first.getEventTime();", 
          "type": "Replace", 
          "seed": "return (first == null) ? Double.NaN : first.getEventTime();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 301, 
          "faulty": "previousEventTime=t;", 
          "type": "InsertBefore", 
          "seed": "t0=t;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_418/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:37:02.570972371 -0500\n@@ -208,7 +208,11 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\t2018-12-01 06:00:05.075483730 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_418/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\t2018-12-01 06:37:02.574972391 -0500\n@@ -292,12 +292,7 @@\n           if (manager.evaluateStep(interpolator)) {\n               final double dt = manager.getEventTime() - stepStart;\n               if (Math.abs(dt) <= Math.ulp(stepStart)) {\n-                  // we cannot simply truncate the step, reject the current computation\n-                  // and let the loop compute another state with the truncated step.\n-                  // it is so small (much probably exactly 0 due to limited accuracy)\n-                  // that the code above would fail handling it.\n-                  // So we set up an artificial 0 size step by copying states\n-                  loop     = false;\n+                  super.sanityChecks(equations, t0, y0, t, y);\n               } else {\n                   // reject the step to match exactly the next switch time\n                   hNew = dt;\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java", 
          "line": 300, 
          "faulty": "loop=false;", 
          "type": "Replace", 
          "seed": "super.sanityChecks(equations,t0,y0,t,y);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/CombinedEventsManager.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_328/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/CombinedEventsManager.java\t2018-12-01 06:29:21.204714230 -0500\n@@ -106,7 +106,8 @@\n      * @return true if manager is empty\n      */\n     public boolean isEmpty() {\n-        return states.isEmpty();\n+        first = null;\n+\t\treturn states.isEmpty();\n     }\n \n     /** Evaluate the impact of the proposed step on all managed\n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_328/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:29:21.204714230 -0500\n@@ -208,7 +208,11 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/CombinedEventsManager.java", 
          "line": 109, 
          "faulty": "return states.isEmpty();", 
          "type": "InsertBefore", 
          "seed": "first=null;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_746/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 07:03:41.202777494 -0500\n@@ -225,7 +225,11 @@\n                     };\n                     final BrentSolver solver = new BrentSolver();\n                     solver.setAbsoluteAccuracy(convergence);\n-                    solver.setMaximalIterationCount(maxIterationCount);\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\tsolver.setMaximalIterationCount(maxIterationCount);\n                     final double root = (ta <= tb) ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta);\n                     if ((Math.abs(root - ta) <= convergence) &&\n                          (Math.abs(root - previousEventTime) <= convergence)) {\n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\t2018-12-01 06:00:01.507483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_746/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\t2018-12-01 07:03:41.206777513 -0500\n@@ -150,7 +150,7 @@\n     if ((initialStepSize < minStep) || (initialStepSize > maxStep)) {\n       initialStep = -1.0;\n     } else {\n-      initialStep = initialStepSize;\n+      resetEvaluations();\n     }\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 228, 
          "faulty": "solver.setMaximalIterationCount(maxIterationCount);", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java", 
          "line": 153, 
          "faulty": "initialStep=initialStepSize;", 
          "type": "Replace", 
          "seed": "resetEvaluations();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_943/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 07:19:34.155371774 -0500\n@@ -208,7 +208,8 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    pendingEvent = true;\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n@@ -242,9 +243,6 @@\n                             // properly ends exactly at the event occurrence\n                             return false;\n                         }\n-                        // either we were not waiting for the event or it has\n-                        // moved in such a way the step cannot be accepted\n-                        pendingEvent = true;\n                         return true;\n                     }\n \n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 247, 
          "faulty": "pendingEvent=true;", 
          "type": "Delete", 
          "seed": "this.convergence=Math.abs(convergence);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "pendingEvent=true;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_1222/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 07:42:44.242142853 -0500\n@@ -208,7 +208,11 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n@@ -299,7 +303,8 @@\n         if (pendingEvent) {\n             // force the sign to its value \"just after the event\"\n             previousEventTime = t;\n-            g0Positive        = increasing;\n+            g0 = handler.g(t, y);\n+\t\t\tg0Positive        = increasing;\n             nextAction        = handler.eventOccurred(t, y, !(increasing ^ forward));\n         } else {\n             g0Positive = g0 >= 0;\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 302, 
          "faulty": "g0Positive=increasing;", 
          "type": "InsertBefore", 
          "seed": "g0=handler.g(t,y);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_1148/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 07:36:32.764312668 -0500\n@@ -188,7 +188,8 @@\n                 if (g0Positive ^ (gb >= 0)) {\n                     // there is a sign change: an event is expected during this step\n \n-                    if (ga * gb > 0) {\n+                    pendingEventTime = Double.NaN;\n+\t\t\t\t\tif (ga * gb > 0) {\n                         // this is a corner case:\n                         // - there was an event near ta,\n                         // - there is another event between ta and tb\n@@ -208,7 +209,8 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    pendingEvent = true;\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/sampling/DummyStepInterpolator.java\t2018-12-01 06:00:01.511483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_1148/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/sampling/DummyStepInterpolator.java\t2018-12-01 07:36:32.768312687 -0500\n@@ -104,7 +104,9 @@\n   @Override\n   protected void computeInterpolatedStateAndDerivatives(final double theta, final double oneMinusThetaH)\n     throws DerivativeException {\n-      System.arraycopy(currentState,      0, interpolatedState,       0, currentState.length);\n+      System.arraycopy(currentDerivative, 0, interpolatedDerivatives, 0,\n+\t\t\t\tcurrentDerivative.length);\n+\tSystem.arraycopy(currentState,      0, interpolatedState,       0, currentState.length);\n       System.arraycopy(currentDerivative, 0, interpolatedDerivatives, 0, currentDerivative.length);\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 191, 
          "faulty": "if (ga * gb > 0) {\n  final double epsilon=(forward ? 0.25 : -0.25) * convergence;\n  for (int k=0; (k < 4) && (ga * gb > 0); ++k) {\n    ta+=epsilon;\n    interpolator.setInterpolatedTime(ta);\n    ga=handler.g(ta,interpolator.getInterpolatedState());\n  }\n  if (ga * gb > 0) {\n    throw MathRuntimeException.createInternalError(null);\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "pendingEventTime=Double.NaN;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/sampling/DummyStepInterpolator.java", 
          "line": 107, 
          "faulty": "System.arraycopy(currentState,0,interpolatedState,0,currentState.length);", 
          "type": "InsertBefore", 
          "seed": "System.arraycopy(currentDerivative,0,interpolatedDerivatives,0,currentDerivative.length);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "pendingEvent=true;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_581/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:50:18.514895117 -0500\n@@ -208,7 +208,11 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n@@ -334,7 +338,7 @@\n         if (nextAction == EventHandler.RESET_STATE) {\n             handler.resetState(t, y);\n         }\n-        pendingEvent      = false;\n+        pendingEventTime = Double.NaN;\n         pendingEventTime  = Double.NaN;\n \n         return (nextAction == EventHandler.RESET_STATE) ||\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 337, 
          "faulty": "pendingEvent=false;", 
          "type": "Replace", 
          "seed": "pendingEventTime=Double.NaN;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_1040/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 07:27:34.481711828 -0500\n@@ -208,7 +208,11 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:01.483483648 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_1040/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 07:27:34.481711828 -0500\n@@ -334,7 +334,8 @@\n             } else if (dx > 0.0) {\n                 x1 = x1 + 0.5 * tolerance;\n             } else if (dx <= 0.0) {\n-                x1 = x1 - 0.5 * tolerance;\n+                oldDelta = x2 - x1;\n+\t\t\t\tx1 = x1 - 0.5 * tolerance;\n             }\n             y1 = f.value(x1);\n             if ((y1 > 0) == (y2 > 0)) {\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 337, 
          "faulty": "x1=x1 - 0.5 * tolerance;", 
          "type": "InsertBefore", 
          "seed": "oldDelta=x2 - x1;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_1079/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 07:30:33.158577156 -0500\n@@ -208,7 +208,8 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    pendingEvent = true;\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/sampling/DummyStepInterpolator.java\t2018-12-01 06:00:01.511483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_1079/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/sampling/DummyStepInterpolator.java\t2018-12-01 07:30:33.158577156 -0500\n@@ -104,7 +104,9 @@\n   @Override\n   protected void computeInterpolatedStateAndDerivatives(final double theta, final double oneMinusThetaH)\n     throws DerivativeException {\n-      System.arraycopy(currentState,      0, interpolatedState,       0, currentState.length);\n+      System.arraycopy(currentDerivative, 0, interpolatedDerivatives, 0,\n+\t\t\t\tcurrentDerivative.length);\n+\tSystem.arraycopy(currentState,      0, interpolatedState,       0, currentState.length);\n       System.arraycopy(currentDerivative, 0, interpolatedDerivatives, 0, currentDerivative.length);\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/sampling/DummyStepInterpolator.java", 
          "line": 107, 
          "faulty": "System.arraycopy(currentState,0,interpolatedState,0,currentState.length);", 
          "type": "InsertBefore", 
          "seed": "System.arraycopy(currentDerivative,0,interpolatedDerivatives,0,currentDerivative.length);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "pendingEvent=true;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:00:01.503483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_667/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/events/EventState.java\t2018-12-01 06:56:59.304835888 -0500\n@@ -208,7 +208,11 @@\n                         }\n                     }\n \n-                    // variation direction, with respect to the integration direction\n+                    if (pendingEvent\n+\t\t\t\t\t\t\t&& (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n\n\n--- /tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\t2018-12-01 06:00:01.507483649 -0500\n+++ /tmp/Arja_Defects4J_Math_71/patches_6k3o/Patch_667/patched/tmp/Arja_Defects4J_Math_71/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\t2018-12-01 06:56:59.308835908 -0500\n@@ -289,7 +289,9 @@\n       }\n \n       if (filteredH > maxStep) {\n-          filteredH = maxStep;\n+          if (initialStep > 0) {\n+\t\t\treturn forward ? initialStep : -initialStep;\n+\t\t}\n       } else if (filteredH < -maxStep) {\n           filteredH = -maxStep;\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java", 
          "line": 292, 
          "faulty": "filteredH=maxStep;", 
          "type": "Replace", 
          "seed": "if (initialStep > 0) {\n  return forward ? initialStep : -initialStep;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/ode/events/EventState.java", 
          "line": 212, 
          "faulty": "increasing=gb >= ga;", 
          "type": "InsertBefore", 
          "seed": "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n  return false;\n}"
        }
      ]
    }
  ]
}